{"0 - 296.32": "this complete c plus plus course will take you from being an absolute beginner to using advanced c plus plus features danielle gaguaya teaches this course he is an experienced software developer and has created many popular courses hello guys and welcome to this modern c plus plus 20 course this is a course that is going to take you from the absolute beginning where you know nothing about c plus plus and you're going to go all the way to a point where you can use some advanced features in the c plus plus programming language that includes things like object-oriented programming with inheritance and polymorphism with the c plus plus programming language now i'm not going to spend a lot of time convincing you on why you should use c plus plus but c plus plus is a very powerful programming language you can use to do all kinds of crazy things you can use it to do systems programming you can build games with it and it is used in a wide range of areas so you can do a lot with c plus plus now who is this course for this course is built for complete beginners if you already have some experience with c plus plus you will still find some good things you can learn from the course but i am going to go from the absolute beginning showing you every little thing showing you the tools showing you the compilers and the editor we're going to be using here so we're going to spend a lot of time making sure you understand the fundamentals by the time you are done with this course you will understand the bare fundamentals about c plus we will spend a lot of time exploring the procedure programming side of c plus plus so you're going to be writing programs that run from top to bottom and we're going to spend a lot of time in the editor writing code making sure you really understand what is going on here towards the end we're going to learn about object oriented programming and we're going to touch on classes inheritance and polymorphism and these are the tools you're going to be using a lot in your career as a c plus plus developer another great feature of this course is that we spend a lot of time making sure you understand the tools so if you don't know what a compiler is if you don't know what an ide is we're going to make sure you understand these things and we're going to spend a lot of time using these things and by the time you're done with the course you're going to be very comfortable using the tools the editor of choice for the course is going to be visual studio code so that's an editor that is going to allow us to type in the code and give us some things like a syntax highlighting but we're going to be connecting our editor to a background compiler which is going to make sure our code is transformed to run on our computer but don't worry about all that craziness right now we're going to go in detail about these things for now i just want you to have a bird's eye view on what you can expect from the course here now i hope you know what to expect from the course but i also expect you to be ready to take the course and the requirements are really not that bad the only requirement is that you have time set aside to really practice what you learn from the course here and you need to have a strong drive and willingness to learn now if you want to follow along i am going to share a link to the github repository for the code i use in the course so you can check that out and really follow along if you want if you want some support we have a discord server dedicated for our students so you can join and be part of the community if you have a question you can ask but another thing i would encourage you to do is to also help others so if you see somebody asking a question try to help them you're going to learn a lot that way okay now that you know a bit about the course let's talk about myself here my name is daniel cacoya i am a software engineer i have been writing code since 2011 or something and i am a professional c plus plus developer i do a lot of freelance work i work for a few companies i do all kinds of crazy things i also like to teach others so i have a few courses on udemy if you are interested in cute you can check these things out i also have a trending c plus plus course that you can check out but don't feel the need to go and check this ziplesque course out because a lot is covered in this youtube course here so that's really all about me okay now that you have an idea about the course we're going to head over in the next lecture and learn about the tools we're going to be using throughout the course here go ahead and finish up here and meet me there welcome to this new chapter where we're going to be exploring the c plus plus development tools you need to start writing your own c plus plus applications and you really need two kinds of tools the first one is going to be an editor or an ide through which you're going to be writing your c plus", "296.32 - 596.32": "visual studio code as an editor in this course because it is very easy to install it is cross-platform it is going to run well on windows mac and linux and it supports a host of tools that are going to make your job easier as a surplus plus developer but that's not to say you can't use your favorite ide if you can but visual studio code is going to be our main editor in this course so i would recommend installing it to be able to follow along with what we do here now after we have an ide or an editor in place we will need a compiler and the compiler is a piece of software that takes the code we write in the editor and compiles that into code that can directly run on the hardware or binary executable format so this is what we're going to be doing here we're going to be typing our code in an editor like visual studio code we're going to be kicking off a process to compile our program and this is going to turn our program into a format that can run it directly on the hardware so for example if you are on a windows machine you're going to generate a binary executable that can directly run on windows if you are on linux we will generate a binary that can run on linux and the same concepts can really extend on mac or any other kind of operating system you might be working on with the course here so we need two tools we need an ide or an editor and a compiler and the tools you install are going to be depending on the operating system you are using to watch the course if you are on windows you're going to install a set of tools that are specific to windows if you are on linux you're going to install a set of tools for linux if you are on a mac you're going to install a set of tools specific to the apple operating system for desktop now on windows in terms of ides or integrated development environment it is possible to use a host of ides for example you can use code lite it is an ide you can use you can use microsoft visual studio but in this course we're going to be using visual studio code because it is easy to install it has a set of features that are really good it is popular it has a great community around it i think you're going to have a great time as a beginner to start writing your c plus plus programs using visual studio code that's not to say that you can't use another ide you can if you want but i am going to be using visual studio code in this course here now on linux we are also going to be using visual studio code as our editor in the course but there are other ides you can use for example you can use cute creator if you want you can use codelight you can use a host of other ides on linux but again visual studio code is going to be our thing in the course here and i would recommend installing it on your linux box if you are watching this course on the linux machine so for osx we are also going to be using visual studio code as our editor as i said it is cross platforms it runs where regardless of the operating system you might be using to watch the course but if you want you can use the apple ide which is xcode or even code lite all these are going to work if you want but again i would recommend going with visual studio code.plus to start out so that we have a common ground and you don't get confused very easily especially if you are a beginner now after we have an ide rolling we will need a compiler and as we say the compiler is a tool that is going to transform your c plus plus code into a format that can run directly on the hardware so the compiler you use again is going to depend on the operating system where you are watching the course i am going to show you a bunch of compilers you can use but gcc is going to be our common base so on windows i will be using what we call mingw don't worry if you don't what it is i am going to show you in a minute when we install it but this is a project that brings the gcc compiler on windows so that we can use it easily and i am going to show you how to install it but i am also going to show you how to install the compiler from microsoft and the clang llvm compiler these are all available to you on windows and it is really easy to install them these days and i will be using them all if you are on windows i would recommend installing them all so that you really have a chance to try your c plus plus code on the different compilers and that's a really good thing to do if you test your c plus plus code against multiple compilers you will be increasing your chances for your code to really be portable and work on multiple compilers and operating systems and that cannot be a bad thing so i would recommend installing all these compilers if you are on windows i am also going to show", "596.32 - 898.0": "linux i am going to show you gcc we're going to install the shiny new feature in gcc we're going to install clang lvm on linux and we will be able to use all these compilers again if you are on linux i would recommend installing all these compilers so that you have a chance to try your code against multiple compilers and that's going to make your code much portable and easier to use on multiple compilers and platforms on the mac i am going to show you how to install gcc and i am going to show you how to install clangle lvm but if you want you can also install xcode and the compiler that comes with that for c plus but development all these are options to you but again in this course we are mostly going to be using the gcc compiler so i would recommend getting a hold of this if you don't want to install other compilers if you only have to install one compiler please install gcc that's going to be our main compiler in the course here okay so these are the tools we need we are going to head over in the next lecture and show you how to install the visual studio code editor on windows and really get started with that go ahead and finish up here and meet me in the next lecture this video i am going to show you how to install a c plus plus compiler on your windows operating system so we're going to be looking at three kinds of compilers we're going to look at the mingw compiler which gives us access to a gcc like compiler on windows we're going to look at clan llvm which is another compiler we're going to look at the compiler from microsoft now before we talk about any compiler i would like you to come to google or your favorite search engine and say c plus plus compiler support okay so we're going to choose this little guy here and this is really going to give us a berg's eye view on which feature is supported by which c plus plus compiler for example if we are interested in c plus plus 20 which is the lattice standard that we have in simplest plus at the time of recording this video i am recording of this in august 2021 but if we go here we're going to see c plus plus 20 core features and we're going to see that we have a list of what each compiler supports we have gcc we have clan we have msvc we have the clan version from the apple company and if we scroll down we can really see the features that are supported by each compiler again gcc is going to be our choice in this course this is going to be our main compiler but nothing really stops you from using the clan compiler or the msvc compiler and if you happen to see that your compiler of choice doesn't support what you need for example you can see that at the current time lambdas in an evaluated context are not supported in clan you can see that it is ready here but this is a feature you can use both in gcc and the msvc compiler from microsoft so keep an eye out on this page here to know which kind of things you can use in your compiler if you try something out and you see that it doesn't work this is a good place to come and figure out if your compiler supports the feature that you are using in this video i am going to show you how to install the three most common compilers and those are gcc clang msvc if you want you can come in your search engine and type gcc to see what this is it is a good thing to do to learn about your tools here you can see that it is a compiler that is mostly used on the lenox platform but we can also use it on windows the latest release that we're going to be installing is eleven two zero i think it was released six days ago so it is really fresh and we're going to be taking advantage of this another thing i should say here is that you should install the latest tools you can get your hands upon this is the version we're going to be mostly using in this course but if you are watching this in the future you're going to have a newer version i would recommend installing the latest version or the newest version you can get your hands upon so the first we're going to do is install a gcc compiler on windows i am going to show you a way we can get both gcc and clang in one go and to get access to that please go in your search engine and type windlabs and this is going to bring us to this project here if you want you can click upon this and this is a cool project by a guy who is providing worlds for these compilers that we can use on windows so if you want you can just go down here and look at the lettuce releases again i recommend using the lettuce you can get your hands upon in this case the lettuce happens to be 1120 but in the future this is going to change you're going to find a version for 12 or 13 so please grab the newest version you can get your hands up on now", "898.0 - 1195.1200000000001": "says that it has llvm and clang so if you are on a 32-bit version on windows i would recommend getting this 7-zip archive on this zip archive here if you are on 64 i would recommend getting a hold of this or this little thing here it doesn't really matter but make sure you get the latest version you can get your hands upon and you can see that this conveniently says latest here so i am going to download the 64-bit version on windows i am going to grab the zip archive here and let's click upon this this should kick off my download and this is going to download on my system i can download this if i want and you're going to see that it is going to start downloading here and i am going to wait for this to finish again this is going to give us both the gcc compiler and the clan compiler and this is really like shooting two birds with one stone so this is going to be really good i already have this downloaded so i am just going to head over to the location where i have this downloaded i think i can just go in my drive here so let's crack this open and go in my downloads folder and if i go in my compressed folder i am going to find winlabs llvm and mingw this is what you really want but if you don't want the clan compiler you can grab the one that doesn't say llvm here because we really want both of these compilers we are going to grab the one that has both the gcc compiler and the clan compiler if we crack this open let's open this together so that you can see what is happening we are going to have this little folder here if we go in we're going to find a bin folder if we go in and crack that open we're going to have a folder that says clang you see we have a clang compiler we have our clan plus plus compiler for c plus plus and if we go down we're going to find our g plus plus compiler and the gcc compiler this is what we want so what we are going to do is extract this somewhere on our system i put this on my c drive so if you go here you're going to find mingw64 so all you really have to do is go where you downloaded your compiler and say extract we're going to right click on this and say extract to a location and you're going to specify where you want this to go and this is going to be extracted or even if you want you can extract here this is something i like to do this is going to show up in the current folder and you can grab this and paste that in a location where you want this in my case i put this in my c drive as i said here so this is going to be my compiler now once you have these compilers installed again we have the clan compiler we have the gcc compiler if we go down we're going to find the g plus plus we even have gdb which is a debugger we can use to debug c plus plus applications but we will talk about this later once you have this i would recommend putting this in your environment variables on windows the way you do this you grab this path well we have our compilers here and we're going to copy this this is something i recommend and on windows 10 you can go on the start menu and type env and this is going to give us a window in which we can edit our environment variables we're going to click on this little thing this is going to open up on our system we're going to wait for this to open up and we're going to have a window that says system properties we're going to click on environment variables here and we can put this in our user environment variables or on our system environment variables since i am the only one using this system i like to put this in my path for my system variables so i am going to click on path and click edit here and i am going to add a path to my gcc and cloud installation here you can see that right here if you don't have this end you can click on new you're going to have a window here and you can paste this right in and you can click ok but i'm not going to do that because i already have this in here so what i am going to do is just delete this let's see if i can delete i can delete this little guy and i have my path in here so if you don't have this in please make sure you have this in your environment variables so we're going to cancel out of this but if this is the first time you do this you should click ok and one way to test that your environment variables are working or even if your compilers are working is to crack up a command line terminal so we're going to say cmd on the start menu here and all you need to do is say g plus plus just like this dash dash version if you do this you're going to see information about your c plus plus compiler and this is coming from the installation we just did and for clan you can say", "1195.1200000000001 - 1495.2": "to tell you the information about your clan compiler installation let's wait for this to come up i don't know why it's slow but you can see that we have a clank compiler the lattice version is 1201 for the gcc compiler the latest version is 1120 and these are the compilers we can use to write c plus plus 20 applications okay so by now we have a gcc compiler through the main gw project we have a client llcm compiler on our system we are also going to see how to get a hold of the compiler from microsoft and to get hold of this you need to install microsoft visual studio to install microsoft visual studio all you have to do is come to your favorite search engine and say microsoft visual studio we can look at the 2019 version which is the latest i think and we're going to click on the download link here we have as the first link and we're going to see ways we can download this little guy now microsoft visual studio has a community version you can download for free but we also have a professional and enterprise versions that we're not going to care about in this course here we are just going to download the community version and that's going to be enough for our purposes here so if you click on free download here this is going to download and install the visual studio compiler you can click on this little guy and it is going to download an installer you're going to crack this open on your system and it is going to install the visual studio installer so once you have it installed you can come to the start menu here and say visual studio installer i think if you say visual studio you're going to have this pop-up somewhere on your system we're going to click on this and if you crack the installer open you're going to see a window like this which is really going to give you a chance to install the tools you want to use with the microsoft visual studio ide and in this case we are interested in desktop development with c plus plus so we're going to click this little guy here we're going to take it open and once you do this you going to click download and install and this is going to install the visual studio compiler with the underlying compiler you see that this is going to give us access to the msvc compiler and all kinds of crazy things we really needed to write c plus plus applications on windows using the compiler from microsoft now i have to say this is going to take some time to install so if you see that this takes up 20 minutes of your time don't worry this is really normal because this id and the compiler behind it and really large they're not like the gcc or the clan llvm compilers that we just installed okay so once you have this ticked or checked you're going to click on download or install whatever this button is saying here this is going to install both the microsoft visual studio ide and the compiler from microsoft that you can use directly to write c plus plus applications so once we have this open i am going to suppose that you have this installed already i am going to close out of this because i don't want to do this and you're going to have visual studio installed on your system once you have this installed you're going to come to the start menu and say developer and this is going to bring up two things one is going to be the developer powershell for visual studio 2019 and the other is going to be a command prompt it doesn't really matter what you choose i am going to click on the command prompt here and once you do this this is going to give you a terminal or a window through which the environment variables are already in to start using the compiler from microsoft and if we come here and type cl.exe we're going to see that we're going to see the information here if this gives you an error or something you're going to know that you didn't really install this properly so please go back and make sure you have this installed if you have a problem you can ask me i can do the best i can to help you out but by this moment we have three compilers on windows that we can use for c plus plus development we have the mingw or the gcc compiler in our hands we have the klanga lvm compiler and we have the compiler from microsoft and now we can install an ide or an editor and that's going to be visual studio code and we can connect that to these compilers so that we can start writing our own z plus bus 20 applications we are going to head over in the next lecture and install the visual studio code editor go ahead and finish up here and meet me there in this lecture i am going to show you how to install the visual studio code editor on windows so if you are watching this course on windows this video here is going to be a must watch we are going to head over to our search engine and type visual studio code this is going to give you a link where we can download this cool editor if you want you can learn all you can about it it is", "1495.2 - 1796.1589999999999": "it supports multiple languages but we're going to be using that specifically for c plus plus in the course here here i am at the page for the editor and you can read all you want about it but we are interested in downloading this for windows if you want you can click on this download button here but i am just going to scroll down and have download links for windows if i want i can click on user installer system installer you can click on what you want if you are on a 32-bit system you're going to download a 32-bit version i am just going to click on 64-bit here because i am on a 64-bit operating system again in this video we are doing this for windows so this is going to be our area of interest here i am going to click on this download link and i am going to wait for things to kick off and i will have a window to start downloading visual studio code setup here i can save this file and it is going to start downloading once it is downloaded i am going to double click and really click my way through this until i have a visual studio code installed on my computer here okay the download is good i can crack this open let's click on this and you're going to see that it is saying that it has detected that visual studio code is already running on my system because i have it installed but if you don't have it installed you're going to click your way through and install this on windows and after you have it you can start it okay once you start visual studio code you're going to have a window like this if you run it for the first time you are probably going to see a windows with documentation and whatever let's look at the welcome screen you're going to probably see you're going to probably see something like this but i am not sure but the most important thing is that you're going to have a window like this with visual studio code the first thing we want to do for c plus plus development is going to scroll down and click on this little thing that says extensions i am going to click on this and i am going to go in my search box here and type c and c plus i can even type c plus plus it doesn't really matter and this is an area where we can install extensions to make visual studio code do all kinds of crazy things in this case we are interested in making it support c and c plus plus so we are going to click on this extension that says microsoft here cnc plus plus i am going to click on this and if you don't have it installed you can click on the install button and it is going to install this little thing and make your computer ready to use visual studio code for c plus plus so make sure you install this and at the end it is going to say disable or uninstall because it will be already installed and enabled on your computer and this is really the end of our installation video for visual studio code we are going to head over in the next video and show you how you can make a visual studio code use the compilers that we installed in the previous video so go ahead and finish up here and meet me in the next lecture in this video we're going to see how to connect our visual studio code editor to a compiler so that we can compile our projects easily through the visual studio code editor we already have the ide installed from the last two previous lectures when we have a compiler installed in the last lecture we installed the gcc compiler through the mingw project we installed the clangela vm compiler we even installed the compiler from microsoft now we're going to connect the ide to the compiler to make it really easy to compile c plus plus applications using these tools here what i am going to do is really set up a template project we're going to be reusing throughout this course here so i am going to go on a folder in my system and i am going to right click on the folder and say open with visual studio code let's do this this is going to open this folder in visual studio code and i am going to trust this folder here be careful what you trust because some things are going to do some malicious things on your computer make sure you trust the folders that you open up so i am going to trust myself because i am the creator of this folder here and this is going to open visual studio code now in our install video we installed the c plus plus extension for visual studio code again if you don't have this installed please make sure you go back and install and make sure this is saying that this is enabled and now we want to use this to write c plus plus applications here we're going to write a simple toy c plus plus application to just test that our compilers support c plus plus 20 and then we're going to use this as a starting point or as a template project so i want you to click on this little plus icon here", "1796.1589999999999 - 2095.7599999999998": "main.cpp and once you do that you will be able to type c plus plus code in this year so we are just starting out here i would recommend to type this exactly as i do here so we're going to say include and say opening angle bracket and say io stream and we're going to go down here and say and main and we're going to go inside these curly braces and say auto result and you are going to exactly type what i tap here don't worry we're going to have a chance to learn about all these things here so i am going to put a pair of parentheses and i am going to say 10. and i am going to put a weird operator here this is called the spaceship operator it is just something we can use to test that our compiler supports it plus plus 20 and we're going to put a 20 here and then we're going to try and see if this is greater than zero and we're going to print this out we're going to say stdc out again don't worry if you don't know what this is this is just a way for us to test and see if our compiler is going to be able to use c plus plus 20. we're going to say result here and this is going to be our program now we want to make sure we compile this program so to bring in your compilers in visual studio code all you have to do is come to the terminal menu here so please come here and we're going to have an option to configure tasks i want you to click on this and once you do this you're going to see that visual studio code is going to find the compilers that we just installed you see that it has found the gcc compiler we installed in mingw you see that it has found the clan compiler i know about the g plus plus compiler because you can see the path here you can see c major w ben g plus plus dot exe this is where we installed our g plus plus compiler and i know about the clank compiler because that's what's being found here for example on this entry here you see it says cmajw bin clan plus plus so we wanted to configure these two compilers here and later visual studio could use them to build our c plus plus 20 projects now what we're going to do is click on the g plus plus compiler first and when we do that this is going to create a tasks that json file in our project and you see that it has created a folder called dot vs code if i click on my main cpp file here and do reveal in explorer this is going to open up on my system and you see that this has created a dot vs code folder and if we go and we're going to find this tasks.json file this is going to be our configuration to configure which compilers that visual studio code is using to compile our main.cpp file here so if we go in it's going to really have everything ready for us so you're going to see that it's going to be using our g plus plus compiler this is the path to it and in our args options here we have the options that we pass to the compiler to compile our program here now i want to change this to say which kind of compiler we are using so we're going to change the level here to say world width g plus plus and say the version i think that's going to be more descriptive here so we're going to save world with g plus plus or gcc and we're going to say 11.2.0 because that's our version here and the rest is really going to be enough so let's try and see if we can compile our program here and see the thing here printing out but the other thing we need to do because this program is using c plus plus 20 we need to configure our compiler to use c plus plus 20. and one way to do that in gcc and you can really search these things for example if we come to our search engine here and say configure gcc to use c plus plus 20 or even gcc and say c plus plus 20. you can search these things and find information and it is a really good way to test your things here so let's see if we can find a link to help out we have a stack overflow link here so we can crack this open and if we go and we're going to find a batch of things for example we can say std c plus plus 20 here as an option to our compiler and this is going to bring c plus plus 20 support in our gcc compiler so i am going to copy this and i am going to come back in my visual studio code editor and i am going to pass a flag to boiled in c plus 20 mode and it is something i just got from stack overflow here and we are going to pass this to our compiler and put a comma to make this a valid", "2095.7599999999998 - 2395.04": "close this now once we have this open and we want to build this we need to bring a terminal window so we we're going to bring the terminal window so that we can see things happening and we do that by coming to terminal and saying the new terminal and we will come back to terminal again and say that we want to run a task in this case we're going to be running our world with gcc 1120 again if you are using a newer version that's what you should use and if we click on this thing please make sure you have the main cpp file selected before you do this so i have this selected and i'm going to go to run task and i am going to click on this little thing you're going to see that this is going to kick off the process to build our program and we're going to wait for this to finish and you're going to see that it is using c plus plus 20 here we're going to see that the world finished successfully and we have a main.exe file created here so if we go in our terminal in visual studio code and click enter and type clear and hit enter this is going to clear the screen this is something you can do to clear things out we can run this main.exe binary directly here so we're going to run exe here and if you run it it's going to say zero and this is an indication that we have our visual studio code editor connected up to our gcc compiler and we can use that to compile c plus plus applications and this is really the configuration with it now you may ask how do i know this how do i did i know the steps to follow to get this to work well if you come to extension tab here and before we even do that i want to bring to your attention that we have a bunch of tabs here in visual studio code we have a tab that says file i think the one here saying explorer we have a one we can use for version control if you use something like git or whatever you can use this but in this course we're mostly going to be using the explorer tab here and the extensions tab to install things and at a later time i will show you how to use the debug tab here or run a debug tab but in most cases we're going to be using the explorer tab or the extensions tab here if you want you can click on this to close this so that you have some more space you can click again to bring this back these are some things you can do in visual studio code but i am going to show you how to configure your compilers where i got the information so click on extensions here and we're going to find our cnc plus plus extension if we scroll down we're going to find tutorials on how to set up this on different compilers for example you can crack this open to see how to set up a visual studio code to use your compiler from microsoft if we come back we can see a link to see how to use this with mingw on windows let's click on this and let's see what else we have we can come back to here and we can see how to use this with gcc on linux or clango on a mac you can really choose whatever is relevant for your operating system but in this case here we are just using the windows operating system so we're going to see how to use this with the mingw compiler that we just installed now we can use the mingw compiler and i would recommend reading up on this entire thing to have an idea on what is happening we already have our g plus plus compiler so this is this command is going to work again if we come back to terminal here and run g plus plus version i think we can see that we run these commands here to see these things working so we have this step here and if you wonder what gdb is it is just a debugger you can use to debug your programs and again if we come to our terminal here and say gdb version we're going to have this available from our mingw installation you can see that we have this here so this is working just fine you can really follow this and configure your visual studio code installation but i am just showing you how to do this pretty fast you can see that this is what we set up in our configuration file which is our tasks dot json file now one thing you can do is modify the task.json file to build every single file in your project and this is something that is going to make things easier what i'm going to do is go back to our visual studio code instance and find our project we're going to crack open our tasks that json file which is living in our dot vs code folder and i am going to take out the craziness i have in my arguments here i am going to select everything i am going to delete that and i am going to put in a configuration that i am using for my projects here to make this super easy what this is doing it is telling the compiler to build in c", "2395.04 - 2696.96": "visual studio it is going to tell the compiler to build every single cpp file in our project so if we have multiple files they are going to be built together and we're going to specify the name for our output file for example if we don't want our binary executable to be named mainly.exe we can give it a name and i am going to be naming mine rooster.exe in the course here i would recommend doing the same so that we can really have the same habits as we go through the course here but of course you are free to use whatever you want in your c plus plus programs here so once you have this you can click save here and this is going to save our json file here i can close this and i am going to bring my terminal by going to view and the terminal here this is going to bring back my terminal that i had before and i am going to run the clear command and hit enter and i am going to do dir to show the contents of my folder on windows here i wanted to remove the main.exe file from the terminal here so what i am going to do is say rm and i am going to say the name of the file i want to remove i am going to say main dot exe and if i hit enter notice what is going to happen the file is going to go away i don't see it anymore here i want to build again using my new configurations in my tasks the json file i am going to run the task to build with our gcc compiler this is going to build again and you see that it is using the configurations that i passed you see that it is building every single cpp file in the directory here and it is going to generate a program called rooster.exe and we if we look here we're going to find it we can hit enter in the terminal and we can type clear to clear things out and if we do the ir again we're going to see that we have rooster.exe and we can run it by doing rooster.exe here and this is going to do what we want this is really all you need to do to connect visual studio code to your gcc compiler now we're going to connect visual studio code to our clan compiler that we have installed we really want to be able to use it with our project here and we're going to go through the seven steps again so we're going to go to terminal and say configure tasks and we're going to choose something that says the clanger compiler and we're going to find clang plus plus so let's hunt for that i have something that says that here we have cloneplusplus.exe i am going to click on that and if i do this this is going to add an entry in my tasks.json file so watch out for this i am going to click on this and let's crack this test that json file open and you're going to see that this is going to also set up another configuration to world using my clang plus plus compiler and again i can edit this out a little bit to say what we want let's look at the version of cloud we have installed to say that out this is going to be 12 0 1 so we're going to say world with clank plus plus 12 0 1 let's say that here in our level 12.0.1 we can say that right here and you see that it is really doing the same thing we did with our gcc compiler so what i can really do is still everything i did in my gcc compiler i can copy this and i am going to take out the arguments i have in my args here and i use what i have in my gcc compiler you can see that you can use the client compiler and the gcc compiler in the same way and this is something really cool so now we have the option to use two compilers and this is really cool so we're going to close the json file and it's going to be saved automatically and we're going to bring up our terminal window again and let's bring this up a little bit and we're going to do dir on windows and we're going to remove the binary again we're going to remove roster.exe and again what you can do you can start typing the name of the file you want to remove and hit tab if you do that the terminal is going to autocomplete this for you and this is really cool so if i do this the file is going to go away you see that it is going right here and i can clear and what i am going to do is world with the clan compiler can do that by coming to terminal i am going to say that i want to run a task and i am going to be given an option i can either build with gcc so if i choose gcc here it's going to be used but i can also use clan let's use clang here so i'm going to click on this and you're going to see that visual studio code is going to kick off the world process this is going to build my binary", "2696.96 - 2996.0789999999997": "plus plus 20 again the build is going to finish successfully and i will have a binary here and this is going to be all i need to do so if i hit enter and run my binary by tapping the name and hitting tab this is going to auto-complete if i run it it's going to say zero and this is what we expect here if you have some kind of error please try and fix it if you have a problem you can ask me and i will do the best i can to help you out okay now we have our two compilers working we need to configure the compiler from microsoft now the compiler from microsoft is a little bit weird again you can read up on this by coming to your extension documentation and going to using the compiler from microsoft with visual studio code on windows you can read up on all this if you want but i am just going to show you a quick way to get this running so the compiler from microsoft is special in that you have to specify the path to it for example if we open a regular terminal window and say cl.exe to call the compiler we're going to see that the terminal is going to say that the cl.exe compiler is not recognized and the reason is we don't have the proper environment variable settings for the operating system to find this compiler when we call it right here we are able to use g plus plus and clan because we put the environment variables in place if you remember when we installed them we did something like this we came to the start menu and did env we came to environment variables here and we put the path to our compilers in our environment variables here you can see them right here so we don't have the same thing for the compiler from microsoft and that's for a reason because we may have multiple compilers installed from microsoft then if you have multiple compilers it would be really cumbersome to choose which compiler you want the guys at microsoft opted for the option for you the developer to specify which compiler you want to run by coming to the start menu here and typing developer and choose which powershell for the compiler you want to use for example if we want to use the visual studio 2019 compiler we can click on this and then we will have a terminal that can run the c plus plus compiler from microsoft for example if we wait for this to be ready and say cl.exe we're going to see that we're going to have a message saying that this is our compiler we can use it however we want so what we're going to do is set up a terminal like this and use this terminal to start visual studio code and the visual studio code is going to start in the mode where it can find the compiler from microsoft i know this is confusing but please bear with me this is what we need to do to get this to work if we start visual studio code in a mode where it knows about the environment variables for the compiler from microsoft we will have the ability to say cl.exe and we will be able to use that right here but you see that it is not recognized now but we can use the g plus plus compiler if we do this version we're going to see that it's available we can use it we can use clan plus plus and if we do version as well we're going to see that we can use this little guy here we also want the ability to use the compiler from microsoft but to have access to that we will have to close the visual studio code instance we have here and we're going to come back to our project let's see if i can find it here so we're going to go to the location where we have our project and we're going to change to the location of the project here so i can grab the location from my visual studio code project that i just set up i am going to come back to my powershell window that knows about the path to the c plus plus compiler from microsoft and i am going to change it to the location of my project here so i am going to say cd and paste in the path i just copied and if i hit enter this is going to change to my location and i really recommend using powershell if you have access to this because it is a little more convenient to use it supports more commands that you can use in the command prompt but again that's going to be your choice now i am in the location for my project if i do ls or dir you can see that i can see my main cpp file can see the binary we generated earlier but this is not problem so what i can do here is say code and i say a dot and this is going to start visual studio code in the current folder of our project year so if you hit enter we're going to wait for visual studio code to come up it is going to come up with the project we had in that folder and the special thing about starting visual studio code this way is that it's going to know about the compiler from microsoft if we come back to our terminal here and clear and say cl.exe", "2996.0789999999997 - 3295.359": "about the compiler from microsoft and we can use it to do things so let's set this up again if you want you can read up on how to do this on the documentation from visual studio code itself but again i am going to show you how to do this you can see that it is really the same things they are doing here so let's come back to visual studio code and we're going to go to terminal and we want to configure a task now you see that we have the compiler from microsoft available you can see that we can use that right here so what i am going to do is click on cl.exe world active file and this is going to add a new entry in our configuration file and it is going to open up if we go here we are going to find that we have a command to build using the compiler from microsoft so let's change the level here and i say world with msvc i think this is going to be more descriptive and this is really going to build your thing now i am going to change this up so that it works everything in the current folder and again i am going to remove everything here and put in a configuration that i have ready on my system here this is what i use for all my projects again this is just calling the compiler and giving it options to do things we just need to specify that we want to use the lattice standard of the c plus plus standard and it is going to specify the input files we're going to be building everything in the current folder this is what we are saying here and the output file is going to be called rooster.exe if we save this by saying ctrl s or command s and close our tasks dot json file we can bring up our terminal window by going to view and saying the terminal here and we can go down and clear we can say clear and hit enter and if we do rm and say rooster and hit tab this is going to remove the binary we generated with the clang llvm compiler earlier now we want to build with the compiler from microsoft so let's do this we're going to say terminal and we're going to say that we want to run a task but this time we want to build with msvc this is what we want to do here if we click on this little thing we're going to kick off the process to build with the compiler from microsoft and we're going to wait for the compiler to do its thing and if we wait we're going to see that the world finished successfully and if we look in our folder we're going to see that we have our output file and we can come in our terminal and hit to enter and do clear to clear things up and if we say rooster just like this and hit enter you're going to see that it's going to say zero and this is confirmation that we are able to use our visual studio code editor and be able to use it with all kinds of crazy compilers and this is really cool if you are on windows i recommend setting this up because it's it's going to make it easier to run a c plus plus applications from visual studio code using state-of-the-art compilers like msvc clone and gcc here and this is really cool now we have everything we need to start running c plus plus applications but before i let you go let's show you how you can set this up so that you have an easier time with regards to intellisense and whatever so what we're going to do we're going to go to our view menu and we're going to choose command palette and in this we're going to say c or c plus plus we can say something like this and we're going to choose edit configuration ui this is going to give us an option to configure things and i want you to configure things your new system so i am on a windows system let's see the options we have here i am only going to have the option for win32 but if we go down we can specify the things we need visual studio code configured for for example it's going to give us intellisense or autocomplete and all kinds of greater things using the setting we choose here if we want we can choose the gcc compiler or whatever i am just going to leave in the windows msvc compiler because i am on windows here but know that you can configure these things now if we go down we're going to see that we have the option to configure the c plus plus standard and the compiler path that is going to be used to figure things out we're going to be using the compiler from microsoft here but know that you have the option to choose any other compiler for example we can choose the g plus plus compiler we can choose the clank plus class compiler you can configure these things and if you need to change this please come back here and do these configurations here we're going to leave in this whole intellisense and what we will do is configure visual studio code to use the c plus plus 20 standard so we're going to do that right", "3295.359 - 3596.319": "to see that visual studio code is going to generate a cpp properties file which is going to store all these configurations here so it is really going to be a configuration for what we choose in our configuration here so make sure you choose what makes sense again i would recommend using c plus plus 20 but if you go on top you can really use any compiler you want i am going to use the compiler from microsoft this is okay i am going to use windows msvc configuration for intellisense here and i am going to close this and we are really ready to start using visual studio code to ride c plus plus application so let's clean this up a little bit we're going to view our terminal and we're going to remove the junk that was generated by the compiler from microsoft i am going to say rm and say rooster and i can remove the binary i can say rm and say rooster and say tab this is going to autocomplete and really remove things i don't need i am going to remove the pdb file i am going to remove rooster you know i am going to remove the main object file so let's say main dot obj and i am going to remove main dot or vc we don't want to remove our cpd file so now we have a project we can use as a starting point to write c and c plus plus applications here so what we will be doing in the next few lectures or the next few chapters is reusing this thing here as a template project so what i can do is uh call this c plus plus 20 template project and let's do this here i think i need to close video studio code otherwise it's going to complain so i am going to call this little guy c plus plus 20 template project and later when we start learning about c plus plus proper we're going to be using this as a starting point and we want to have to reconfigure the compilers our project will be ready to use the compilers that we set up here namely the compiler from microsoft the g plus plus compiler and the clang plus plus compiler and that's going to be really cool this is really all i have to share in this lecture i hope you have visual studio code set up to use all these compilers we are going to stop here in this lecture the next one we're going to start and see how to set up your development environment on linux and we're going to start by installing compilers on ubuntu 2004 go ahead and finish up here and meet me there in this lecture we're going to see how to install c plus plus compilers on linux we are going to be working on an ubuntu 2004 system and we will install a new version of gcc and the latest version i can get my hands on for clang llvm so let's do this okay so here i am on my linux box this is ubuntu 2004 if i do you name and say a we're going to see the information on this and you will have to adapt this for whatever linux distribution you are on and to install gcc it's really simple but the problem is the latest version of gcc at the time of recording this video is gcc 11 and it's not available in the ubuntu packages now for example if you do see do apt get install gcc 11 this is how you get it if you do this you're going to put in your password you're going to see that this is really not available yet right we cannot find this so the best version we can install is gcc 10 which i happen to have installed already on this system so we're going to do gcc 10 that's what we're going to install here and if we do this we're going to see that this is already available you can also install g plus plus done i think you can do that okay so we're going to run the command here and we're also going to see that it's already available here but if you don't have these they are going to be installed and you can use them on your linux system another tool that is necessary on linux is the gdb debugger so we're going to do sudo apt get install gtb right if you install it it's going to be installed but i already have it installed already so now if i do gcc 10 on my system here and say version we're going to see the version printed out we can do g plus plus stand we can see the version here let's do that for c plus plus so we're going to see the version here we can even do gdb version and it is going to show up let's wait for this we're going to see my gdp version here and now i can use these compilers to compile c plus plus code on", "3596.319 - 3896.0789999999997": "steps to install a gcc compiler on linux we're going to look at how we can get a hold of the clang compiler on our linux box here and it is really simple all you have to do is to do apt get install and we're going to install clang 12 because that's the latest version at the time of recording this video if we do this we're going to see that it's going to install i already have it installed here but if you don't have it installed it's going to install on your system and this is going to give you all the tools you need to compile with the clan compiler on this particular ubuntu system these installs are going to be installed in my user bin directory so if i see the there and do analysis to show everything in here and scroll up we're going to find all the versions for clan you see i have multiple versions clang 10 11 12 and we have clan plus plus variance of this i think we do okay we have clank plus plus and clan here and this is going to do what we want we have the clan combiner and the gcc compiler installed on our system here now if you want to get the latest version of gcc installed on your system one easy way i found is to go through a package manager called homebrew let's search for this right if you search for this you're going to find it and if you want you can install it on your linux system and when you install it it's going to to be basically there ready to use and to install it i think there's a command there install home brew let's do this install here and if we do install we should find a link to install this let's find a link i think they have a link you can copy aha it is this little thing here you can copy it paste it in your terminal and it is going to install home brew on your system and when you have home brew installed you can go through it to install the latest version of gcc for example if we search for homo blue gcc in our search engine here we're going to find all the information to install this through home brew and you just have to do bro install gcc and this is going to install this on your system and you're going to see that it is going to install the latest version at the time of recording this video so this is what you should do for example if we go back to our linux box we can do let's cd into our home directory and we're going to say brew install gcc and it's going to tell me that it is already installed because i installed this but if you don't have it installed it's going to install it and you do this after you have gone through the steps to install the home brew package manager on your system and you do that by just copying this link and pasting that in your terminal and hitting enter and it's going to give you directions on what you can do to get this properly installed on your system here so this is really cool so if you want the absolute latest version in gcc this is one way you have to get a hold of it without really going through the complex steps to build the compiler yourself on linux okay it is taking some more time here i am just going to kill this because i already have the latest version of gcc here if i do jcc 11 on linux and the do version i am going to see that i have 11 2 and it was installed through homebrew and if you let this run to completion it's going to install this on your computer we don't have to wait for this so now we have the latest version of gcc on an ubuntu system we also have the latest version of clan this completes our tutorial on how to set up compilers on linux we are going to stop here in this lecture this one we're going to install visual studio code on the linux system and then in the next one we're going to link visual studio code to these compilers and be able to use visual studio code type code and compile our programs using these two compilers here so go ahead and finish up here and meet me in the next lecture in this lecture we're going to see how to install the visual studio code editor on a linux system and again we will be working on our ubuntu 2004 system here so let's head over to the website for visual studio code and download our binary and install it on our linux system here okay so here we are at the website for visual studio code you can get there by searching for visual studio code in your search engine and you're going to land here and all we really have to do is go down to find our download links we're going to see that for debian and ubuntu we can download here but you can also find something specific to other distribution okay so we are going to grab the 64-bit version of debian ubuntu here because that's my system and you're", "3896.0789999999997 - 4195.4400000000005": "your distribution so let's grab this here we're going to grab the link so if you click on this this is going to kick off the download process and you will see this downloaded on your system and once you have this downloaded you're going to install it and in ubuntu you can just double click on this to install it or you can install it like you install any debian package on a linux system for example if you are unsure on how to install debian packages all you have to do is do a simple search so let's do google.com and go there and we're going to see how to install to install debian packages on ubuntu 2004 so this is our version here and you're going to find a lot of instructions on how to do this it's going to be really simple so we can go down and find a way to install so all you have to do is says you do dpkga say i and you pass the name of the package and this is going to install visual studio code on your system once you do this you will have visual studio code installed and you will be ready to start it and use it on your system here once it is installed you will have the ability to come in your system here for example and say code dot and this is going to open a visual studio code instance on your system let's wait for this to come up so that you really see this okay so this is going to open visual studio coordinate system and you can start using it like we will do in the next lecture okay once you have a visual studio code installed and started up on your linux system the very first thing you need to do is to install the extension that is going to allow you to do some c and c plus plus and to do that you will come to this tab here that says extension and in our search box you can start typing c and c plus plus and you are going to have an entry that says microsoft here so please select this and this is going to be the extension you need to install you're going to click on install and it is going to install and this is what enables a visual studio code to do some c plus plus programming and this is really cool if you want you can check out how to use it on linux and you're going to have instructions on how to do this but we will do this in the next lecture and show you how to configure visual studio code to use the compilers that we have installed in a previous lecture so we're going to tell visual studio code to use our client compiler we're going to tell it to use our gcc compiler and we will have the flexibility to come to terminal and choose which compiler we want to use and we're going to do all this in the next lecture so go ahead and finish up here and meet me there in this lecture we're going to configure our visual studio code editor to use the compilers that we just installed in a few previous lectures so we will be able to type our code in our visual studio code editor just like we do here and we will pass the code through the compiler to generate a binary that can in turn run on our linux system here this is what we want to do so we want visual studio code to use the compilers that we installed so let's head over to our linux box and do this okay here i am on my linux box this is the current directory where i am at this is where i am going to do my things here so i am going to create a folder and call it a template project let's do this we're going to say mkdir and we're going to say c plus plus 20 template project i think this is going to do or we can even say cpp because i'm not sure the plus signs here are not going to give us a problem let's play it on the safe side and we are going to create this folder and we're going to cd into this folder okay once we are in this folder we're going to open this folder in visual studio code and the easiest way to do that once you have visual studio code installed is just to type code and type dot and you will basically be telling the operating system to open visual studio code in the current folder here so i am going to hit enter and this is going to kick it open and i trust this folder because i just created it and we are in our project here the very first thing we're going to do is to create a main cpp file so let's do that and i did that by clicking on the plus icon here and i typed in the name of the file and i am going to put in some dummy code here that we want to use our starter code we're going to say iostream and we're going to put in our code here we're going to say main and again you don't have to type all this if you want you can get the code from the resource section on the lecture so you can copy the code paste that in here and be on your merry way because we haven't", "4195.4400000000005 - 4495.36": "plus we are setting up the environment so don't stress yourself here this is just some simple code to test our compilers to see if they support c plus plus 20 because we want to use the letter standard we can get our hands on here so let's do equals type exactly what i typed here so we're going to say 10 and we're going to put this weird operator and say 20 and we want to see if this madness here is greater than zero this is what we want to do and we're going to say stdc out and the same result okay so type exactly what i type here and as we progress in the course we're going to make sense of all these madness we see here so now that we have a cpp file containing the code for our c plus plus program we want to compile this and we need to tell visual studio code which compiler it's going to use to compile this program here to give us a binary that we can run so what we're going to do is come to terminal here and we're going to say that we want to configure tasks and the task is really a set of instructions you give to visual studio code on how to take your c plus plus project and turn that into a binary that can run on that system here so that's what we want to do we want to tell visual studio code which compiler it's going to use we're going to configure task here and you're going to see that it's going to discover many compilers on my system here you see we have clan 10 clang 11 clan 12 and we should also have gcc 11 if we keep scrolling down we're going to find these little guys here i have many compilers on this system so i am going to choose the gcc compiler which is installed through home brew this is what i'm going to choose here you say it's saying g plus plus 11 but if you have access to g plus plus 10 you can also use that it's going to work with what we want to do in this course here mostly so i am going to choose the best i have in terms of gcc and this is going to set up an entry in our tasks dot json file to build and run this program here and that's what we're going to do okay you see it is using this particular compiler and one thing we can do before we try and build this we can change the level here to make it a little bit more descriptive so we're going to save world with gcc 11.2.0 if i am correct and this is all we can save this and we can close this json file and if we bring up a terminal window we can do that by hitting terminal here and choosing a new terminal this is going to open up the current location for example if we do pwd in this terminal here let's use lowercase i think that's what it wants we're going to see the location here this is my project so to build i can come to terminal and i choose run task and i am going to choose the task to compile with my gcc installation here if i choose this it is going to kick off the weld process and you're going to see that the gibberish i have here is not supported because the compiler is not configured to use the c plus plus 20. so all we really need to do is go back to our command and tell it to use c plus plus 20. and we can do that by passing a specific instruction to the compiler to use c plus plus 20 like we do on line 10 here so we're going to say std equals c plus plus 20. we are going to save this a little bit and i really wanted you to see this problem here because many people are going to forget this and we're going to try and build again making sure we are selecting the main cpp file here so let's go to terminal run task and use our compiler and wait for it to do its thing you're going to see that the world now finished successfully and if we come back to our terminal here and do ls we're going to see that we have a file called main and if we run it we should see a zero so let's say main here and if we run it we're going to see a zero meaning that our program is running and working correctly we are able to compile a c plus plus project on a linux system here now if you want to see how i came up with the information to use the tax json file please come back to the extensions tab here and choose the c and c plus plus extension we're going to click on this and we're going to see all the instructions on how to use this guy on the linux system here so gcc on linux we can choose this and we're going to see all the information here now you can read up on all this if you want but what i am going to do is go to visual studio code and", "4495.36 - 4796.5599999999995": "get this to work what i want to do in there is set this up to compile everything in my what i want to do is to set what i really want to do is to what i really wanted to do is to set this up so that it compiles every single cpp file in my directory here and i can do that by putting in a set of instructions i had prepared beforehand so we're going to tell it to compile in c plus plus 20 mode we're going to tell it to compile every single cpp file in this directory and then we're going to specify the output file name for our binary now this is code i used on windows i need to adapt it to be specific to linux so let's see what they say in the documentation there and we can we can scroll down a little bit and we're going to see that they use backslashes here so that's what we're going to use in visual video code to play it safe so we can say this a backslash and this is a backslash and we will try and build this and we're going to see what happens here this is going to build our project in c plus plus 20 mode we're going to be building every single cpp file in the project and the output will be called rooster this is what we want to do here let's save this up and i am going to close this json file and i will bring up my terminal by coming to view and save a terminal here and i can remove the main.exe file or the main executable i had in there if i do lsuc it's gone but now if we try and compile with the gcc compiler we're going to see what happens you see the world is good and we have a binary called rooster and we can run it here if we do rooster we're going to see it run and give us a zero and this is really all we need to do now we have this working for our gcc compiler but we wanted the same for a clanger compiler and we want the flexibility to be able to switch compilers by coming here and just selecting the right task so let's do this we're going to configure clan we're going to come to terminal we want to configure a task and we're going to choose the best we have in terms of clang that happens to be clang plus plus 12 here so we're going to choose this and this is going to add an entry in our tasks.json file we're going to change this to say that we want to build with clan let's do that we're going to say world with clang i think we have 12.0.1 if i remember correctly but we can ask our terminal here let's go to terminal and we're going to say clang plus plus and 12 that's the version and we're going to ask it what's your version it's going to tell us in detail and if we wait we're going to see this speed out on the terminal here and this happens to be clank version 1200 so that's what we're going to say in our file here weld with clan 12 0 0 to be super clear on this and uh this is really all all we need to do is put in the instructions to build in c plus plus 20 mod exactly what we did for gcc here so i am going to copy this and put that in my arguments here i'm i am going to take out whatever i had in there i am going to put in my new things and let's see if this compiler works now we're going to save our tasks.json file and come back to the cpp file we're going to bring up our terminal window and we're going to clear and remove rooster because we wanted to build a new one with our clank compiler and we will come to terminal run task now we're going to choose to build with clang 12.0 we're going to fix this in a minute but if we do this we're going to see that our weld process is going to start it's going to be building with our clan compiler it's going to be using c plus plus 20. it's going to be building every single cpp file in this location here and the output of the world will be a binary called rooster that we have right here so the build is good if we do ls we're going to find rooster and if we run it it's going to say zero exactly as we expect here and we have visual studio code properly configured to use our two compilers the client compiler and the gcc compiler let's come back to our configuration and change this to say 12.0.0 to be super clear on the version we have we can close our json file here and come and try to build again if we do terminal and run task we will have our compiler here ignore all these things i think visual video code is going to give you duplicates but you can choose the version that says what you want and it is going to work so we're going to choose gcc oh we are saying gcc but we", "4796.5599999999995 - 5096.56": "want to build with clan we're going to go to terminal and run task and we want clang 12.0.0 this is right here so we're going to select it and it's going to build successfully and we will have our binary here if we run it it is going to say zero and this is really what we need to do here so this is really all i had to share in this lecture showing you how you can configure visual studio code to compile using the compilers that we have installed another thing you can do to make your experience better is come back to view and select command palette here and you can do c and the c plus and edit the configurations through a user interface and if we do this you're going to see that this is going to create a cpp properties json file so this is where we can configure what kind of intelligence what kind of what kind of compiler is going to be used we can do all these things here so we're going to leave it to the default it's on our linux system it's going to be using gcc 11 which is the best we have in terms of gcc but uh one thing you should note in this course here is the c plus plus standard we wanted to use so we wanted to use z plus plus 20 and we want visual studio code to give us intellisense or format our main cpp file based on the c plus plus 20 standard year that's what we can achieve with this so once you have this and you can come and close this and if we go back to the main cpp file you see now that this is no longer flagged as a problem with squiggly lines visual studio code is properly understanding what is happening here and this is something you can do to make your experience a little bit better okay now that we have this project set up and ready on linux we're going to be reusing this as a template project every time we start something new on linux so every time we want to create a new project we will grab this entire folder so for example we will come to our terminal here and go up a little bit so cd and go up one level and if we do ls we're going to have our c plus plus 20 template project we will copy it and rename it to start a new project and that's going to give us all the configuration that we did we don't need to reconfigure the compilers or whatever it is going to work right out of the box and that's really what we did here we set up a template project that we will be reusing all over again in the course as we progress learning about c plus plus 20. i am going to stop here in this lecture the next one i am going to show you how you can set up a development environment on the mac os system go ahead and finish up here and meet me there in this video i am going to show you how to install c plus plus compiler on your mac os system and we have a bunch of options on the mac we can install the gcc compiler we can install the clang version of the apple company or we can install the clangle vm version all these are options and i will show you how to install these i don't have access to a mac device so i won't really be able to install xcode and show you but i think you can manage if you are using a mac system it is nothing complicated you just have to go to the apple store and click on xcode and it is going to install for a gcc and clang llvm i will show you how to do this using the homebrew package manager which is also going to make this super easy okay so let's head over to our browser and we have a good link here from digitalocean on how to install and use homobrew on a mac os system this is a really validated link you can see that right here and you can read up on this if you are using a mac system i am going to share the link here in the resources section of the course and to use this we will go through the mac os terminal and it is nothing complicated you can search for it and open it up and after you do this you will have to install the tools needed to build things on the mac os system and that's going to install xcode here so grab the command here and run it in your terminal and this is going to install everything you need and after you have this installed you're going to install home brew i do recommend coming up to the website here for homebrew and clicking on this copy icon here this is going to copy the entire thing and you can copy this and once you copy it it is going to give us a green tick here and you can go in the terminal on your mac os system i am using a linux terminal here and then you're going to paste this command in here and hit enter once you do that you will be prompted to put in the password it's going to tell", "5096.56 - 5396.639": "and you are basically going to wait for this to finish i have to warn you this is going to take some time even if you have a good internet connection this is going to take some time so be patient here when it's done it's going to tell you that it is finished and you will be ready to install the gcc compiler and the client llvm compiler through your homebrew installation here i am not going to click on this because i already have this installed on my linux system here let's go back to the link and see what they say next so after you paste that in it's going to install and after that you will see that homebrew is going to be installed on your system and uh you can use home brew to start installing and upgrading packages you can really read up on this but what i want you to see is that you can use home brew to install the gcc compiler and the clang ll vm compiler so if we come to the search here and say gcc homo broom we're going to find instructions on how to install this so all you need to do really is to say brew install gcc this is going to install the latest version of gcc on your mac if we come here and say llvm or clank let's say clan and we can find that right here llvm and it is going to give us instructions on how to install this and all you have to do is brew install llvm and this is going to install these two compilers on your mac system so once you do that you will have them stored somewhere let's go to the install link and we're going to see that homebrew is basically going to be installed into things in your user local directory on a mac device please tell me if this is true for your case and if you have a problem we'll try and go through that and fix that up so if you are on a mac i would really recommend going through this to install homebrew once you have that installed you will go through that to install both of the llvm compiler and the gcc compiler and that's going to give you the latest versions for these compilers to find out if they will installed you can go in your user local directory and you can hunt through these compilers and you're going to find binaries for them and start using them to build your c plus plus applications you okay so by now i am going to consider that you have both gcc and a clang installed on your mac system the next logical thing to do is to want the apple version of clang and i think that's going to come as part of xcode here and it is going to come as a result of running the command that we did before i think it was this little command here which is going to install everything you need from the xcode ide so this is all i have to share in this lecture again i apologize i don't have access to a mac device but if you have a problem you can tell me and i will try to help you out and get this sorted out we are going to stop here in this lecture the next one we're going to see how we can install xcode on your mac device go ahead and finish up here and meet me there in this video i am going to show you how to install the visual studio code editor on your mac os system please know that you can also use other ides like x code or code lite do c plus plus development but visual studio code is going to be our main editor in this course here and i would recommend to install it so that we are doing consistent things that's going to reduce chances for you to get confused so we are going to head over to the website for visual studio code and to get there we can just type visual studio code in here on in our search engine and we will have a link here that we can use to download our fans so we are going to go down and find download links for windows linux and mac please use the mac download button here and you're going to download the binary and install it i think it is going to be in the download folder by default so all you have to do is drag that up in your installation directory so that it becomes a runnable application after you do that you're going to run it and it is going to run and you will have a user interface like this with visual studio code opened up once you have that up you will need to install the c plus plus extension and what you need to do is come to the extensions tab here and type c and c plus plus in here and you're going to have an entry for microsoft click on that and install this extension on your system and your visual studio code instance is going to be ready to handle some c plus plus development and this is really all i had to share in this lecture showing you how you can get this installed again i apologize i don't have access to a mac device so i used my", "5396.639 - 5695.52": "subsystem for linux to show you this but this is good enough i think if you have a problem you can tell me and i will do the best i can to help you out for now we're going to stop here in this lecture in the next one i will try and show you how to set up a visual studio code to use the compilers that we installed in the last lecture go ahead and finish up here and meet me there in this lecture i am going to try and show you how to configure visual studio code to use the compilers that we installed on our mac system in a previous lecture so we want visual studio code to be able to pick up our gcc compiler and use it we want it to pick up our client compiler and use it we also wanted to pick up our clanger compiler from apple and use it to build binaries that we can then run on our system here so let's see how to do this i have to say i don't own a mac device so the best i can do here is describe the process to you and if you have a problem you can tell me i will do the best i can to help you out okay so once you have visual studio code installed you're going to create a folder somewhere and open visual studio code from that folder and what you will basically do is use the terminal to navigate to a location you're going to create a folder you can even call it cpp template project you're going to hop over into that folder and then open visual studio code from that folder here so for example we can hop over into cpp and run code and say dot that's going to open visual studio code in that folder and from that folder you will create a main cpp file by clicking on the plus button here and you will create the cpp file call it main cpp and you can put in the content here and once you have this the next task is going to be to set up a compiler to build this little thing so once you have this project you will come to terminal i think there's going to be a terminal menu somewhere and you will choose configure tasks once you do that visual studio code is smart enough to scan your system and find any compiler you have installed the first thing that is likely to be found is the apple client compiler so you're going to find a clone plus plus compiler so you can choose that and you can use that for the apple client compiler we are lucky we even have a tutorial on how to do that so if we click on our extensions tab here and choose our c and c plus plus extension if we scroll down we're going to see a link on using the client on mac os here this is going to give us all the instructions we need to use visual studio code with the client compiler from the apple company so if you scroll down you're going to be able to read up on all this but what i really want you to see is the configuration file you're going to see that it's going to be using the clang compiler from the user bin directory and this is mostly going to be the clang version from the apple company and sometimes you don't want this so if you want to use the clang version that we installed through home brew i think you will need to go through the user local directory because that's where homebrew is going to put it you're going to see that that's going to be the location here from our tutorial and you're going to hunt down for the clan compiler and find your binary and that's what we're going to be using next but for the first time if you want to use the clan compiler from apple this is the configuration you need and all you need to do in this case is change this to c plus plus 20. now once you have this configured you will have the ability to come to terminal let's show our files here you will have the ability to come to terminal and run task and choose the compiler that's going to be the clang compiler from apple but you can also configure other compilers and all you really have to do is choose them in the list here and you're going to have a configuration file it tasks json file to be exact let's show that up here and that's going to give you the instructions you need to build this and in most cases you will just need to be careful about the path to the compiler so for example if you are using the gcc version you installed through homo brew you're going to find that in your location you're going to make sure that's the correct one and you will put in these instructions here to tell your compiler to build every single cpp file in the directory here this is what we do if you use clan you're going to have something like this and again i am describing this to you because i don't have a mac available to me right now and if you have a problem you can tell me we can try and sort this out okay and by this time you will have the ability to use your visual studio code instance and compile c plus plus programs using either the", "5695.52 - 5996.638999999999": "compiler or the gcc compiler and all these are going to be compiling in c plus plus 20 mode again to both you need to make sure you have the file selected and choose whatever compiler you want to use for example if you want to use clone 12 from homebrew you're going to you're going to select that and it is going to be used to build your project and you will have the ability to run your projects just like we do here and it is going to work let's make sure we are running rooster here our binary and it is going to run and printer 0 and this is going to work again i am really sorry i don't have a mac device available to me but this is what i have to work with now if you have a problem on a mac device please tell me i will do the best i can to help you out in this lecture we're going to explore the option to use online compilers if for whatever reason we can't install a radio compiler on our system and again the goal is to be able to turn the code we type into what looks like an ide into a compiler and get a binary that we can run and see the output of there are a few online compilers that are very popular within the c plus plus community one box is one of them there is also compiler explorer and kodiro but there may be other ones out there if you do research on your own we're going to go to the browser and actually check each of these out okay here we are in our browser here i am on onebox.org and you see that it really looks like an ide inside we have the code we've been running all along to make sure that it compiles with c plus plus 20. on the left here we have a few options we can select which compiler we want to use you see that there is a couple of gcc versions you can see that this is a really nice way to test things across gcc versions you see we have clan 12 so if you want to test clang out you can select it let's actually try this so we're going to use clang head and try to compile this so let's hit enter and see if clank 12 supports c plus plus 20 and you see that it really works clan version 12 should support c plus plus 20 like this let's go back to gcc because that's what i like and you can try putting different things in your c plus plus code to see if the compiler actually responds for example we can say stdcl hello there stdendl and if we run we're going to see the message output here another good thing with these online compilers is that you can share this code and anybody will be able to look at the code here and run it so this is a really good way to get help from your instructor so i do encourage you if you run into a problem come and use one of these compilers and send me the link the way you can send the link you can hit on share here this button here you're going to get the url that you can copy and send to anybody and they will be able to see your code just like we're going to see here in a minute okay you see that it isn't the exact same thing and anybody on the internet will be able to see your code and try to find whatever the problem is and help you out very fast one box is one compiler you can play with the options that we have here you can load different libraries you see they have a lot of boost libraries but this is of no interest to us right now you can play with it and see what you like about it another one is kaliru which is another online compiler you see it doesn't have a lot of options like we had in one box for example you cannot change the compiler it's going to be using g plus plus but if we hit compile link and run it's going to run our code and we're going to get the output here again we can try and change this so that you know i'm not lying to you so we can say stdcl and say the sky is blue std endl if you want you can hit control plus on your browser and it's going to make this a little bigger and if we compile link and run we should see the sky is blue in the output window here this is really all you can do with kolero and if you like it you can donate to the developers i think we have the same thing on one box but it is in japanese so i can't really read this okay another one is compiler explorer which is a really good one the main purpose of this is really not giving you the output it is actually seeing assembly code that is generated for your", "5996.638999999999 - 6297.679": "little bit advanced for our purposes here so we're going to ignore this we're just going to be using it to test our code with some of the popular compilers if you look here on this drop box you see that they also have a lot of compilers you can use different gcc compilers i think they have clan they even have msvc how cool is this so you can use a lot of compilers gcc clang you see we have a lot of clan compilers we have clang 11 here so this is a really good way to try things out we're going to come back to gcc 10 2 and i noticed that i passed the flag of c plus 20 to be able to support c plus plus 20. again if i come here in my code and say stdc out the sky is white don't worry about these errors they're going to go away in a minute let's wait for the program to compile you see that it is compiling let's wait a minute the sky is white and everything is fine if you don't see this output here it is possible that you didn't check this checkbox run the compiled output so come to this dropbox and make sure this is checked and you should have a window like i have here compiler explorer also allows you to share your code with people on the internet let me see if i can find the option to share you come to this drop box and you get a link here that you can copy i'm going to copy this and open a private window in my browser here so that we know that it is some other browser that is going to be opening this link and getting access to the same code we have in compiler explorer and this is going to be pretty cool and you see that we get compiler explorer privacy we're going to close this and you see that we have the same code we can try modifying this code for example we can take out this third line here it's going to start compiling you see that it is compiling and it is going to give us the output that we expect from this so this is a really good tool to try out if you want to share your code with some people that are not close to you this is a really good way to do this it is also good to try out different compilers for example if you don't have a gcc compiler you can try it out here and see if it does things for example we didn't install clang on our system but we can try it out and see if it runs or could but make sure you pass the correct flats here because you are responsible for this if you pass the flats that don't work you're going to get arrows for example if we say hello here we're going to get weird arrows and oh and recognize command line option std hello but if we say c plus plus 20 it is going to work so make sure you pass the correct options in this lecture you're going to write your first c plus 20 program and we're going to start and attempt to understand our program let's hop over to visual studio code and actually do that the first thing we want to do is to set up our code so that we can open that in visual studio code we're going to start from our c plus 20 template project that we set up in the last lecture and i'm going to be doing the projects for this chapter in this folder here so we're going to do our very first c plus plus program so what we're going to do is go inside our c plus plus 20 template project and i noticed that we actually left in the boiled files we don't want so what we're going to do is remove this main file and that this vc 140 fan we don't want these here and we're going to copy the main cpp file and the dot vs code folder we're going to copy these things and we're going to put them in our first c plus plus program folder and we're going to open this folder in visual studio code visual studio code is not opened up you see that i have my developer powershell opened if you want you can open visual studio code directly without going through this if you're not going to be using the visual studio compiler but i want to have the option to use that compiler so this is how i am going to open my visual studio code instance i am going to type code.exe to open this up i'm going to hit enter and visual studio code is going to open and it is going to open whatever we did in the last lecture we don't want this project because this is a template project from the last chapter we're going to close this folder go to file and hit", "6297.679 - 6595.28": "new folder we want to work on we're going to go to file and hit open folder we're going to go to the location where our project is so you're going to go where yours is i'm going to browse to mine and i'm going to go in the current chapter and choose 3 2 first c plus plus program i'm going to select the folder it's going to open up and you're going to see that our settings from the last template project are still valid here they were copied over if we open the main cpp file it's going to be the main thing we had in the last lecture so we have the option to run task you're going to see that we have two compilers available and this is really good we are ready to start using this let's try and build this with gcc and we're going to have our binary created we can click in the terminal here and if we want to open the terminal again we have the option to come in terminal and new terminal this is going to open this up if we do dir in the terminal we're going to see our program generated we can remove this thing here and say rm rooster dot exe and remove this we can clear and we have a clean project we can start learning from okay now we have the project and it is building successfully let's try to understand the code we have in here the first statement we have it this include io stream thung this is a feature c plus plus offers to load the pro built libraries that we can use iostream is specifically going to help us print thanks to the console we've seen that we can for example print hello world if we want let's take out all these things in here and say std column column c out this is coming from i iostream and we're going to put two less than symbols we're going to open two quotes and inside we're going to type hello world and we're going to go outside the quotes and do two less than signs and say std colon colon endl and put a semicolon this is going to print things on the console if we run this program so if we run this program the first thing we need to do is to build this program so we can come to terminal task and we're going to build it with gcc and after we've built it we can hit enter to close the terminal and we can do dirt to see the content of the folder you see that a program has been generated we can run it and if we run it it's going to say hello world this message is coming from this statement here and we have this statement because we have included io stream to really make this super clear we can try to remove this line that says include io stream and the moment we do that you're going to see that this tab says we have problems and if you open this tab you're going to see the message namespace sdd has no member c out name space std has no member a and dl this is because the z plus plus program doesn't know what sddc out means because we don't have the library included and you also see that we have these squiggly lines to make it really clear that we have a problem so to really be able to use this we have to include a third party library that brings these features into our program and that's what the include statement here is really doing so let's bring this in and we're going to say i o stream again and let's wait and see that the problem goes away and the one thing you should really know is that we don't have a semicolon at the end of the io stream statement we don't need to put it there but many c plus plus statements need a semicolon at the end okay i think this really makes it clear what the include statement here is doing the other thing we have in our program is this ant main parenthesis curly braces thing this thing here is called the main function a function in c plus plus is a block of code that does a lot of things but the main function here is special because it is the starting point of your c plus plus program we also call the main function the entry point of the c plus plus program and what that means is that if you open the program the main function is going to be the very first thing that is going to run and the things are going to be executed in the main function in order", "6595.28 - 6896.159": "run first and the statement after that until we hit the end of the function so this is what we mean here to really drive this home we can come here in our main function and say sdd number one and say sdd engl and by the way this e n d l statement is going to print a new line we're going to see it in effect in a moment let's actually take it out so that we can see its effect we're going to also do sddc out number two and what this is going to do is to print number one and number two on the terminal let's build this program and if you want to build the default task you can hit ctrl shift b for it to happen very fast but i am always going to come here so that it is really clear what i am doing a program should be generated now if we try to run it by typing rooster.exe and again we can hit the app arrow button on our keyboard so that's the last command that we run from this terminal runs and this is going to speed things up a little bit so if we run this program it should say number one and number two as you see here but these two things are cramped on one line and the reason is we are not printing new line characters after we print number one and number two and we can solve this problem by putting in two less than symbols and saying std column column e n d l this is going to put a new line character after number one we can build again for our new changes to tech effect after we do that we click on the terminal hit enter we hit the app arrow button if we run it's going to say number one and number two on two separate lines because we are printing a new line character after number one i really hope this makes sense please do take some time to play with us because if this is the first time you're doing this some things might not be clear and the best way to really make sense of this is to type code run it and see the effect of what you type by running your program so let's do this a couple of times we're going to do sdd endl after the statement for number two we're going to do stdc out number three and we're going to do stdeandl to really show the problem again we're going to take out stdendl on the number two line we are going to weld the build is going to be successful we're going to click in the terminal hit enter hit the app arrow button run the program again and you're going to see it's saying number one it's going on the new line printing number two but we not to jump into the new line from number two so number two and number three are going to be cramped on one line that's what we see here we can solve this again by putting in a new line after number two let's do std e and d l here and uh this should solve the problem again let's build we're going to run our build task the build is going to be successful we're going to hit the app arrow to run the program if we run it it's going to say number one number two and number three and this is really good now it should be clear that statements in the main function are run in order from top to bottom and that the program is going to end when it hits the end of this curly brace that includes our function we're going to have a chance to learn more about functions in detail later in the course but we are just getting started and we need to start somewhere so that's why we're doing this main function thing here another thing you can do is return from the main function and in many examples you will see people do return 0 something like this and this is a way for the main function to send the message to the operating system if it's finished successfully or if there was some kind of problem we're not going to go into any more details about the main function because that's really too much for now we are just getting started we are trying to get a feel of how c plus works the main message here is really that you should be able to print things to the console using sddc out you should be able to print a new line after your message using sdd ndl this stdc out and stdendl thank come from the iostream library that we are including here", "6896.159 - 7195.36": "going to have problems because our surplus plus program is not going to know where they are coming from so we should really put this in if we want to use these features and we can return from a function to let the system know the operating system if the program finished up successfully or if there was some kind of problem and again this project is using the templates we've done before and this is really all we set out to do in this lecture trying to make sense of the main function in c plus plus to really practice these things i would challenge you to write a c plus plus program just like this that is going to print your name 10 times try to do that and if you have a problem please do ask me and i will do the best i can to help you out this is really all we set out to do in this lecture i hope you found it interesting we're going to stop here in this lecture in the next one we're going to start and learn about comments in c plus plus go ahead and finish up here and meet me there in this lecture we're going to learn about comments and c plus plus comments are the way to put some messages in your c plus plus chord that are really meant to be read by humans and one way we have to do comments in c plus plus is through this backslash backslash thing we have here this is going to comment out the line so the compiler is really not going to care about it it's going to think that it is something that is meant for the developer to see so this is a one line comment and this is how you do it in c plus plus you can also comment out a block of code in your c plus bus code and this is something that comes in quite handy many times you put your comment in a backslash star and a star backslash like this this is going to comment things out in your code and the compiler is really not going to care about this let's hop over to visual studio code and actually play with us so here we are in the folder that is going to contain our code the first thing i'm going to do is go through the template project i'm going to copy my files and i'm going to go up again and we're going to be learning about comments so i'm going to put this in the folder on comments i am going to close whatever folder we have opened in visual studio code and i'm going to browse to the location where my project on comment says my project is in this folder that is named three three comments i'm going to open the folder and if i open the main cpp file i'm going to find the starter project we're going to remove this const eval thank because we're really not ready to understand this yet it was in here to help us test that our compilers support c plus plus 20. so we're going to remove this and we're going to put in a message that says hello world you already know how to do that from the last lecture so we're going to say sddc out hello world and we're going to say stdendl and don't forget this semicolon at the end if you do you're going to have problems so make sure your code looks like this try to build it to make sure it's working fine this is going to run the gcc tasked world we can click on the terminal here and it's going to close the terminal and we can open a new terminal here if we want if we do dir we're going to find our rooster program inside we can run it and it's going to say hello world we already know to do this from the last lecture and in this one we are going to be learning about comments the first thing you can do is use slash slash so let's do that and uh let's put some message here this branch and the iostream library this is a nice message that is going to give some more information about this statement to whoever might be reading this program and this is called a one line comment you can really put this wherever you want in your c plus plus file we can go in the main function for example and say this is going to print hello world to the console or the terminal we can really put this anywhere we can even put it after the return statement here and really put in whatever piece of information we think is going to make sense to wherever it's going to be reading our program okay this is how you do a line comment you can also do comments across different lines and the way you do that you put that in the slash star and go down and say star slash like this and whatever is going to be in the middle here is going to be a comment this is usually called a block comment you can put in whatever you want so if you have a piece of text that you would like to use as a comment in your program this is one way you can do this one thing you should know though is that you cannot nest these things but before we do that let's try to build our", "7195.36 - 7495.84": "problem if we have these comments in the world is successful and if we click on this terminal and hit enter and hit clear to clear things out in the terminal we can try to run our rooster program and it's going to say hello world you see that all these green lines which are comments are really not affecting the program all the compiler is going to care about is this include thing it's going to care about the main function here it's going to ignore these green things it's going to be like these green lines that are our comments are not in there this is the effect comments have in your program and we're going to be using this a lot in this course one thing you should know though is that you cannot nest these block comments so if you try to do something like this and uh say this is one comment and uh come again and say this is another comment you see that we have problems already nesting is not allowed you're going to get a compiler error and we're going to learn more about these errors in the next lecture but don't do this don't nest these block comments if you do that you're going to get some confusing errors and this is going to be the cause for them so don't nest your blog comments it's going to give you headaches okay this is really all we set out to do in this lecture learning about comments in c plus plus you can do one line comments on a single line like this you can do block comments to comment out a block of text you can't nest your blog comments because that's going to give you a lot of problems you don't want that and really use comments wisely and don't overdo it because it's going to turn your program into a novel and i don't think people want that so use this feature when you need it to give some more information about your code and don't overdo this we are going to stop here in this lecture the next one we're going to learn about different kinds of errors and warnings you can see in your c plus plus program go ahead and finish up here and meet me there in this lecture we're going to learn about errors and warnings in your c plus plus programs there are three kinds of errors or warnings you can get you can get compile time errors you can get runtime errors and you can get warnings but what is really meant by these things remember the ultimate goal of every developer or every c plus plus developer in our case here is to be able to generate a binary executable file from the c plus plus code and we have to run the code through the compiler to be able to do that and one thing you should know is that there is a set of requirements that the compiler enforces on our code for it to be able to compile successfully and those requirements are the rules really that we have to follow in our c plus plus program and if we break those rules we're going to get problems and these problems are going to come in the form of compile time errors run time errors or warnings let's look at compile time errors in detail here we have a simple c plus plus program that has a few problems we have forgotten to put the semicolon at the end of our stdc out statement here and the compiler is going to freak out because of this if we compile this program we're going to get a bunch of errors and the ide is going to show us this problem some ides are going to give you different errors for example here i was using codelite and it was saying error expected semicolon before return or something like this so this is a compiler error and if you have this kind of errors your program is not going to compile compilation is going to fail you're going to get this error and you're not going to get your binary executable and when you have this you basically have to go back and fix this problem compile again and when you get rid of these problems the compilation is going to succeed this is what a compile time error is another thing you can have is the run time error this is not going to cause a compile time error the compilation is going to succeed but when you run the program it's not going to do what you intended it to do in the first place for example you may want it to print green on some user interface it's going to print gray or whatever it's really not going to do what you want so it's a logical error that you have in your program and you have to fix it to get rid of this and another thing you should know is that sometimes these run time errors can cause your program to fail and terminate immediately and we say that the program has crashed we're going to see an example of this in a minute the last kind of problem you can have in your program is a warning this is a problem that is not serious enough for the compiler to halt your compilation compilation is going to", "7495.84 - 7796.8": "compiler telling you you are doing something that has some problems and you should really fix it before it becomes a serious problem so that's going to be a warning for example here you see some compilers can warn you when you divide stuff by zero and we're going to see how this works the main message in this lecture is that you may have problems in your program and they are going to come in three forms some are going to be compile time errors some are going to be run time errors some are going to be warnings we are going to hop over to visual studio code and actually play with this okay here i am in visual studio code the first thing i'm going to do is to set up the template project we're going to be using in our project here the project is going to leave in this folder errors and warnings i am going to copy over the files and i am going to go in the current project we're going to be working on and i am going to open this folder in visual studio code i am going to go to file close folder i am going to close this one and i am going to open our new project i am going to browse to it the project is this one i am going to select it and select folder and it is going to open up in visual studio code i am going to close this welcome screen and open our main cpp file we are going to get rid of this constable fan this is a c plus plus 20 test thing we had and we don't really need it now we're going to get there in due time what we want to see is compile time errors we're going to put in our stdc out statement hello world as we usually do we're going to end this stdndm and we're going to remove the semicolon on purpose and if we try to compile our program like this we're going to get a compile time error this is what we want to see so let's try and build our program we're going to run the task to build with gcc and you see that the world fails we're going to get a bunch of errors in our terminal it's going to say in function it main expected a semicolon before return it's going to try its best to tell you what the problem is but sometimes these errors can be really confusing in this case it is really easy because we introduced this error on purpose so we're going to fix it in a minute but before we do that i want you to see these problems tab it is where the problems are going to show up in visual studio code so you should see your problems in here or through the terminal here okay one thing you should know is that when you have a compiler arrow compilation is not going to succeed and you're not going to have your binary file which is what you really want so to fix this problem we're going to put in our semicolon here we're going to build again we're going to go to terminal run task we're going to build with gcc and this time you're going to see that compilation is going to succeed and we have our program here we can run it through the terminal here so we're going to click the terminal is going to go away but we can open our own and if we do dur we're going to see our files in here and we can run our program we can say rooster and if we run we're going to have hello world so i hope this really makes it very clear what a compile time error as so this is one kind of error you can get the other one is around time error and this comes in the form of things that don't work as you really expected so let's say we are trying to do some computation in our program we try to take 7 and divide this by 0 for example and this is a statement there is a load in c plus plus so let's try and build this and see what we get because this is a common scenario where we have run time errors we're going to run the task to build with gcc okay if we do this you see that world finished with warnings we didn't get a compile time arrow and our build was successful so to really prove this i'm going to go back in our directory i'm going to do dur you're going to see that rooster is there i'm going to remove it i'm going to say rooster.exe this is how we remove stuff from the command line when i do this and do dirt again the executable file should be gone so let's try and build with this statement and and you're going to see that we get a warning and not a compile time error like we had here so we're going to go to terminal run task we're going to build with gcc and you're going to see that we're going to have our executable here but we had a warning and it's saying that division by 0 was detected in our program and it is a recipe for disaster so why is it a disaster let's try and run this program so we're going to", "7796.8 - 8095.28": "to run it if we run it it's going to say hello world and it's going to end let's try and actually use our own terminal to see if we have a better chance of seeing the problem here so i'm going to reveal in explorer by clicking on main cpp and i am going to try and open a terminal window here powershell that we open ourselves we've done this before this shouldn't be new to you by now so we're going to do dirt in here and we're going to try and run the program and it's going to run so so it's not really giving us a run time error here because we're not capturing this or trying to use the result of this division here we're just doing the division which is a problem so let's try and capture this we haven't learned about variables yet but what we're going to do now is do end value and we're going to assign the result of this division to this value and let's try printing the result of dividing a number by zero so we're going to do stdc out and we're going to say value and this is how you can print a value out on the console okay now that we have this and let's try and weld we're going to run tasks and worldwide gcc we're going to get the same warning but if we try to run the program we're not going to get what we expect let's run rooster exe we expect it to say hello world and printed the value but you see that it's really struggling to print the value and it gave up and ended immediately so this is one example of a runtime error that you can face in your program there are many other kinds that we're going to see as we progress in the course here we are just trying to raise your awareness on these problems so that you can know how to fix them when they come up okay so this is all i can share with you now about runtime errors we also had a chance to see that this is also going to give you a warning and a visual studio code here is also helping out telling us that we may have a problem it's turning the main cpp file yellow and it's saying that there is one problem in this file and if you go here you're going to see that we have a warning here okay so this is one way you have to see this so this is not recommended to do so we're going to comment this out okay this is really all i had to share in this lecture we had a chance to look at compile time errors we also had a chance to look at warnings and run time errors using this example if you get a warning it is a message the compiler is giving you that you should really look it up and fix the problem before it becomes more serious compile time errors are going to cause your compilation to fail and that's a really good thing because the compiler is going to stop you from generating a binary that doesn't really do what you expect it to do so that's a good thing but sometimes the compiler want to give you a compile arrow and you have a chance to run into a runtime error and that's really bad so be careful about these things and when you have problems visual studio code is going to show you the problem in terminal or in this problems tab and you're going to be able to fix it up we're going to stop here in this lecture in the next one we're going to learn a little more about statements and functions go ahead and finish up here and meet me there in this lecture we're going to learn about a little more about statements and functions in c plus plus a statement is a basic unit of computation in c plus plus you can say that it is the smallest thing your cpu can execute in your program every c plus plus program is a collection of statements so you're going to have a bunch of statements that are organized in a certain way to achieve whatever it is you want and statements in c plus plus must end with the semicolon we saw in the last lecture that not putting that semicolon is going to result in a compile time error here is a basic sample c plus plus program that we're going to use to learn about statements in the main function here we have two variables declared we haven't really learned about variables but they are a way to store data in your program and here we are storing two decimal numbers one is called first number the second is called second number we can do something with these variables that we have in our program for example we can add them to have another variable in our program and we can print that so you see here we are saying stdc out the sum of two numbers is sum so this is going to print 21 because it's going to add 12 and 9 and the result of that is going to be displayed on the terminal if we run this program what i really want you to notice is that this and first the number equals 12 thing is a statement in c plus plus so it must end with a semicolon the line", "8095.28 - 8395.358999999999": "statement so it must end with a semicolon every single line we have here in the main function is really a statement and it must end with a semicolon if we don't put the semicolon in place we're going to get a compiler error okay one other thing that is really important to keep in mind is that statements are executed in order in your program and the order is from top to bottom if you go back to our program here so the first statement is the one with first number here 12 is going to be installed in memory when this statement is executed by your computer and we're going to go to the second statement with second number and we're going to keep going until we hit the end of the main function and the return statement is going to execute and when the main function returns or terminates we're going to get the return value sent to your operating system and it's going to know if your program ended successfully or with a problem and the operating system is going to know what to do with that information execution keeps going until we hit the end of the program or if there is any other condition causing for the program to terminate and we're going to have more details about these things later i just want you to know that the statements are executed in order in your main function another concept i really want you to have an idea about is the concept of functions a function is really like a machine you give it input and it's going to give you output if we look at the operation here to add first a number to second number we can consider first number and second number as input to the function and sum is the output of the function we can visualize that like this so we have a first number and the second number we pass that into our machine which is really a function and we're going to get the result of this function in a return value or something that we get out of the function as our result c plus plus has a special syntax we use to define functions this is our function to add numbers on the left we have an integer which is code name for a whole number in c plus plus it's a number without decimal points and it's a whole number after that we have the name of the function and we can name it whatever we want and after that we're going to have the list of parameters that we can pass to the function and this is going to work as the input to the function after you do that you're going to have a pair of curly braces the one is here the other is here to the end and within those curly braces it's going to be the body of the function inside the function you see that we are declaring a variable which is called sum and we are storing the sum of first number and second number in this variable and we are making this function return the sum as the result and we're going to be able to capture it if we call this function in a function like me you're going to see how this works in a minute a function must be defined before it's used so you can't really call a function you haven't defined first in your c plus plus program and here is a slightly complete program to really put all these ideas together we have our function to add numbers it takes two numbers first number and second number it's going to add them up and store the results and we're going to return some to be used by whoever called this function and if you look in our main program we have a statement here we're going to store the result of add numbers in the sum variable and we pass first number and second number in the function and we're going to have that result stored in here here we also call the function with direct numbers you see that we pass in 34 and the seven and we're going to print out the result here this is the basic idea i want you to have about functions they are reusable pieces of code that group together a bunch of statements to do whatever it is we wanted to do in that function one benefit about functions is that we can reuse the code here if you look here we are calling this function multiple times without really rewriting these statements that are inside the function i know some of these concepts might be cryptic to you right now we are going to go to visual studio code and try this in code and you're going to see exactly how this works okay here we are in our folder where we are storing our projects i am going to grab the code from the template project i am going to put that in the current project which is statements and functions i'm going to paste that in here and i am going to open this up in visual studio code i am going to close the project we have right now and i am going to open our new project let's browse to its location i am going to open the project on statements and functions let's open this", "8395.358999999999 - 8695.6": "going to have our starter project here i am going to take out whatever we have in the main function and take out this contival thing we don't really need it and we are going to try and define two variables using two statements we are going to say and first number and we're going to put in a value let's say three and we have to remember to end this with a semicolon so this makes our statement we can encode this in a comment to make this pretty clear we're going to also define a second variable so we're going to say ent to mean that it is a whole number it doesn't have decimal points like 2.5 it is a whole number like one or seven or ten so we're going to say second number we can give it a name and uh let's put in a seven we're going to store these values in our program and we can print these values out let's print them out first so we're going to say stdc out we already know how to do that and we can say first number and we can change these output statements and say the first number is first number you can do that std endl and you can notice that visual studio code is really helping out in auto completing things we have in our program let's print the second number to really practice this so if we do std you're going to see that it's going to give us a bunch of options we can choose from if you want you can scroll through this with your mouse or you can just type whatever you want to type so i am going to do c out and it's going to try and help out if i really want i can come on c out here and click on it and it's going to be auto completed which is pretty cool so we're going to say second number and we're going to say second number here and it's going to auto complete for us endl and we can try and compile this program before we do i want you to guess what we're going to get when we run this program give it a guess we are then going to go to terminal run task and we're going to build this with gcc the world is going to be successful we're going to open this in our terminal the terminal goes away no problem we're going to open it again and we are going to go in our folder and do the ir and you're going to see that we have rooster.exe our program we can run it and it's going to say first number three and second number s7 this is what we have stored in these variables and the benefit of storing your data in variables is that you can change the variables and let the rest of your program really do the same things and pick up the data that you have in those variables for example we can put 13 in the first number and if we build again this number is going to be picked up by this code and we didn't need to go in and manually change data in these sddc out statements here let's weld so that we can see this and we can close this by clicking and if we run rooster again it's going to say 13 and 7. play with this a couple of times until you really feel confident and if you have any problem don't hesitate to ask me i am going to do the best i can to help you out now that we have these numbers stored in our program we can add them up let's say and some we're going to declare another variable and we're going to say it's equal to first number plus second number and we're going to end this with a semicolon and we're going to print the sum out let's do sddc out and we're going to say the sum is sum we're going to print our variable here and we're going to print a new line character with std endl we're going to build our program so that our changes are reflected in our binary here so we're going to go to terminal run task weld with gcc the build is going to be successful we're going to press any key we are going to click here in the terminal and we're going to hit enter and run rooster again and we should see the sum and you see it says the sum is 20 which is what we expect now we are doing the sum here but it would really be better if we're not doing the sum in the main function here what if we actually took this code and wrapped it in a function that we could reuse whatever we want we have seen how we can declare a function so let's do that we're going to follow the same structure we saw in the slides earlier so we're going to say and this is going to be the return value or what we get out of the function then we're going to put in the name of the function we're going to say add numbers and we're going to pass in the parameters the parameters can really have any name you want but you have to specify the type of the parameter first so the parameters are also going to be whole numbers like 1 5 7 or whatever you want and we're going to say first program", "8695.6 - 8996.319": "whole number an integer and it's going to be second param okay after we do this we're going to specify the body of the function which is going to be between these curly braces i am going to jump to the next line so that this is really easy to see so i am going to define our sum variable inside the function it's going to be a whole number and i can call it whatever i want so let's call it result because it's going to be the result of this function and the result is going to be the sum of first param and second param okay i hope this makes sense and we're going to end this with a semicolon because every statement in c plus plus has to end with the semicolon after we have the result we need to give it back to whoever called this function and we're going to do that with a return statement and we're going to return the result to whoever might have called this function here now that we have the function we can actually use it we're going to go back in our main function and what we're going to do is to reuse this sum variable and store in whatever is returned from our function the syntax for that is going to be sum and we're going to say equals and we're going to say add numbers and we can pass in whatever two numbers that we want to add up let's pass in 25 and 7 for example we would expect this to give us 32 so if we print the sum again we can just complete this statement that prints the sum and reuse it here let's align this a little bit and i want you to take a guess at what we are going to get from this program right now we have these two numbers we are adding them up if we get here this should print the first number which is going to be a 13 so here we expect to get 13 and by the time we hit this second number statement we are going to print the second number it's going to be 7. if we get here we're going to print whatever is stored in sum and in sum we have the sum of first number and second number so this should print 20 right and here we are doing another sum of two numbers but we are using a predefined function that we have here before the main function because you have to define the function before you use it okay if we add 25 and seven we are going to fall into this function and it's going to add those numbers up and we're going to get a 32 in here and that's what we're going to return and it is going to be saved in this variable if we print it out it's going to give us 32. i hope this makes sense let's build and run our program run task world with gcc the world is going to go fine we're going to go back to our terminal here that's clear so that things don't disturb us and uh bring in some confusion we're going to run our rooster program and exactly what we have here we have a 13 from the first statement here we have a 7 from this statement here we have a 20 from this sum here which is here and we have a 32 that we got from this function the good thing about functions is that we can reuse them now that we know how to use it we can use it again and we can say sum equals add numbers and we can say 30 and 54 for example you add them up and you're going to get the results so we're going to print the result some and we're going to put in the sum i really want you to take some time and play with this statement so that these things make sense it's really not that difficult but you just have to rock your brains around how c plus plus defines these things so we have this statement and we are adding 30 and 54 so it should get an 84 after the 32 here let's weld we're going to run the task to world with gcc we're going to click on the terminal here and hit enter let's clear so that we don't have things disturbing us and we're going to run our program and we have our trusty 84 here i really hope this makes sense and as a bonus i'm going to show you that you can also call things in the stdc out statement here without having to store them in some predefined variables and sometimes this comes in handy so you can say std see out and we're going to say sum and you might say add numbers right in here and you're going to say 3 for example and uh 42 and this is going to give us a 45 that's what we should expect to see after 84 here so that's world and running the task to build with gcc the world is going to be successful we click on the terminal here", "8996.319 - 9295.76": "with output we're going to clear so that we see our output without noise we're going to run our program and we're going to see a 45 here i really hope this makes sense the whole point of this lecture was to make you aware of statements and function a statement is the most basic unit in your c plus plus program it basically lives on one line but it can also spread across different lines but we're not going to look at that here maybe we're going to see that later in the course statements are executed in order so when our main function gets to be run by the computer it's going to go from the first statement second statement third statement and it's going to go until it hits the end and we can see that here in the order in which our numbers are printed it is going from top to bottom we have also seen that we can split our code in different functions and wrap whatever functionality we have in a function we have seen the basic concepts on functions a function has a return value it has a name and you have to give it the parameters and you put the body of your function within these two curly braces as an exercise i would challenge you to do a function that multiplies two numbers and call it in the main function here to see the result if you have any problem please do ask me i am going to do the best i can to help you out this covers all we set out to do in this lecture and i hope you found it interesting we're going to stop here in this lecture in the next one we're going to see how we can input and output things from our c plus plus program go ahead and finish up here and meet me there in this lecture we're going to learn about how we can get thanks in our program and get things out of our program and that's basically input and output to and from our program we have actually been doing this all along we have been printing things from our program to the console and with this technique you can really think of stdc out as a highway that goes from your program to the terminal you can basically think of it like this data is going from your program to sddc out and it's going from here to the terminal and from this you might get an idea why these less than signs kind of point to the left because data is going from your program to htdc out and these two symbols point to the left they point to hddc out to signal to the fact that data is going from here to here i really hope this makes sense because sometimes these things can confuse people this is the reason why it's going from your data to stdc out data is basically going from your program into httc out and the sddc out is one way we have to get data from our program to the console there are many others we have std c e r r or std server this is what i'd like to call it and what it does it prints errors to the console we have stdc log which is going to print log messages why do we have these different things different programs might decide to format these messages differently because they are different messages one is a simple message from the program another is the narrows you might want to turn this red to really bring the attention to this message because the user has to solve that problem another might be a log message that you want to store in some file or some database uses for these things differ and c plus plus makes sure to give you different ways to state your intent through the tools that you use we have looked at sddc out sddc error and stdc log what does sd c i n do it does the reverse it's going to take data out of the program and bring that into the program so let's look at a few examples using these here we have an example of printing data from the program to the terminal through c out cr and c log here we have a hello world message going to c out here we have a number going to c out this is what we've been doing all along we can also do a variable storing the edge for example it's a whole number it's an integer so we print this out and the message is going to go from the program to cl so you can think that things are going from the program to sddc out i really wanted this to make sense okay if we go down we're going to see that we can use cr to print errors to the terminal and we might say something went wrong or something along these lines to bring the attention to the problem and we can use", "9295.76 - 9596.0": "work the same way they all use the stream output operator and it is going to take data from the program to the output stream really this is what we mean here here is an example of how you might read data and bring that into the program here we have two variables one is the age it's a whole number or an integer and z plus plus and the other is a string this is a type that allows you to store strings in c plus plus we're going to learn a little more about this later but here i want to use it to really make it clear that you can get things from the outside and bring that data in your program so we're going to let the user type in the last name and this statement here with cin is getting data from the stream or from the highway through which data comes into our program and bringing that in our program and here it should be clear that the flow of data is in this direction data is going from c i n and we're storing that in a variable that we have in our program that is called name we do the same thing and ask the user to print the age and they are going to print that and the data is going to come from cin and we're going to store that in our edge variable here after we collect the data from the user we're going to print that and we're going to say hello we're going to print the name and we're going to say they are whatever years old this is what this program does and i really hope it makes it clear how data input works through streams in surplus plus another thing we can do with sddcin is chaining input and we can use this technique to grab data in one statement look at the program down here to really understand this we have the same variables age and name we let the user type in the last name and age separated by spaces and we grab the data like this we first grab the name after that we grab the age and we're going to print the same things and we can chain input stream operators like this to grab the data in one go and this may come in handy sometimes before we try these things in visual studio code i want to bring your attention to a problem that you are likely to come in contact with and that is reading data with spaces what if the user types the name with spaces for example you asked me to type my name i'm not going to type daniel i'm going to type daniel cafwaya and your program is going to run into problems c plus plus allows to solve this problem using std get line and you use it using this syntax you're going to pass in the stream where the data is going to go and you're going to pass in the variable that is going to read the data and you're going to have this information stored correctly in your program this might be not making sense yet to you we're going to go to visual studio code and play with us and i am sure it is going to make sense okay here we are in visual studio code and we have our project where we're going to store our files data imported output we're going to copy code from our template project and we're going to put the data in and i am going to open this folder in visual studio code so let's close whatever we have now and i am going to open my folder let's browse there i am on this folder data input and output i am going to select that and the project is going to open up in visual studio code i am going to jump to my main function i am going to take out things we don't need and the first thing we're going to do is printing data we have really done this so we're going to practice this a little bit we can say stdc out and we can say hello c plus plus 20 why not and we're going to put an std endl at the end and remember our semicolon and here i want you to really put in your head that data is going from our program here to hddc out and sddc out is going to dump that on the terminal that's how this works you can also do a variable let's say ant age for example let's say 21 and end this with the semicolon and we can also print the h we can say sddc out and we can say age this is going to be sent to the output stream and we're going to do sdd and dl to add a new line character at the end and we can try and build this before the program gets more complicated let's go to terminal we're going to run the test world with gcc and if we hit enter on the terminal here the terminal is going to go away we're going to create a new one no big deal and uh if we do dir we're going to find", "9596.0 - 9896.08": "going to say hello c plus 20 and the age is going to be 21. we are successfully taking data from our program and printing that to the terminal this is pretty cool and you can think of sddc out as the highway that is really going to take your data from your program and bring that to sddc out like this we're also going to take the age it's going to go through sddc out and it's going to show up here you can think of this like this okay now that we have used sddc out we can use sddcr and sddc log in the same way so we're going to say sddcr i'm going to say error message and the message is going to be something is wrong you may do whatever you want in here and we have to remember to put a new line character otherwise data is going to be cramped on one line we can also use sddc log it really works the same way c log and we can say log message and we're going to say something happened and we remember to put std endl and our semicolon if we build this program you might guess what it's going to do it's going to print these things on the terminal but this might be useful to terminal programs that support features to format different messages directly the program is going to know that one message is a simple message the other is an arrow the other is a log message let's run our program but before we do that let's clear so that we don't have noise here we're going to run the program and it's going to say the error message and the log message here okay now what we're going to look at is how we can get data into our program and data is going to be going in a different direction it's going to be coming from the terminal and flowing into our program what we're going to do we're going to do ant age one this is a new variable so we're going to put in data and we're going to bring in a string library to allow our program to store strengths the way we're going to do that we're going to include strength this is how you do it in c plus plus we haven't really learned about this type it's a powerful type in c plus plus but we will get it there when we have more powerful tools to really understand it we are just getting started here so what we're going to do we're going to say std strength and we're going to say name and we're going to ask the user to print their name and age you already know how to do that so we're going to say please type your name and age and we're going to do stdndl on this and how we're going to get data in the program we're going to use stdcin and we're going to do std cim and data is going to be going from the stream to the program so the stream input operator here points to the right and the data is going to be going in the name variable because that's what they're going to be typing in first because that's what we told them to do so we're going to store the name and we're going to say stdcim data is going to be flowing from sddcin into our h1 variable okay now that the user has given us their information we can greet them with a personalized message we're going to say stdc out hello and we're going to put out their name and we're going to tell them you are and we're going to put the age one because that's what they're going to give us here and i'm going to say years and we're going to put an std endl here i'm going to grab this and pull this to the left so that we can see our entire program here that's helpful so what we are doing here we are getting data from the user and we are storing that in our variables and we are printing the message so that the user can see it i don't want the first things we did here to disturb us when we world and try this out so i am going to comment this out and comment the first block of code out using blog comments i think this is the first time we use this and uh this is going to be ignored by the compiler now and it is only going to consider this and this is going to be pretty cool let's go down a little bit here and i try to build the program we're going to run the task that welds with gcc and uh looks like the world is good we're going to hit enter and we're going to clear so that we are not disturbed by this we're going to run the program let's say rooster.exe it's going to ask me to type my name and age my name is daniel i'm going to type that hit enter it's going to want me to type my age so i am going to say", "9896.08 - 10197.12": "and it's going to tell me hello daniel you are 33 years old i put a slash here we can try and run it again so that i don't have to make that mistake again so daniel that's my name i hit enter i say 33 and if i run it's going to say hello daniel you are 33 years old i really hope this brings the point home that stdcin is a highway that takes data from the terminal into your program so this is really what is happening here when i type daniel it's going to flow from the terminal and it's going to go into my variable which is name here and when i type the age it's going to go in my edge variable here and all these happening through in here okay one other thing we can do is grab the data and put that in our variables in one go so what we can do here is comment this out and we're going to do stdcin and we're going to put that in name and we're going to change these two things and put the other piece of data in h1 if you run the program it's going to work exactly the same way but we are grabbing the data in one line so let's weld to see this in action we're going to run the task that worlds with gcc we're going to click here and we're going to clear if we run rooster it's going to ask for the name and the age i'm going to put in daniel and i'm going to put my h and say 33 for example and it's going to do exactly the same thing but we have one compact line the last thing i want to show you in this lecture is how you can grab data with spaces because if i try to put in data with spaces here the program is going to fail miserably let me show you this i'm going to clear and i'm going to run rooster again and i'm going to say daniel i'm going to put in my full name and uh it's really not grabbing the second name and it didn't give me a chance to input my age and this is really bad so c plus plus provides a way to solve this using std get line so let's see what we are doing here and before we play with this we're going to comment out what we had here so that it doesn't disturb us in what we are about to do so let's come down here and say that we were doing data input this is helpful here and we're going to go down and grab data with spaces so i am going to set up another strength and this is going to store my full name that's what i'm going to say here and to grab it i'm going to tell the user to type in their full name and age so i am going to sddc out so the way i'm going to grab the data i'm going to do std get line you see that we have this function here and it's going to take an input stream so asd dcin is going to work and the second parameter is going to be the variable where this string data is going to be stored we're going to pass in our full name and this is going to work just fine and we're going to also grab the h using the same technique we've used before so we're going to say stdcin and we're going to store that in our h3 variable once we have the data we can greet our user using the same message we had before so i'm going to copy that if i can do that and i'm going to paste that here i'm going to bring this to the same location it's going to be full name here and it's going to say h3 and let's try and weld we're going to terminal run the task to bolt with gcc and we have a problem because we forgot our semicolon see how these problems might come to you uh-huh so we're going to put in our semicolon and another thing i really want you to see is that you can bring these things to the next line if they turn out too long like we see here so i can for example put this to the next line and it is going to work just fine so what i am going to do i'm going to try and weld again run task to build with gcc you see that the world is good we're going to bring in our terminal i'm going to clear so that we don't have noise here and we're going to run our program it's going to ask me to put in my full name i'm going to say daniel and it's going to want the age i'm going to say 33 and it's going to reach me hello daniel gaway you are 33 years old we are able to bring data with spaces into our program and this concludes what we had to say in this lecture i hope it made it very clear what these htd n and stdc out things are they are basically highways that take data out of your program or bring data into your program and the way you use them is what we've done here in this course i would encourage you to play with us a couple of times if this is the first time you're doing this we are going to stop here in this lecture in the next one we're going to try and recap on the c", "10197.12 - 10495.438999999998": "and finish up here and meet me there in this lecture we're going to explore the c plus plus execution model and show you a simplified version of the memory model of your c plus plus program here is how our program looks it is a simple program in our main function it is going to call a simple function that is going to add two numbers we have seen a program like this before and when we compile it it's going to be turned into a binary this black icon here represents the binary executable and it is not in the format that you can read with your eyes if we come back here to what we were doing in the last lecture we can see our rooster executable binary here if you try to open it here you're going to see that visual studio code is going to say the file is not displayed in the editor because it is either binary or uses an unsupported text encoding so it says i can't really say this because it's binary and it says do you want to open it anyway if i try to open it it's going to be just some gibberish because this is binary it is meant to be read by programs it is not meant to be by ides or text editors like visual studio code so this is the binary file we have here i tried to put a simplified version of this program to represent binary so that we can follow it up but it is not in the form that is readable by any human out there unless you are a machine so why is it in binary because binary format is easily understandable by your cpu and we're going to see how your program is loaded in memory and executed statement by statement by the cpu so that you can really understand this so here is a representation of your program here we have our how to drive and we have the program sitting somewhere on our hard drive in binary format and it's waiting to be run by you by double clicking on it or opening it in the terminal and on the left here we see a representation of the memory of our computer and when i say memory i mean random access memory i don't mean memory on your hard drive this should be really clear this is the random access memory of your computer that is running your programs very fast so when you double click on our program or if we open it in the terminal the binary file is going to be loaded up in memory and you see it in red here this is a representation of that and it is ready to be run by the cpu by the time the cpu says in the memory location it's going to know i have a program to run and the cpu is going to start running it statement by statement it is going to start by the top so it's going to see that it needs to allocate space to store our integer a it's going to allocate to that somewhere on the memory in yellow here you see a and it's going to see that it should store in a value of 10 and it's going to do that you can see that here it's going to go to the next statement and the next statement tells it to allocate space for a value b and it's going to store in f5 it's going to go to the next statement it's a variable called c it's going to allocate space for it but we didn't specify a value for c so what it's going to do is store in some junk value the value in there is really unspecified at the moment it's going to jump to the next statement and what it's going to do is print some things on the console and it is going to do that it's going to jump to the next statement and it is going to print statement 2 and here it is going to notice that it is going to call a function i don't know if you have noticed but the cpu has allocated a special memory location for our function the function doesn't leave with our code here or anywhere near the variables that we have here there might be a huge chunk of memory between these two or three things so the cpu knows that it is going to jump to another location it's going to ask itself if i jump to that location to run this function how am i going to come back and the cpu is smart enough to store the return address and that's what it's going to do it's going to say if i go to that function i want to come back to the address 6 and run whatever is after this address so it's going to store 6 and cpu memory and it's going to jump to the function it's going to take the first parameter as a and the second parameter as b so a is done the parameter 1 is going to be 10 it's going to take parameter 2 it's going to be 5 because it is b here and in b we have a 5 and it is going to jump to the next statement in the function and it is going to add up parameter 1 and parameter 2. after it adds those things up it's going to return the result to c we can see that here okay that's what", "10495.438999999998 - 10796.08": "the results in c and the result is a 15 so we're going to write that in there and now that the function is really done it's going to come back to its address and it is going to jump to the next segment after that it is going to print three statement three it is going to jump through the next line and print statement four it's going to do that and by this time we have reached the end of our program and it is going to be popped off the memory and your program is basically going to end this is how your program is executed by your cpu and why am i showing you this because it is really good to have an idea of how memory is allocated and used by your program another good reason is that some c plus plus feature require you to have an understanding of a memory model like this to understand how they work for example you have seen that to call this function the program had to jump from address 6 to 30 and this is really heavy especially if you are running a simple function like we are doing here to add two numbers so the cpu can realize that and optimize this call to the function to an inline function and add these two numbers up right here at address six without jumping to this address here and this may come in handy and you need an understanding of this memory model to really understand these features this is just one example i am giving you you are going to reuse this model a lot in your career as a class plus developer and i thought it was a really good idea for you to understand it firsthand this is really all i had to share in this lecture i hope you found it interesting in the next one we're going to try and understand the difference between three key components of the c plus plus programming language go ahead and finish up here and meet me there in this lecture i want to highlight the differences between what we call a c plus plus core language feature or a standard library feature or an stl feature because these are terms that come up a lot if you happen to read some documentation about c plus plus a core feature is really a basic building block that makes up the c plus plus programming language you can think of it for example how you define variables the rules that govern how you can define and use a function in c plus plus the rules that say what you can do and not do with the basic features of c plus plus that's really what can be qualified as the core feature of the c plus plus programming language i don't know if that makes any sense if we come back in visual studio code we have a program we have used in the last few lectures for example these basic types that you use in c plus plus the rules that define how you can define a function for example if you put a an angle bracket here and try to compile this program it is not going to work because we have violated the rules of the c plus plus programs the basic rules that define how the c plus plus programming language works the basic types that are defined in the c plus plus programming language these little things make up the raw ingredients you use to make up a proper c plus plus programs and these little row components that you use to put together a c plus plus program are called core features you can think of them as the foundation on top of which we really build daily use c plus plus programs the standard library is a set of ready to use highly specialized components that we can easily use in our c plus plus programs and again coming back to our program in visual studio code iostream here is a standard library feature string here is a standard library thing we have in the c plus plus programming language and again the c plus plus standard library tries to provide highly specialized components that we can use in regular c plus plus programs when you use the c plus plus programming language you don't really want to extend the c plus plus programming language you want to use it to build something of your own and uh the standard library features are things you use to work on your programs very fast for example we have used sddc out without really going into the details of how the data is taken from this program to the terminal that's really advanced and probably complicated but it is wrapped into this reusable components and one of them is iostream and we can use it relatively easily in our c plus plus program okay i hope now you have a better idea of what the c plus plus standard library is now what is the stl the stl is really part of the c plus plus standard library but it is a", "10796.08 - 11095.199999999999": "them as collections of things and we have a set of types that allow us to store collections we have algorithms or functions that work on these collections and we have specialized types that are called iterators that allow us to navigate through these containers potentially running these algorithms on each element in the collection this is probably not making sense by now but you can think of the stl as a highly specialized part of the c plus plus standard library and we're going to learn about many features of these things throughout the course but i want you to have a basic understanding between these three terms a core feature of the c plus plus programming language is standard library feature and the stl and i really hope this is clear to you by now in this chapter we're going to learn about variables and data types before we talk about variables and data types i would like to take a moment and recap on what we know by now and if you look at these cards many of these things should make sense now you know about the main function you know that it is the entry point of your program you know that your program is going to be made up of statements and statements and with a semicolon in c plus plus you know about functions errors warnings you now have an idea about how you can handle input and output from your program you can use comments you know about the memory model and the execution model that we talked about in the last lecture you know quite a lot now we have been using a program like this to do things in the last chapter but there is one thing that isn't really explained yet and that is this ant this end is a type that is predefined in c plus plus and c plus plus predefines many types here we have a couple of these types for you to see as examples it is one of them we have seen it a lot of times in the last chapter it is used to represent whole numbers like one two and three but we have others for example double and float are used to represent fractional numbers numbers that have decimal points for example 2.5 7.3 and numbers like that and we're going to see the difference between these two another one that is commonly used is char or car and it is used to represent characters in memory and you can store in characters like a b c and d and all the other characters you can really put in we have a bull which is a type that is going to store two possible states the only values you can really store in here are true or false and we're going to see how this works void is uh somewhat confusing because it represents a typeless type and it is really meaningful when we get to talk about functions in detail so we're going to learn more about the void type a little later in the course we also have the auto type which is really not a type it is a keyword you use in c plus plus to deduce other types and we're going to see how this works later in the course these are a few examples of types we can use in c plus plus and we are going to play with most of them in this chapter another thing i really want you to see is what does it mean to really put a 4 in a variable in your program everything you have in this program here is represented by ones and zeros in the computer's memory it really looks like this it's a bunch of ones and zeros in the ram of your computer and there must be a technique to make sense of this gibberish here and store data that makes sense to humans and the starting point is to group these ones and zeros into little chunks that we can manipulate each of these ones and zeros is called a bet so this zero here is a bit this one here is a bet and if we group eight beats together they are going to form what we call a byte okay if it makes sense you can group your bits in bytes or if it makes sense to group them in groups of 16 you can do that like we see here we're going to see a little more details about this in the next lecture okay here you see that if you really want you can treat each bit as a self-contained piece of data but this is really not very useful but there are some corner use cases for this okay now we really have two sides on the right we have data in the format that is really convenient and understandable by humans and on the left we have how data is represented in memory so there must be a way to transform between these two forms of data because humans can't really handle these ones and zeros well and we do the transformation between these two representations of data using", "11095.199999999999 - 11395.76": "systems available to us that we can use binary octal hexadecimal are a few examples and we're going to learn about them starting in the next lecture so go ahead and finish up here and meet me there in this lecture we're going to learn a little more about number systems number systems allow us to transform data from the form that is really convenient for humans in a form that is convenient for computers in these ones and zeros that you see on the left we can also use them to do the reverse go from ones and zeros and go in the format that is convenient to humans like this 22 or this steve name here to make sense of how these number systems work let's analyze the decimal system that we really use in daily life and that is usually called base 10. so if you look at this 2371 number here we can really split it in the form that you see to the right here if you try and take this expression we have on the right here and evaluate it you're going to get this number here 2 times 10 to the power of 3 this evaluates to 2000 and this one here is going to evaluate to 300 this one is going to evaluate to 70 and the last one is going to evaluate to one and if you add these things up you're going to end up with this number so this is how we can take a number and uh make up a base 10 representation of it we can do the same thing for 924 here or 47 here it really is basic math you don't need to have a lot of background in math to make sense of this so we're going to use this exact form and understand binary numbers if you look at what we have here we have a few binary numbers that are made up of ones and zeros that's why it's called binary because you can only have two states or zero or one in your numbers so we can really do the same thing we are in base two so instead of using a ten here we're going to be using a two but it is the same operations we really did if you take this and multiply and add these things up what you're going to end up is a base 10 representation of this number if we go in the middle here we have something we can easily do without using a calculator the expression on the left here is going to evaluate to zero because we are multiplying with zero the second one is going to be a two because we are taking one and multiplying this by two the others are going to be zeros but the last one is going to be 2 to the power of 4 which is 16 and we're going to add a 2 and this is going to evaluate to 18. we can actually bring up our calculator on windows 10 i think it can help in this a little bit we're going to bring it up and we want to put it in a programmer mode and we're going to go back on our slide and find our number which is one zero zero one zero so we're going to type it out one zero zero one zero in binary this is binary that we have typed here so let's clear this and do one zero zero one zero and you're going to see that in the decimal it is 18 which is what we came up by computing this in our brain let's try the one we had before that we couldn't really do in our brain we're going to say one zero zero one zero one let's do that we're going to clear one zero zero one zero one this is going to evaluate to 37 in decimal and you can use calculators like this to really do the transformations between these different number representations okay down below we have a one one one which is going to evaluate to a seven in base ten okay if we have three digits we can really represent numbers between zero and seven and you see a table here that is going to prove that zero zero zero is going to evaluate to zero in decimal zero zero one is going to be a one and if you go down to one one one that is going to evaluate to a seven you can try and use a calculator to prove this and really understand how this works if we use the three digits representation our numbers are going to look something like this in memory we're going to take the bits in memory and group them in groups of three and we are going to use binary to actually make sense of these numbers for example here on the left this is going to be a one the second one from the left is going to be a six and this is going to be a six as well this is going to be a zero this is going to be a three because we have one and two here we add those up we get a three if this doesn't make sense you can try and use a calculator you're going to see that it makes sense okay so what if we want to group our digits in groups of four we can do that and we're going to end up with something like this the values we can represent are going to", "11395.76 - 11696.0": "try and prove this using the calculator like we just did and it is going to look like this in memory so what we really are doing is grouping the bits in different sizes of data and we have a kind of formula that we can use to make sense of the data in memory for example on the left here we have zero one one zero if we go back to our table and defined zero one one zero this is a six and we're going to know that these four bits here are really storing s6 and there are ways you can manipulate this in your c plus plus program we're going to see that you can also use five digits and you're going to end up with something like this and the numbers are going to go from 0 all the way to 32 and this is how it's going to look in memory you can try and come up with what this represents in decimal i'm not going to tell you this but we can try and figure out the one on the left here so it is 0 1 1 0 1. if we go back we're going to come up to 0 1 1 0 1 which is a 13 here so this memory location these five bits represent a 17 number so if we want to kind of generalize what we have talked about in the last slides if you have one digit you can really represent two states zero and one if you have three digits you can represent numbers between zero and seven and you can go all the way down and if we generalize this in a mathematical formula we can say that if we have n digits we're going to be able to represent between 0 and 2 to the power of n minus 1. and if you try to plug in any number of digits you're going to see that this formula works okay so these are a few grouping of bits we have in practice we can use eight digits and we can represent numbers between zero and two 255 if we have 16 bits we can represent this range if we have 32 bits we can represent this range if we have 64 bets we can really represent a really huge range i can't even say this number it's really bad okay now you should have a pretty good idea of the binary system and different representations we can use to make sense of binary numbers in a computer's memory the last thing i want you to see is what we call hexadecimal number system and it is a technique we use to shorten the length of how we represent a binary number in memory how does it work well we take our number and split it in groups of four bets and each group is assigned a symbol we can use to represent it if we have four zeros that's going to mean a zero in hexadecimal if we have zero zero zero one we're going to represent a one and you can see that if we go up to nine this is really similar to what we have in the decimal number system but once we hit 10 we're going to represent that with an a in hexadecimal 11 is going to be b 12 is going to be c 13 is going to be d 14 is going to be e and 15 is going to be f so how do we use this to represent binary numbers let's see an example here we have a huge number that we represent in memory it starts with zero and ends with the one here so the first thing we're going to do is to split this in groups of four and the one on the left is going to be a one one one one if we come back to our table here one one one one means f so we're going to represent this with an f if you go to the second group of four bets we have zero zero one one if we go back zero zero one one means three so we're going to have a three here i hope this makes sense and we're going to keep using the same transformations and we're going to come up with one f 0 3 e 6 and we can represent this binary number using these symbols you can see that we go from using 32 bits to using one two three four five six seven eight symbols to represent this and this is shorter and easily manipulable by humans and we use a zero x in front to mean that this is a hexadecimal number i really hope this makes sense so if we have numbers that don't really fit in groups of four we're going to go from the left and split this in groups of four and we're going to end up with a group on the left that doesn't really meet our requirements and what we can do is add the missing bits and make them zeros and we call this operation padding this is what you can do to really represent any number in hexadecimal if you don't have enough bits on the left we also have another system that is really not widely used today but i am mentioning it here for", "11696.0 - 11996.399": "it goes from zero all the way to seven and we can divide our binary number into groups of three and represent using these zeros and ones to shorten the length of the binary number we can really do the same thing we did with hexadecimal so we're going to take our binary number and divide this in groups of three the one on the left is going to evaluate to a 7 because it's 1 1 1 and one one one evaluates to seven in octal system the second one is also going to be a one one one the third one is going to be one zero zero if we go in our table it's going to be one zero zero it's going to be a four and you see we have a 4 here and you can do the same things until you have figured out the entire number here and you see on the left we are doing padding and adding a missing bit and making it to 0 so we are coming up with 0 0 1 and if we go back to our table here 0 0 1 is a 1 and that's what we put here so we're going to put this number here it's going to be 15 61 41 70 47 7 and we're going to add a zero in front to mean that this is a number represented in the octal system i really hope this makes sense okay so we have seen all these binary numbers and different number systems we can use to represent them but how do we use them in a c plus plus program well i'm glad you asked here is a simple example of how you can represent the number 15 through different number systems in c plus plus if you just say 15 like this it's going to be in decimal if you add a zero in front it's going to mean that the number is in octal system so this can be confusing sometimes if you do 0 17 it's not going to be 17. so if you say 0 17 c plus plus is going to interpret this number as if it is in octal system and it is going to turn this into 15. down here you see the same representation in hexadecimal we saw that you use a 0x in front to represent that it is in hexadecimal and this is going to be 15 in memory and here we have representation in binary using zeros and ones and you use zero b in front like this i have to say that this was only possible since c plus plus 14. so if you are using an older standard of c plus plus you want to be able to represent binary like this and if we run this program it is going to print the same thing it is going to print 15 but we stored the number using different number systems let's go to visual studio code and try this out okay here we are in a folder i have on my system where i am going to be storing my projects for this chapter the first thing i am going to do is copy code from a template project i am going to go in and copy things over and i am going to put these in 4 2 number systems i am going to open this folder in visual studio code so i am going to go to file close the folder we have now and i am going to open up a new one open folder and i am going to browse to the location of my project i am going to open this project here that says number systems we are going to get rid of the welcome screen and open our main cpp file we're going to get rid of this constival thing and clear everything we have in the main function here the first thing we want to do is to store an integer that is 15 and we're going to say and number one the exact same thing we had in the slides and we're going to store 15 in this variable here this is going to be represented in decimal and if we want to store the semi number in octo we saw that in our slides we could store this as 0 17. so let's do that we're going to say it number 2 and we're going to store in 0 17. this is not going to be 17 this is going to be a representation of a number in octo system so we're going to say that this is octo and we can represent the number in hexadecimal as well so we're going to say it number three and it is going to be 0x because it is hexadecimal and we're going to say zero f this is how we represent it you can use lowercase or uppercase it won't really matter let's use uppercase here and we can use binary because we are using c plus plus 20. so we're going to say and number four and we're going to store in a representation of 15 in binary and it happens to be four zeros and four ones and we have to prefix this with a zero b this is how it works so this is going to be in binary and if we print all these numbers up we're going to see let me not tell you this what do you think we'll see okay so i went ahead and typed this out what do you think we will see when we build and run this program before we do that we're", "11996.399 - 12295.52": "it here and we're going to go to terminal run task we're going to build with gcc let's wait and see if the world is successful world finished successfully we have a rooster program in here we're going to click somewhere in this terminal and our terminal is going to show up if we do dur you're going to see that our rooster program is here and if we run it i want you to take a moment and guess what we're going to see hmm number one 15 number 215 in number 315 and number four 15. this is really the same number we are storing in these variables but we are using a different representation that is going to be convenient depending on whatever it is we are doing if it is more convenient to use binary we are going to use binary if it is more convenient use hexadecimal please do use hexadecimal but the representation of this number in memory is really going to be the same i really want you to take some time and let this sink in because you're going to see these things a lot of times in your career as a software developer so please do yourself a favor and make sure you really understand this okay this is really all we set up to do in this lecture trying to make sense of the binary numbers we have in memory and how we transform between them and different forms of data that is easily manipulable by humans all data is represented by a bunch of grouped cells of zeros and ones we have seen this as the range of your data grows so will be the number of digits you need to represent the data in memory we have seen that the hexadecimal system makes it a little easier for humans to handle streams of data in ones and zeros octo has the same goal as hexadecimal but it's almost no longer used in modern times i just mentioned it here for completeness we are going to stop here in this lecture in the next one we're going to look at integers in a little more detail so go ahead and finish up here and meet me there in this lecture we're going to learn a little more about integers in c plus plus integers are represented by ant and z plus plus it's what you see on the left here and they are used to store whole numbers things like 1 2 and 3. they typically occupy 4 bytes or more in memory but in most times it's going to be 4 bytes so for example if you have a variable called age and it is an integer this is how it's most probably going to look in memory it's going to take four bytes and i really want to make it clear what a variable is it is a named piece of memory that you use to store specific types of data okay so here if we have a variable named age it is a named piece of memory edge is going to be the name of that piece of memory and we can store data in that memory it's going to look like this in memory but the value is going to be stored in here in binary format i really hope this makes sense a variable is a named piece of memory that we can use to store different kinds of data and okay now we're going to look at a few examples of how you can work with integers in your c plus program you can define a few variables here we have one that is going to store the number of elephants we have you can declare it like this and not put in a value and if you do it like this the compiler is just going to put in some garbage value that is really not meaningful for your program so you see the warning we have here as a comment the variable may contain random garbage value and this is something you need to be aware of another way we can define integers in our c plus plus program is this statement here that declares a variable called lion count it's going to initialize to zero if we use curly braces like this it's going to initialize to 0 by default we can also explicitly put in a value we can do the same with cat count and we can use these variables to do operations for example we can declare another variable and it is going to store the number of domesticated animals and we're going to add up the numbers for dogs and cats and we're going to store the result of that in our variable that is called domesticated animals this is something you can do another thing that can be problematic is trying to use variables that you haven't defined or declared in your program that is going to give you a compiler error and the compiler is basically going to say i don't know what doesn't exist one here is i don't know what this doesn't exist to is it is not defined anywhere in the program another thing you can do is try and store a fractional number in a variable that you declared as an integer and this is going to give you a warning because fractional numbers are usually bigger in size than integers and this is going to lose some of your data we don't really have enough", "12295.52 - 12595.278999999999": "going to understand this a little bit later in the course but this is something you can do you can take a fractional number and store that in an integer variable and we're going to do an example and see how this behaves with our compiler that is gcc10 okay here we have mostly used curly braces to initialize our variables but we can also use parenthesis and this is going to be usually referred to as functional variable initialization because we are using parenthesis and this is mostly going to do the same thing we saw in the last slide with curly braces but when we come to the example here where we are storing a fractional number this is going to silently chop off the data you have in a fractional number and turn that into an integer and this is called implicit conversions but if we go to the last example here where we are storing 2.9 into an integer this is going to take this fractional number chop off the decimal point and only store 2 in this integer and this might not be what you want and it is going to happen silently so this is a really bad way to do this if you want to do something like this it is preferable to use curly braces because you are either going to get a warning that this is going to lose you data or you're going to get a compiler error and the compiler is going to completely stop you from doing this and again if any of this doesn't make any sense we're going to go in visual studio code play with us and see how the compiler behaves with these things we have another way we can initialize our variables in surplus plus we can use assignment and we have done this a couple of times in the course but this is something you can do and we are going to play with this in visual studio code in a minute and you're going to see how it works okay by now we have seen three ways we can initialize our integer variables we can use breast initialization which is basically using curly braces we can use functional notation which is using the parenthesis and we can use the assignment initialization which is what we have here another thing i really want you to see is that it is possible to query for the size of your variable here we are trying to print the size an integer is going to take on our operating system and compiler and if we try to run this on our compiler it's going to tell us exactly how much memory an integer occupies in our program we can either pass and explicitly like this or we can pass a variable name and it is going to work equally well okay ants are mostly going to take up four bytes in new memory so here we have a representation of three ants in memory if we go from this zero to this zero this is going to be exactly four bytes and this is how it may look in memory one other thing i haven't really talked about on purpose is that there are a few rules you have to follow to name your variables in c plus plus one of those rules is that a variable must start with a letter like a b c d up to z or an underscore you can't start a variable for example with a number that's going to be a problem after the first character in your variable name you can really put in anything you can put in numbers you can put in letters you can really put anything you want but the first one can't be a number variable names are also case sensitive so if you have a variable called bike account with the lowercase b and you have another one that starts with uppercase b these are going to be two different variables and uh you have to be aware of this no spaces or spatial characters are allowed in your variables you can use underscores but you can't use something like plus because that's going to be confusing to your compiler and these are a few rules you really need to be aware of and you're mostly going to be fine the general form for declaring and initializing your variable is what you see here you're going to pass the type in this case we have used and because we are learning about ants you're going to pass the variable name and you're going to put whatever it is you are initializing your variable with of course this is braced initialization because it is using curly braces but you can also use functional initialization or assignment initialization and it is going to work equally well okay now we have enough information to go in visual studio code and play with us okay here i am in my folder for the projects of this chapter i am going to hop over in my template project and copy the files that i need i am going to go up again and go on the project that is called integer types", "12595.278999999999 - 12895.199999999999": "files and i am going to open up this folder in visual studio code i am going to close the welcome screen here and open my main cpp file and i am going to do the usual take out the things we don't need to save on time i am going to put in a piece of code that i have lying on my drive and we're going to go through it to save on typing time i don't want you to suffer watching me type this the first thing we have is the elephant count this is a variable that is not initialized so this is going to contain garbage data it's not going to contain anything that is useful to us but some compilers are going to usefully put in a zero because that's a logical number to put in here if you didn't explicitly put a number in here the second one is using curly braces and this is going to automatically initialize to zero the third one is going to be explicitly initialized with the 10 and the cat count is going to be initialized with 15. you can try and print this out and see what you come up with after compiling this application another thing we have seen is that we can do something like this and put an expression into our curly braces and the value this evaluates to is going to initialize this domesticated animals variable and now you should know that this is probably going to take 4 bytes in memory because it is an integer this is really how c plus plus works each fundamental type has a size associated to it most times so integers is mostly going to be four bytes on your system and we're going to query this a little later in this video okay let's try and compile this program and see if it actually works we're going to start world and you see that the world is successful another thing we can do is try and use variables we haven't really declared in our program and you can guess what is going to happen if we try to do and new number for example and putin doesn't exist you know it's a number that doesn't exist the compiler is not going to know what this is because we didn't declare a variable called doesn't exist if you try to compile this you're going to get a problem you see that we have a problem before we even compile so visual studio code is this smart it can analyze our code before we compile it and give us hints to problems that might come up you see here it is saying doesn't exist isn't defined so if we try to compile this we're going to get an error that we expect it's going to say doesn't exist doesn't really exist i don't know what that is so you shouldn't really do that you shouldn't try to use variables you haven't declared this is braced initialization we can also do functional initialization as we have seen okay another thing we can do is store a fractional number in an empty variable and we're going to see what this does we're going to try and compile this code you see we have a 2.9 we're trying to store this in an integer if we try to compile this let's try and use gcc let's clear this let's bring up a terminal and try to build this we're going to try and run our gcc compiler on this program it is going to say errol narrowing a conversion of 2.899 from double to integer c plus plus 20 isn't even going to allow this so this is a good thing because you might think that you have a 2.9 and some compilers are going to chop this off and store a 2 instead so this is one of the safe things about this way of doing thanks so i am going to comment this out because otherwise our program wouldn't compile now that we know how to use these things we can try to print the values in here okay i am going to put in a piece of code i have lying around on my drive i am going to remove these spaces inside because it is annoying let's do this and if we try and build this program it should compile successfully and if we run it we should see our numbers we're going to go in our terminal here and do der and we're going to run rooster and we're going to see elephant count is one because this is a garbage value so it could really be anything lion count should be zero dog account should be 10 cat count should be 15 it is what we have and a domesticated animal count is 25 because we have drug account and we add that to cat count and we're going to end up with 25. this is what we expect now that we know how to work with this we can also try and play with functional initialization before i put in my code i am going to comment all", "12895.199999999999 - 13196.239": "disturb us as we work with our functional initialization code so i am going to comment all this out and go all the way down and put in my code for functional initialization and you see here we have a variable called ethel we initialize this to 5 we have orange count which is 10 we have fruit count and we have a bad initialization that is not going to work it doesn't exist 3 and doesn't exist 4 don't really exist so so this is going to give us a compiler error and if we do something like we do in narrowing the conversion function here this is mostly going to compile and this is going to chop off data and store a 2 instead of the 2.9 this is something you should really be aware of and you see the comment here says information lost this is less safe than braced initializer because breast initializer is going to give you a compiler error if you try to do this and that's a good thing so we also try and print these out so i am going to tidy this up a little bit and i am going to try and compile this piece of code run task and world with gcc the world is going to pass through without a problem and if we do clear and run rooster we're going to see apple count is 5 which is what we have in here orange count is going to be 10 so this is right fruit count is going to be 15 because it is 5 plus 10 and what is really worrying is that narrowing conversion is 2 but we didn't store in a 2 we started in a 2.9 and because an integer can really store 4 bytes 2.9 is more than 4 bytes and it is going to store what it can and it is going to chop off this 2.9 and only store in a 2 so this is really something you should be aware of sometimes this is going to cause problems in your program and really really if you are trying to store fractional numbers in an integer please use a braced initialization form because the compiler is going to stop you from doing this if you try okay so this is really the difference between functional notation and breast initializer notation functional notation is not going to give you an arrow if you try to store something that can't really fit in a net it is going to silently chop it off and put in whatever it can and braced initializer is going to give you a compiler error so this is the difference between these two okay i am going to comment this out as well and i am going to put the starting comment here and i am going to go down and show you that you can do assignment initialization as well i am going to put in my code here because i don't want to type it really and i am going to print all this out and we have a bike account variable that we initialize using the assignment notation track count is going to be seven fake account is going to be bike account plus track count and we're going to be narrowing conversion here and we're going to see if this actually works we're going to try and weld this we're going to run the task to world with gcc it is going to pass through you can guess what we're going to see if we run the program bike account is 2 track count is 7 which is what we expect vehicle count is nine and uh the narrowing conversion is also chopping off what we have here so this is something you need to be careful about another thing i want you to see is that you can check the size of your variables in memory so we're going to check the size with size of and i am going to put in a piece of code to really play with this i don't want to type all this because it's really self-explanatory by now we're going to print sites of ant and inside we're going to say size of ant and this is going to give us how much memory is really occupied by an end and we can use this form here by passing in a variable name track count is a variable we have declared and initialized here so if we build this program let's do that with gcc the build is going to pass through and if we run rooster we're going to see that the size of int is four you're going to see that this is in bytes and size of track count is for as well because track account is also an integer so these are all little tools you can really use to know how much memory is really being used and occupied by your program and this is really all we set up to do in this lecture to learn as much as we can", "13196.239 - 13495.76": "in memory for the most part and we have seen different ways we can initialize our integer variables we can use breast initializers which is going to use curly braces we can do functional initialization using parentheses like this we can also do assignment notation using the from like this and we can use size of to check the size of our integer variables i have to say that these kinds of initialization also work on other variables but we took the chance to introduce all these concepts using integers this is really all we set out to do in this lecture i hope you found it interesting we are going to stop here in this lecture the next one we're going to start and learn about integer modifiers go ahead and finish up here and meet me there in this lecture we're going to learn about integer modifiers and these are little things you can sprinkle around your integer types to modify their behavior a little bit but before we dive deep into this let's talk about how we can store positive or negative numbers in integers and we can do something like this if we put a tan inside our value 1 variable which is an integer it's going to work we can also put in a negative number like minus 300 and it is going to work so what's the magic here well this is signed by default and this is a modifier we can apply to our variable to signal that we have the possibility to store in negative or positive numbers and it is going to work if you only want to store positive numbers in your end variables you can use another modifier called unsigned and if you put in a negative number you're going to get a compiler error we're going to see how this works in a minute okay regardless of whether your integer variables are unsigned or signed they are going to still occupy 4 bytes in memory so this is how it's going to look in memory and here is a simple formula we can use to come up with the range of values we can store in our int values if they are unsigned or signed if the number is inside you can use this unsigned range formula and plug in the number of bits you have in your data type if you are using a signed integer this is what you're going to use and here is a simple example for example if we have an unsigned and this is the range of values we can store we can basically go from 0 all the way to 4 billion if the number is signed the range is going to basically be divided into half the half is going to go on the left and store negative numbers and the other half is going to go to the right and store positive numbers and you can see that we can basically go from minus two billion to two billion if the number is signed okay by now we have seen two modifiers unsigned and designed but there are others for example you can flag your integer types as short or long what does this do well this is a table that i put together to try and come up with all the combinations you can come up with if you have a short variable it is going to be two bytes in memory this is the modification that this modifier does to your type if you have short and it's going to be two bytes if you have a signed short and it's going to be two bytes if you have unsigned shirt and it's going to be two bites you can see that the effect of short is really shortening the original size in memory for whatever type you applied this on this is really working on an editor even if we don't specify int here for example short short here it's going to implicitly be and that's why we have two bytes because it's basically an end that we have split into here in the second column we have ant which is going to be 4 bytes if it is assigned and it's going to be 4 bytes this is really the sizes you're going to come up with if you use these combinations of modifiers on your integer types one thing i really want you to be careful about is that these modifiers only work for integral types so they work for data types in which you can store decimal or whole numbers you can't use this on types in which you can store fractional numbers like 2.9 that's going to give you a compiler error now that you have an idea about this why don't we go in visual studio code and actually play with us okay here we are in our folder that contains our projects we're", "13495.76 - 13796.72": "from our template project and we're going to put those files in our integer modifiers project here let's open it up and paste in the files we're going to go up again and we're going to open this up in visual studio code the first thing i want to play with is storing positive and negative numbers in our integer types so we're going to say end value one and we're going to store in a 10 for example and we're going to do any value 2 and we're going to put in a minus 300. i think this is what we had you know a slide so we're going to keep this if you try to print this out so we're going to say value 1 and we're going to say value 2 and we're going to try and build this so we're going to open our terminal so that we can play with it right away and we're going to run the task to world with gcc the world is going to be successful if we run our program we're going to see that it's going to say value 1 is 10 and value 2 is -3 300 this is really cool we can store positive numbers and negative numbers in our end times and this is going to occupy 4 bytes in memory we can prove this by printing the size of value 1 and value 2. let's do that so we're going to say size of value 1 is size of value 1. we can also do it for value 2 size of value 2 and it's going to be size of value two std and yeah if we build this again we're going to run the test world with gcc and uh we run our application it's going to save four bytes so it doesn't really matter if we store in a positive number or a negative number it's going to be 4 bytes this is the point i want to make here another thing you can do is actually make it very clear that you have signed numbers in here and you can use the signed integer modifier here so this is going to give us the same result and if we try to both again run the task to build with gcc the world is going to be successful if we run the program we're going to get the same result so if you don't put aside or if you put it here it's going to be exactly the same thing another thing you can do is make it very clear that you want to store positive numbers in your variables we can do that by using the unsigned integer modifier so we're going to say unsigned and value three for example and we're going to put in a four this is going to be fine but if you do unsigned and value 4 and put in a minus 5 for example this is going to give you a compiler error because you save this is unsigned and this really means that you want to store in only positive numbers but you are trying to put in a negative number if you try to build this let's try this we're going to run the task to build with gcc we are going to get a compiler arrow saying conversion from -5 to ant this is not allowed you're going to get a compiler arrow your program is not going to compile so this is a compiler error let's say this here and this is really all i had to share about these signed and unsigned modifiers signed is going to mean that you can store negative and positive numbers unsigned is going to mean that you can only put in positive numbers and if you try to put in a negative number you're going to get a compiler error now that this is commented out if you try to run the test to world with gcc the world is going to be good and we will be able to run our program and it's going to do whatever it was doing before as we see here we also saw that we could use the short and long modifiers and we're going to put a piece of code here that is going to allow us to play with them so i don't want to type this and if you don't want to type this as well you can get this code from the resource section it's going to be left you can open the link use the code copy the code and paste it in here and really play with it because the point is really not to type all this the point is to understand what these modifiers do to your variables what we are going to do we're going to try to print them out and print the size they actually have in memory we're going to do this in four groups we're going to do one for short and long we're going to do one for ant here we're going to do one for long and we're going to do one for long long these are things you can do and we're going to see how much memory is actually being used by all these variables we are going to start with the first group here so we're going to go down and print the size is out and this may be really hard to wrap your brain around but they are plain old", "13796.72 - 14098.239": "doing all along i am going to split this on different lines so that you can really say this so we have an output statement for a short var which is what we have here so we expect this to take two bytes and all these things are probably going to take two bytes let's try and build the program with gcc the bullet is going to be successful we are going to run rooster and you're going to see that short end is two bytes signed short is two bytes and everything is basically two bytes in this group here and we did guess right the next thing we want to try out is this group of ants so we are going to go down and give ourselves some breathing room and we're going to paste this in and we're going to separate these again so that we can see what is really happening here and i think this is really enough so we're going to see the sizes for the thanks we have in this group here and we expect this to take four bytes so let's try and run the world task to build with gcc the world is going to be good we can run the program like we usually do and you're going to see that ant variable is 4 bytes and everything in that group is 4 bytes and this tells you that regardless of the side and unside modifiers you put here it's going to really use the size of it here okay it's going to take four bytes in memory let's try this group here we are going to go down and put in the code to print the sizes for them and this is what we should use let's split this on different lines so that it is easier on the eyes and again if you don't really want to type this you can get the code from the length resource section you're going to find the code here and you can copy and paste and really play with us but it is helpful to really type these things out and really bring these things in muscle memory because it's going to help okay so we have this and we're going to try and run the world task with gcc the build is good we're going to go in here and run rooster and it is going to say long variable is four bytes and everything in this group is basically going to be four bytes in here the last one is this long long thing it is going to really give you a huge range for your values you can store in the variable but don't really trust my world let's try this out so that you can see for yourself we are going to go down and really put this in so we're going to give ourselves some breathing room and paste the code in so i am going to bring this to the next line and what we are really doing is printing the sizes for the variables that we have in this group here let's build and see if this passes the world the world is going to be good now we can run rooster and we're going to see that long long is eight bytes eight bytes gives us a really huge range of values okay this is really all we set out to do in this lecture to learn about these integer modifiers they modify the way your integer variables behave for example we can specify that we only want positive numbers all that we want to both store positive and negative numbers for that you're going to use designed or unsigned modifiers you can also shorten or lengthen the range of values you can store in your variable by using the modifiers short and long and from the output of a program here you can really see all these effects here this is really all we set out to do in this lecture i hope you found it interesting we are going to stop here in this lecture in the next one we're going to start and learn about fractional numbers go ahead and finish up here and meet me there in this lecture we're going to learn about fractional numbers and as we work with these numbers i want you to keep in mind that any piece of data you work with in your c plus program is ultimately going to be stored in the form of ones and zeros in memory functional number are also called floating types in technical terms they are used to represent numbers with fractional parts in c plus plus and many other languages and we have three types that we can use in c plus plus we have float double and long double and the main difference is in the size they occupy in memory a float takes four bytes a double takes eight bytes and the long double takes 12 bytes typically so as the size goes up you can also notice that the precision goes up so what is the", "14098.239 - 14397.599999999999": "number of bits you can represent with that type starting from the number in front of the decimal point so if we look at this number here we can try and figure out its precision so we're going to count 1 2 3 4 5 6 7 8 9 10 11 12. the precision here is 12. if we go back to our table we're really not able to represent a number like this with a float the smallest thing we can use to represent this number well is a double because the precision is 15 and it is more than what we need for this number which is 12. one thing you should remember is that the number in front of the decimal point is also counted then when you are trying to figure out the precision for your floating point numbers in c plus plus so here we have an example of how we can declare and initialize floating point numbers in our c plus plus program number one is a really huge number so you can guess that this is more than we can handle with the float we're going to see how this is handled by our compiler a double has a precision of 15 so we should expect to store more numbers than we did in a float a long double should be able to handle this without a problem because if we go back to our table here our long double here should be able to handle this better than double but it is possible that it is the same thing as double depending on the compiler implementation and if we try to print out the sizes here we're going to see what the compiler gives us we're going to do this when we try this in visual studio code okay and here we are trying to print out the precision of these numbers we can use a special setting on our stream to control the maximum precision that we can see here you see that we are trying to show the precision for each number there is a special setting we can put on stdc out to make it control the precision to a given number here we are using 20 and we're going to see that for number one this is going to be seven digits for number two it should be 15 digits or something close to that the specifics are really dependent on the compiler implementation and for long double it should at least be the same as double or even more in some cases okay here we want to see that we can also have narrowing errors if we try to store something back in a float and a float can't really handle it here we have a number with a lot of digits one two three four five six seven eight nine and we know that the float can only handle seven digits so this is probably going to give us a compiler error as we've seen for breast initialization if we use functional initialization this problem is not going to be code at compile time so we're going to end up with a chunked piece of data and we're going to see this when we play with this with visual studio code and another format we can use with floating points is that we can use scientific notation and it is basically a way we can use a power of 10 multiplier to multiply with our floating point number so for example here number 5 is going to be this number 1 9 2 4 0 0 0 23 we can use a floating point scientific notation to represent this so what we're going to do we're going to say 1.9 and we're going to multiply this with 10 to the power of 8. this is what this means this 8 here means to multiply with 10 to the power of 8. and if we multiply with that that basically means moving the decimal point 8 digits to the right so we can go one two three four five six seven eight and it is going to end at these three here and it is going to be basically the same number number seven is also another one and if we do this we're going to pad with zeros after these four and we're going to end up at this same location as the three but it is going to be a zero we're going to see about that in a minute and number eight is another floating point number and we can use scientific notation to represent it just like you see with number nine we're basically going to have the same thing when we have a minus in here it means we're going to multiply with 10 to the power of minus 11 and this is going to give us a number below one thing zero point zero zero seven or something like that so we're going to go 11 digits", "14397.599999999999 - 14697.04": "two three four 5 6 7 8 9 10 11 and the decimal point is going to go after three and we're going to basically end up with the same thing here we're going to play with this in a minute and you're going to see that all this makes sense and don't forget that any piece of data we store in a computer is going to be ultimately represented by ones and zeros in memory and for floating points we don't use the number systems like we've done for integers there is a special system that is used to do that but it is a little bit complicated to cover in a course like this i am just going to point you to it if you are interested and when you are done with this course you can come up and read on this the main point is that any piece of data that you represent in your c plus plus program is going to be represented in terms of ones and zeros in the memory of your computer okay there are a few things you can do with floating points that you can't really do with integers for example you can divide with zero if you take a floating point number and divide that with zero you're going to get what we call infinity if the number is positive you're going to get positive infinity if the number is negative you're going to get negative infinity and you can take two floating point numbers that are zeros and divide them and what you're going to get really is not a number it's something called nan which stands for naughty number and uh your program is going to not crash but very few things you can't do with these things for example you can't add them up you shouldn't really do this it's probably going to end up bad for your program here we have a few examples we have three numbers declared they are doubles they must be occupying eight bytes in memory number 10 is initialized to 5.6 11 is initialized to zero because we are using the braced initialization and we have nothing in here and infinity here is the result of dividing a number by zero so it's going to be positive infinity because number 10 is a positive number if you go down we're going to print number 10 divided by number 11 and we're going to say yields we're going to put the result out we're going to see that down here on the second line you see that we are trying to add something to infinity and this is also going to yield infinity because think of infinity as something super big and if you add something small to something big it's still going to be something big down here you see that result equals number 11 divided by number 12 and these two are zeros so we're going to end up with none and that's what we're going to print in this statement here down to the bottom okay you should really remember to put in the suffixes when you are initializing your floating point numbers otherwise the default is going to be double this is what we mean by this you see this floating number we have a suffix that is f to mean that it is a floating number if you don't put that in this is going to be interpreted as double and the compiler is going to try and turn that into a float by chopping off things that can't really fit in a float so to really make it clear that you are stirring in and loading number please put this f suffix here for double you don't need to put anything because it is the default assumed by the compiler but for a long double you have to suffix this with l just like this so that's what we really mean here we have seen that the precision for float isn't really enough for many of the computations we might want to do in our c plus plus applications okay we have talked a lot about floating point numbers let's head to visual studio code and actually play with them okay here we are in our folder that is going to contain our project the project is going to be called fractional numbers so we're going to copy our files go up a little bit and put those in and i'm going to go up again and open this in visual studio code we're going to close whatever it is we have opened now we're going to close folder and we're going to open our project in visual studio code and we're going to do the usual and remove things we don't need in here the first thing we want to do is to store a few floats in our program we're going to declare and initialize a few floating point numbers we have number one number two and number three and we want to make it clear that the sizes are what we expect we are going to open a terminal window here and we're going to build with gcc run the task to weld with gcc the world is going to be successful we're going to come to our terminal click a little bit and we're going to type dir we're going to see that a program is in place if we run it we are going to see that size of float is 4 size of double is eight and size of long double is 16. this is what", "14697.04 - 14996.8": "try and play with the precision of these numbers and see what we can really go away with okay so we're going to actually put in a piece of code to play with this we're going to add a setting to our sddc out stream so that we can control the precision but for this to work we need to bring in a library that is called i o manip so we're going to include that i o manip and how do i know this i usually consult the c plus plus standard library documentation and you are not at the point where you can really understand it right now so we're going to be putting in these things here and explaining them as we go and i made the type here it is io manip and you see that now this is recognized our program should compile so we're going to try and weld it so that we can try this out we're going to build with gcc the world is going to go through we can run our program we're going to do dur and clear and rooster to run you see that things start to go off at sex and if we count what we have here it is one two three four five six seven we can only represent seven numbers accurately with a float and after that we're just going to have garbage because the computer can't really make sense of whatever we have after our seven digits that we can legally represent with the flood so the precision for our floating point number here is seven i really hope this makes sense let's check out number two we are using double so precision should be around something like 15. so we are putting in a number one through nine and we are starting over zero one two three four five up to zero again if we look at what we have in the output here we have one two three four five six seven eight nine zero one two three four five six and here things start falling off after our sixth year and if we count we're going to have 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 digits this is the precision we are having this compiler for double 17 so it is something around 15 and we should expect to have something more than that or at least the same thing as double with long double so if we look at this you see that it is one two three four five six seven eight nine zero one two three four five six seven eight nine we are able to represent up to 20 and you can see that long double leaves up to even the precision of 20 that we have set with std set precision here okay i really hope now that you have an idea about these precisions we have with our floating point types in c plus plus programs another thing i want you to see is what kind of narrowing errors we can get if we try to initialize with something that can't really be represented by a floating point number and here we have a float it is called number four and we are trying to put in something that is bigger than we can really fit in it has more than seven digits so one two three four five six seven eight nine it is more than seven digits and we would expect to have a problem with this because we are using braced initialization let's try and build this with gcc we're going to do that and this is going to work successfully so this is going to silently chop off our number if we try to print it out we're going to say sddc out number four and we're going to world again run the test tube world so that our changes are taken into effect i'm going to do dur and do rooster and this is going to print our number you're going to see that after the zeros we have junk our number has been basically chopped off and this is junk because we can't really represent this with the double the 16 here has been chopped off because we can't basically represent this with the floating point number if we change this to double this is going to probably give us what we expect so let's run again world with gcc the world is going to be good if we run the program it is going to show us the same thing okay this is a really good learning change why are we having the same results as before even if we changed the type to double try to think about it the reason is the suffix here is still saying f and this is going to be stored as float in memory so if we want this to really be treated like a double we can take out the float here and if we build again and run the application now you're going to see that we see the 23 this is basically being correctly stored as a double this is a", "14996.8 - 15295.92": "mind if you don't put in your suffixes here the number is going to be interpreted as double by now i hope you see that if you really try to put more than your floating point can handle the number is going to be chopped off and only the precision that it can handle is going to be stored in i hope this makes sense and you see that the behavior for numbers is really different we got the compiler error when we try to do narrowing conversion with integers but now it is silently chopping off our number if we try and use functional notation i think we're going to get the same result and change this back to a float and uh use float here and if we both again let's go to terminal run task use gcc we're going to run this let's run rooster and you see that we get the same results our 23 is chopped off here we can also use the assignment notation here just like we did with integers and this is going to do exactly the same thing it is going to chop off the 23 here and we're going to have some garbage which is 16 in this case if we weld the gun the world is going to go through and if we run we're going to see as it's in here okay narrowing conversions are something you should be aware of when storing your floating point numbers and you should really remember to put in your suffixes here and other thing we have seen that we should really play with is scientific notation as the comment here says what we have seen so far in floating point numbers is fixed notation it is what we have here but we can also use scientific notation which is exactly what we described in the slides and what we have here for example is e8 and it means that we are going to multiply this number here with 10 to the power of 8. if you go down here we have number 9 so we have 3.498 and we have e minus 11 and what this is going to do is multiply with 10 to the power of minus 11. this is how i can represent this here and we can print these numbers out to really play with them to make a difference with what we have been doing before we're going to do sddc out and put a dividing line here this is one way we can do this so we're going to do stdndl we're going to weld this so we're going to run the attached world with gcc 10 the world is going to go through if we do rooster we're going to see that our number here number five is what we expect number six is the same thing but we used scientific notation to do this because we took this number and multiplied by 10 to the power of eight number seven should be almost the same thing but the lower 23 here is going to be chopped off because we haven't specified it we're just multiplying with 10 to the power of 8 so that's why we have 0 0 here i hope that makes sense and if you look at number 8 you see that we stored it like this without using scientific notation we used fixed notation but on the terminal it's going to be printed out in scientific notation and this may be pretty cool the main usage for scientific notation is to make sense of numbers that are really huge so the way you interpret this you're going to move these numbers after the decimal points with 0 in front and it's basically going to be like this so if you count the zeros you have here we're going to have 1 2 3 4 5 6 7 8 9 10 and 11 is going to be directly after three and you're going to get the number here this is what we mean and number nine was explicitly stored in using scientific notation and you see that we have the same thing you can play with these things and really make sense of them and again we didn't specify any suffix here so these are going to be interpreted as doubles but this is not a problem because they are doubles here okay we are making some progress with this lecture which is a little lengthy the last thing we want to do is to play with infinity and nan we're going to put a message here to say what we want to do and we're going to have number 10 which is going to be positive we're going to have number 11 which is going to be zero number 12 is also going to be zero if we take 10 and divide that with 11 we're going to get infinity because we are dividing a floating number with zero if we try to print that out we're going to get infinity and we're going to get infinity for this result here because we are trying to add something small to infinity which is something really big and if we all trying to divide zero with zero in floating point we're going to get what is called", "15295.92 - 15596.8": "we're going to see this in a minute let's build this with gcc we're going to weld successfully let's clear this out so that we don't have noise in here and we're going to run rooster and you see here it says infinity and none which is what we said here and if we go down here it is saying number 10 divided by number 11 and number 11 is zero you see that here it's going to yield infinity if we add five to infinity we're going to get infinity and if we try to divide a zero by a zero we're going to get none which is really a way to tell you that you're doing something wrong you should really be careful one other thing i want you to see is that if you turn this five into a minus five and build again we're going to build with gcc and we're going to run this rooster we're going to get minus infinity so if you divide a positive number with zero you're going to get positive infinity and if you divide a negative number with infinity you're going to get negative infinity and this is what we see here this is really all we set out to do in this lecture i hope you found it interesting and again the big message is that any data type you're going to be handling in your c plus plus program is going to ultimately be stored as ones and zeros in memory and we have learned about floating point numbers float double and long and they have these properties you see here and you should use them with this in mind otherwise you're going to have problems with your precision make sure you are using the correct precision that you need in your program we are going to stop here in this lecture the next one we're going to try and learn about booleans go ahead and finish up here and meet me there in this lecture we're going to learn about booleans booleans are types that can store two states in c plus plots it can store either true or false and we can use this to really do decisions in our program if you look in the program we have here we have two variables declared the data type is bull and one is called red light the other is called green light and we have true and false inside one thing we can do in c plus plus is make decisions we can say if the red light is true we can print a message that says stop and if it's not red we can print a message that says go through we can do that and booleans are really used in this way to make decisions in your c plus plus program we haven't really learned about if statements in this course but i am throwing this in here to really drive the point home that we can use this to make decisions in our program down here we have another way we can do this we can actually use the variable itself without checking if it is equal to true or false and we are going to get the same message the point here is that if green light is true we're going to say the light is green if it's not we're going to say the light is not green you can do something like this and again the big point here is that booleans data types are used to store two states true or false in your c plus plus program okay by default if you print a boolean that has two in it you're going to get true and this is what you see here and if you print one that has zero in it you're going to get false we can change that with a special setting that we can apply to our std out stream and you do that like this with std bull alpha and we're going to play with this in a minute you're going to see if we try to print with this setting applied we're going to see true on false and not c 0 and 1 like we did before we're going to play with this in a minute and you're going to see another thing you should know is that booleans occupy 8 bits in memory they take up an entire bite so you may think that this is wasteful and it is but with the amount of memory that we have today this is really not a big problem but if you are working on a device where memory is really a problem there are techniques you can use to pack even more data in a byte and we're going to learn about that later in the course okay so this is really all i have to say about booleans we're going to go to visual studio code and play with them in code okay here i am in the folder for my project here i am going to do the usual and copy the files over and i am going to go in my project on booleans i am going to go up and open this up in visual studio code i am going to close the current folder open the new one and browse to my project this is going to open up in visual studio code and i am going to close the welcome screen here i don't need it anymore so i'm going to remove what i don't need and we are going to play with the exact code that we had in the slides we're going to declare two variables one is", "15596.8 - 15896.08": "to be green light they are going to be booleans and in red light we're going to store a true and story false in green light and we can make a decision like this so try to guess what we're going to plant in this program we're going to try and decide and say if the red light is true we're going to print stop if it's not true we're going to fall in this block here and say go through if we look at our program in red light we have a true so this should really win and we should get in this block here i hope this makes sense so let's try and build this program to see that it actually works so we're going to build with the gcc we're going to run our program and our terminal just went away we're going to create a new one no big deal and uh if we do dir we're going to see rooster.exe we run it it's going to say stop okay so in red light we have true the test is going to succeed here and we're going to fall in this block and say stop i hope this makes sense you can try to store a false in here and both again going to world with gcc if we run this program now it's going to say go through because red light is not true anymore this is really what we mean when we say that we can make decisions based on booleans in our c plus plus code we can also try another example we're going to say if green light is true we're going to say the light is green if it's not we're going to say the light is not green and this is another form we can use instead of typing the entire thing comparing red light to true here and again we're going to learn about all these comparisons here it is just because i thought that talking about bulls without showing tests like this is really not going to drive the point home for you so try to understand this as simple tests you can do in math if one value is true i am going to do something if it's not true i'm going to do something else this is what we are doing here okay this program here is going to check if the green light is true so we're going to look here green light is not true so we should fall here and print this message that the light is not green let's build the program the world is going to go through we're going to run this and you're going to see go through and the light is not green this is what we have here another thing we can actually try to see is the amount of memory that a boolean takes up so we can use sizeof to do that we have seen this before if we build with gcc we're going to go through and we can run our program to actually this message and you're going to see that bull is actually going to take up one byte in memory this is what we saw in the slides another thing that can be really confusing is printing out boolean values for example here we are trying to print great light and green light let's go up and actually change them a little bit for example take green light here and make it true and we're going to go down again and here we are trying to print them out red light is going to print whatever value we have stored then and green light is going to store whatever value we have stored in and again true is going to be printed out as one and false is going to be printed out as a zero let's try and build this we're going to build with our gcc compiler the world is going to be good we're going to run this and you're going to see that red light is zero because we have a full sun here and green light is going to be one because we haven't a true here if you try to print out boolean variables you're going to get one and zero by default if you really want to see true and false there is a special setting you can apply to htdc out and you do that by saying stdc out std bull alpha and you do it like this and if you try to print again we are going to get true and false right now okay let's try and print again and we're going to work this with gcc and we're going to run this and now you see that we see red light is false green light is true this is really all i had to share about booleans in this lecture i really hope it drives the point home that booleans are mostly used in making decisions in your program and that's what you're going to be mostly using them for and another thing is that they take up one bite in your memory we are going to stop here in this lecture the next one we're going to try and learn about characters and text go ahead and finish up here and meet me there in this lecture we're going to", "15896.08 - 16196.159": "use a data type called car in c plus plus to represent characters and this is basically how you use it you store in characters like abc and here you see that we have a r r o w and you put your characters in single quotes like this to mean that they are characters if you don't do that you're going to get a compiler error after you have your characters declared and defined like this you can print them out with stdc out and we're going to see them on the terminal car occupies one byte in memory so it's going to take up eight bits okay so one thing we can do is map each value in these 256 possible values to a character and we can do something like this for example we can say that 33 represents the exclamation mark 48 represents the character 0 49 represents the character 1 50 represents the character 2 and we can keep going up and say for example 70 represents f 71 represents g or 112 represents p you can really use a mapping like this and come up with representations of your characters in memory and this is what we do you can learn about this encoding and on the link here this is a real thing and it is called the ascii encoding that takes characters and stores them in one byte and the data type to store these characters in c plus plus is car if this doesn't make sense please bear with me we're going to play with this in visual studio code and it is most probably going to make sense okay it is possible to assign a valid ascii code to a car variable and the corresponding character will be stored in that piece of memory so once you have that you can choose to interpret that either as a character or as a number that is something like an integer this is what we really mean if we declare a variable called value which is of car type 65 is going to be stored in memory but the c plus plus program is going to interpret this as a character if we go back to our table and see what is represented by 65 this is what we're going to find we're going to find that 65 represents a and if we print this out by default it's going to print a it's not going to print 65 but there is a way you can take this character value and turn that into an integer and print it out and you see that here we are saying value and and we are saying static cast and and in the parents we have a value this is basically a way to say we wanted to take the value and interpret that as an integer and we're going to learn a little more about static cast later in the course but it is basically a way to transform between data types and in this case we are trying to transform from car to end and we're going to print this out okay what we just described is the ascii encoding a technique by which we can map the first 128 numbers in a byte two characters and use that to represent characters this technique doesn't work well if you have languages like arabic japanese and chinese because they are completely different beasts there are better ways to represent characters in your c plus program and that's usually unicode but that's really out of scope for a course like this so i'm not going to describe that anymore okay this is really all we need to learn about characters we're going to head to visual studio code and play with them okay here i am in my working folder i am going to go in my template project i am going to copy things over i am going to put that in my characters and text project and i am going to go up and open this up in visual studio code we're going to close the welcome screen here we're going to open up main cpp and we're going to put in the code to play with characters and text the first thing we can do is declare characters like this we can put in a r r o w here and we're going to see this printed out if we run this program we are going to put in some code to play with characters we have a few variables declared that are of car type we go from character 1 through character 5 and these are the characters we are storing and this is and this is the format you're really going to use to declare your characters after we have them declared we can print them out like we print any other variable and we can try and compile this program and see what we're going to get but before we do that i would invite you to try and guess so let's open our terminal and we're going to build with our gcc task we're going to world the build is going to go through and if we run", "16196.159 - 16495.68": "printing out a r o w we are storing our characters and and we are able to print them out this is really how you work with these guys another thing i want you to see is the size that a character occupies in memory by that i mean card type it's going to occupy one byte in memory and that means that we can only have 256 different values that go between 0 and 255 if we have decided to store in positive numbers we are using the knowledge we learned from the integers lecture if these calculations we are doing here don't make sense please go back and check that out so down here we are declaring a character type the name is value and we are putting in a 65. the thing is if you try to print this value here it's not going to print 65 it's going to print a which is a character representation of 65. if you remember from our ascii table we had these mappings between characters and integers and 65 mapped to the character a upper case so if we print this out this is going to give us a but we have the option to interpret this as a number and we can pass this through a static cast and it is going to take a value turn this into an integer and we're going to be printing this integer on the console and we're going to see it we're going to try this out so we're going to run the task to build with gcc the build is going to go through we're going to run rooster and you're going to see that value is a for the first line here and the value and is 65 because we decided to interpret whatever is in this value as an integer and not as a character as it is done by default this is really all we set out to do in this lecture i hope you found it interesting we are going to stop here in this lecture in the next one we're going to try and learn about the auto key world in c plus plus go ahead and finish up here and meet me there in this lecture we're going to learn about the auto keyword in c plus plus this is a keyword that is going to let the compiler deduce the type for you and this is going to come in handy when you have longer type names that are really hard to type we can't really give you an example of that because that requires to have a good number of concepts mastered in clause plus but we are measuring this here for completeness because we are talking about variables and data types so let's hear how we can use this here we have an example where we are saying autovar one and what we initialize this with is an integer so the compiler is really going to try and guess the type of this thing and that's the type it's going to assign to variable one this is what ocho is really used for if we pass a double inside and it is a double because we have no suffix here so it is going to deduce a double if we pass a suffix of f it is going to interpret this as a fluid if we pass l it is going to interpret this as long double and if we pass in a character it's going to interpret this as a character and this is really the essence of what auto is used for it is used when you don't really want to explicitly type the type of your variable and you want the compiler to fill in that for you or it gets it for you down here you see that we have a few examples with integers so we can make this unsigned lung through this suffixes and the compiler is going to deduce the type based on what we pass in our initializer here down here you see that we have a few examples with integers if we pass a suffix of u this means that we are storing an an unsigned integer so that's what the compiler is going to deduce if we pass ul it is going to be unsigned long if we pass in ll this is going to be long long and that's what the compiler is going to deduce here you see that we are trying to print the sizes of these variables and we trying to prove to ourselves that the compiler deduced the right type and we are going to go to visual studio code and actually try this out okay here i am in my working folder i am going to open my template project i'm going to copy that and i'm going to save my files in the auto project here so i am going to go in and put in my files i'm going to go up again and i am going to close whatever it is i have in visual studio code because we're going", "16495.68 - 16795.12": "open my new folder we're going to close the welcome screen here and we're going to remove whatever it is we don't need for this project and we are going to put in the code we basically had in the slides i am pasting this code in to save on some time because i don't want you to see me type these things we're going to save some seconds here so the first statement here declares a variable var1 the type we don't really know but we're going to let the compiler deduce that for us and we can try and actually hover over this and we're going to see that the compiler already deduced that this is an integer if we go to vira 2 this is a double if we go to var3 you see it's a float if you go to var4 it's long double if you go to wire 5 it's a character you can see that visual studio code can even see what the compiler is going to deduce before we even compile the code this is the beauty of visual studio code we're going to look at virus 6 you're going to see that it's going to be unsigned and if we go to var 7 it's going to be unsigned long if we go to var 8 it's going to be long long this is really cool and you can see that our types are correctly deduced visuals video code was really helpful in showing us these types but we want to be sure by running this piece of code and seeing whatever size the deduced type is for example for var1 we guessed that it's going to deduce an end so it better be a four in size we're going to try and run this we're going to open our terminal here and we're going to go to terminal and run task we're going to build with gcc and by the way if you want you can build with the compiler from microsoft by coming to terminal here and choose it with world with msvc but gcc is my favorite compiler and i am going to use it if i can so we're going to hit enter and enter we're going to see that our rooster.exe file is in place if we run it we're going to see our sizes so var one occupies four bytes in memory var2 occupies for eight bytes in memory because it is double fire 3 occupies 3 bytes because it is a float var4 occupies 16 bytes because it is a long double and var 5 better occupy 1 byte because it is a character and we see the same data for vera 6 virus 7 and var 8 and this proves that the auto keyword is really doing its job it is deducing the types for our variables without us explicitly specifying the variable type we didn't have to do something like and or double or whatever we can let the compiler do that for us and this will come in handy many times this is really all we set out to do in this lecture and i hope you found it interesting in the next one we're going to look at how we can do assignments and assign data to our variables in a unified way go ahead and finish up here and we'd be there in this lecture we're going to learn about assignments and the basic idea i really want to drive home here is that after a variable is initialized like we've been doing all along you can later assign a new value to it for example here we have our one declared it is an integer we can print it out and it is going to print one two three but later in the program we can put in another value for example here we are putting in a 55 and if we print var1 it's going to be 55 this time the same idea can be extended to doubles you see here we are doing the same thing booleans we are doing the same thing here the state is declared force and we are printing that and after we are changing this to a true value and if we print that it's going to be true one thing you really need to be careful about is if you are doing auto type deduction the type is not very apparent by looking at the declaration of the variable here for example here by looking at o2 var 3 we don't really know what that is and it is very easy to try and put in a value that is illegal for example here we have deduced an unsigned integer which is only going to store positive numbers but we are putting in a minus 22 and this is going to be a disaster we're going to get a compiler error and this is going to be bad so be careful when you are doing a type deduction in your assignments that you do to your variables this is really all we have to share in this lecture let's hop over to visual studio and show you this in action okay here i am in my working folder the project we're going", "16795.12 - 17096.877999999997": "assignments i am going to grab my template files and put that in this folder here and i am going to open this up in visual studio code so let's close whatever it is we have now and open the folder and we're going to close the welcome screen here we don't want it and remove whatever we don't want from this file here the first thing we want to do is put in the code for our integer variable var1 and show you that you can assign a new value to it after it was initialized and if we run this code we're going to see var1 to b123 and the second statement is going to say var1 equals 55. that's what we're going to see let's bring up our terminal and we are going to run the task to build with gcc and if we hop over here in the terminal and do dir we're going to see that our rooster.exe file is in here if we run it we're going to see var one one two three var 155 exactly what we expect we have stored in a one two three at initialization using braced initialization here but after later on in our program we have decided to put a different value in this variable here essentially reusing it to store something else this is the basic idea here we can do the same things with doubles but before we do that let's put in a separation line so that we can see these vents clearly in the terminal and we're going to go down and put in our code for a double so we have a double variable called var2 initially it has 44.50 in and then we're going to assign a new value to it and that's going to be 99.99 if we print that out we're going to see that let's work and see this in action we're going to build with gcc if we run the program now it's going to save r1 is one two three four one fifty five but we're also going to see that viral two starts out 44.55 but after we put in the 99.99 it's going to show up here okay let's put in another separation line because we're going to need that in a minute we can do the same things with booleans here we are using this as just an example but this same concept essentially extends to any other kind of variable you're going to have in your c plus plus code if you initialize it with some value you have the option to change that value later on in your program by assigning that value to that variable essentially what we are doing here the variable state which is a bull was initialized to false we're going to print that out and notice that we have this setting to allow us to see true or false instead of ones and zeros we have seen this in a few lectures back and later on we are assigning true to this state and we are printing that so if we print these things out we're going to see false and true for the state here so let's build we're going to use gcc and the world is good if we run the program we're going to see false and true and it is exactly what we expect again you really need to be careful when you are using auto type deduction because you might have some serious problems if you are not paying attention let's put in the code so that we can play with it here we have a variable called var 3 and the type of it is not specified explicitly we are letting the compiler deduce this and because our initializer here is an unsigned integer the compiler is going to deduce that it is an unsigned integer the problem will come if you try to store in a negative number the compiler is not going to give you a compiler arrow it is going to silently put in some garbage value that we don't really want in there we want a minus 22 and you can see that this is what the compiler is turning our value into we want a minus 22 in this for three but if you hover over this minus sign here in visual studio code you're going to see that the value that we have in is not what we put in we put in a minus 22 and we are getting a really large number close to 4 billion so this is really something that can go silently wrong in your code and you're going to have a hard time trying to figure out why your code is not doing whatever it is you want so be careful about this let's try and weld this so we're going to build with gcc the world is going to be good you're going to see that we're not even going", "17096.877999999997 - 17397.68": "and we're going to see that viral 3 is exactly what visual studio could guess and it is not good it is this value here and the problem is that the compiler is silently putting in a garbage value and not what we want here because virus 3 is basically not capable of storing negative numbers so the compiler is going to do its best and put in a garbage value and this is not what you want and you need to be aware of this this is really all we set out to do in this lecture i hope you know about assignments and be careful when you are doing assignments on variables whose types are deduced with auto and we're going to stop here in this lecture in the next one we're going to try and recap what we saw in this chapter go ahead and finish up here and meet me there in this lecture we're going to recap what we saw in this chapter and this chapter was really all about variables and data types we had a chance to look at different types that we can use in c plus plus we saw that we have fundamental types we can use to represent integers floating points booleans and we also saw that we can do type deduction with auto we had a chance to make it clear that data is represented in memory as zeros and ones and that there are some kinds of transformations we do on these pieces of data to turn them into a form that is easily usable and manipulable by humans and we saw that for integral types or integers we could do that through number systems and we had a chance to look at a few number systems like binary octal and hexadecimal and we had a chance to play with all these variable types in visual studio code and see the nuances of how you really work with them i would like to welcome you in this new chapter and this one we're going to be looking at operations we can do on our data and there is a bunch of them we can add things up we can subtract numbers we can divide numbers we're going to see all kinds of crazy operations we can do on the data all the variables that we have in our c plus plus program we are also going to have a chance to look at how we can format stuff when we print them out to stdc out and we are going to be using some utilities from the c plus plus standard library to do some operations on our variables this is going to be a fun chapter i can't wait to get started let's go in the next lecture and start doing this in this lecture we're going to be looking at some basic operations you can do on the data in your c plus plus program and we are going to be specifically looking at addition subtraction dividing numbers the modulus operator and multiplying stuff we have seen addition before here we have a simple example we have a variable called sum and we are initializing it with two numbers that we are adding up number one and number two this is something you can do in your c plus bus program you can also do some other things for example we have another one called other sum and we are adding up some other numbers and we are going to collect the result into this other sum variable and we're going to print these things out so that you can see them on your command prompt this is how you can do addition and we're going to have a chance to play with this in visual studio code in a minute we can also do subtraction we can take a number and do minus another number like we are doing here we're going to store the results in this div variable and we can do some other things and down here you see another example in other diff here we're going to subtract numbers and store the result in other def and we are also going to print this out you can also multiply stuff this is how you can do this you use this operator here it is the star operator and this is an operator that many programming languages use to do multiplication you should get familiar with this and again we print out the result so that you can see that this is actually working we can also do division division for integers is a little tricky if you are seeing this for the first time if we take for example 31 and divide that by 10 we're not going to get fractional numbers c plus plus is going to try and figure out how many times it can fit 10 in 31 and we are visualizing this here so in 31 we can only fit 10 three times so the result of 31 is going to be three this is the meaning here okay with integer division you're not going to be getting fractional numbers this is something you should really", "17397.68 - 17695.84": "is called modulus operator and this operator is represented by this percentage symbol that we are doing here and the result of this operation here is going to be what remains after you have done the division of 31 and 10. and here the result is going to be one and you might be wondering why this is useful it is going to be useful in many applications and i think we're going to have a chance to play with this later in the course but right now you just need to be aware of this operation and what it does okay these are the operations we're going to be learning about and playing with in this lecture let's head to visual studio code and actually play with this okay here we are in our working folder for this chapter you see that i have prepared all the lectures we're going to do in this chapter and i have my c plus 20 template project in place i am going to do what we have been doing all along so i am going to take these files and put them in the current lecture which is basic operations and i am going to paste those in and i am going to open this folder in visual studio code so let's do that pretty quick we are going to close the welcome screen here and we are going to open our main cpp file and we are going to remove things we don't need here the first thing we want to play with is addition so we're going to say that and we're going to declare two end variables we're going to call this number one and we're going to put in a two for example and we're going to do a number two and we're going to put in a seven why not and what we can do we can say result equals number one plus number two and we're going to store the result of this operation and the result variable here so what we can do is say sddcl and we're going to print the result we can try and compile this and see the result let's open our terminal here and we're going to build with gcc as we always do the world is going to go through and if we run rooster here we're going to see that the result of our operation is 9. so this is how you can do addition you can also do subtraction and here we know to declare a new variable we're going to store the result in our result variable here so what we're going to do here is say subtraction and we're going to say result equals for example let's take number two minus number one this is the operation we want to do this is number two what we are going to be storing in this result here is going to be a 5 because we are taking 7 and subtracting 2. i hope this makes sense so if we grab this line here and paste it in here so that we save on some typing time and i try to build again we're going to run the world task with gcc and we're going to run rooster again it is going to say result is 5 because we are taking 7 minus two here the result is going to be five we can also do a subtraction operation that is going to result in a negative number so for example we can say result equals number one minus number two and this is going to give us a negative number because two minus seven is going to be minus five so we're going to print that here i'm going to paste this end because i still have this on my clipboard if i bolt with gcc and run my program we're going to get -5 as a result of this operation here this is how you can do subtraction we can also do multiplication so let's go down here and say that and we're going to say result equals number one multiplied by number two and this is the operator we used to do multiplication in programming languages we're going to put in our print statement here and we're going to world with gcc and if we run rooster now we're going to get 14 because we are taking 2 and multiplying that with 7. this is how you can do multiplication so what happens if you take seven and divide that with two try to give this a guess based on what we saw in the slides we're going to go down here and do division and we're going to say result equals number two divided by number one and uh we're going to try and print this out if we build this the world is going to go through and if we run this we're going to see that result is three so to really make sense of this let's look at these numbers we are taking number two and dividing that with number one so it is seven", "17695.84 - 17996.399999999998": "and because we can't store fractional numbers in an integer the fractional part is going to be basically chopped off and we're going to store a three because two can fit in seven only three times i really hope this makes sense the last operation we're going to look at is modulus and it is a way to capture the reminder of a division operation so we're going to do result to play with us and we're going to say number two and we're going to say modulus using the percentage operator here and we're going to say number one and we're going to print the result of this and uh take a look at this here and try to guess what we're going to be doing what we're doing here is really seven modulus two and we're going to take seven divide this by two and the reminder of that is going to be one and that's what we're going to store in this results variable here and if we print that we expect to get a one here this is what modulus does let's build and build with gcc the world is going to go through if we run rooster here we're going to get a one let's do what we used in the slide so that this really makes sense we're going to go down here and i do equals 31 modulus 10. this is what we used in the slides so we're going to print the result here and here we are really asking what is going to be the reminder if we take 31 and divide that by 10 and that reminder is going to be stored in this research variable so here we're also going to get a one so let's weld with gcc and we're going to run the program and we are also going to get a one down here again the modulus operator can be hard to understand for beginners but it is really capturing the reminder of the division again we can see that here we are asking how many times can 10 fit in 31 and we visualize this here it can only fit in three times and the reminder is going to be this red thing you see here it's going to be one and when we do a modulus operation here we are interested in that reminder and that's what we're going to be storing in whatever variable that is capturing the result of this modules operation and that's what we basically have here and this is really all we set out to do in this lecture now i hope you have a good understanding of these operations you can do on integers we have used integers here but you can really do these operations on numbers except for the modulus operator which is really going to make sense for integral types so you can't really do modulus on floating points or fractional numbers that's not going to make any sense at all we're going to stop here in this lecture in the next one we're going to learn about precedence and associativity a very important concept for your operations in your c plus plus programs in this lecture we're going to learn about precedence and associativity so what do we mean by precedence and associativity really what we mean by this is a set of rules that we can follow to know what to do when we have multiple operators in the same expression like in the example we have here if they tell you to evaluate the result of this expression if we don't have clear rules to follow we might have multiple answers and we want to know which one is right or wrong for example one might want to do a and b first and then do c and then do d but one might want to do e minus f and do b multiply by c and then do things in different ways and get different results hopefully you are saying that this may be a big problem what we get from precedence and associativity is the rules we can follow to know which operator we have to do first for example in c plus plus the multiplication and division operator have to be done before you do addition and subtraction and if you want to evaluate this expression here you're going to have to do b and c first and then do d and e once you have those results then you can do addition and subtraction but the question remains still what do we do first if we have only addition and subtraction in an expiration and we solve that problem with associativity associativity defines if you do the operations from the left or from the right and again these things might not make sense yet we're going to do an example and you're going to really see what is meant by this", "17996.399999999998 - 18296.239999999998": "operation you can do first and associativity is going to tell you in which direction you're going to go from the left or from the right and some operators are going to be left associative and that means that you're going to start evaluating them from the left some operations are going to be right associative and you're going to start evaluating them from the right and i am not making these things up there is actually a c plus plus operator precedence table that you can consult to know which operators you should do first if you really are evaluating this thing with your mind okay for example if you look in this table there are many operators we haven't seen yet but that's not the problem the most important thing here is to know what precedence and associativity are and when we get to learn about these new operators you can come here and know where they sit in this precedence table for example we know how to do addition multiplication and modulus we see that the precedence for multiplication division and modulus is higher than for addition and subtraction and we can use this in our operators to know which one is going to be evaluated by our compiler first another thing i want you to notice in this table is this column here on associativity if you go back to our familiar operators here you're going to see that these operators are left to right so you should start evaluating things from left to right but some operators have right to left associativity and when we get to these operators you will start doing things from right to the left okay i think it is time we went to visual studio code and actually played with this thanks here we are in visual studio code we are in our working folder we are going to grab our template projects we're going to copy this and put that in our lecture on precedence and associativity we're going to put that in here we are going to open this project in visual studio code we are going to get rid of things we don't need and remove this here in the body and we are going to put in our test code so that we don't have to type this and save on time we have a few variables here a through g and we have an expression here or a statement that is combining multiplication division addition and subtraction and we have to figure out which operation we're going to do first i would challenge you to do this in your mind and try to guess what the result is going to be before we run this in our compiler we're going to compile this with gcc and we are going to open our terminal here and if we do durham we're going to see that we have rooster.exe if we run it we're going to see that the result is 30. how did we come up with that well the precedence and associativity table says that multiplication and division have to be done first before addition and subtraction we are going to take b and c and multiply those so b and c multiplied we're going to get a 24 we're going to try and do this in our brain d divided by a we're going to do that so d divided by e we're going to get a 3 so we're going to have a 3 here and after we have this we're going to do addition and subtraction so we're going to take a and add that to the result of b and c so we're going to say 6 plus 24 which is the result of b and c we're going to minus the results of d and e and we're going to do minus here i hope you are following and then we're going to minus f and plus g we're going to minus f which is 2 and do a plus g which is 5. okay so this is our expression here and now that we have this we have to think about how we're going to do this we can try to do this from the right do two plus five and then do three minus two plus five and go from right to left but our associativity table says that addition and subtraction have left to right associativity so we will start from the left so we're going to do 6 plus 24 we're going to get 30 we're going to minus 3 and we're going to get 27 we're going to minus 2 we're going to get 25 we're going to add 5 we're going to get 30. i hope you are following and we are really following the rules from our c plus plus operator precedence table here okay so this is", "18296.239999999998 - 18597.52": "and the search activity rules to evaluate your expressions okay here i have another example for you so try to evaluate what we're going to get from this expression here we have a divided by b divided by c plus d minus e plus f try to do this in your brain and try to guess what we're going to get from the compiler if we print this out we're going to put in our htdc out statement here and we're going to try and build this with gcc of course we're going to run the rooster and you're going to get a 24. so how did we come up with that we're going to start by division and multiplication and again where do we start do we do b and c first or do we do a and b first well we can check our precedence table here and we're going to check the associativity of multiplication and division we're going to go to this entry here 13 and we see that it is left to right associative these operations here are left to right associative so what we're going to do we're going to start from left and go to right so we are going to take a and divide by b if we take a divided by b we're going to get a 2 so let's type that here then the result of that is going to be multiplied by c and if we go up we're going to see that c is eight so we're going to multiply by eight and get six so we can replace this with a 16 and we should be here then we're going to add d d is nine then we're going to subtract e which is three then we're going to add f which is a five so we have 16 plus nine this is going to give us 25 minus three okay by checking this out i see that i made a mistake f is not five it is a two we have here and if we do this from left to right because addition and subtraction are left associative we have to do them from left to the right we're going to take 16 and add a 9 we're going to get at 25 minus 3 we're going to get 22 plus 2 we are going to get 24 and that's what we have here i really hope this makes sense okay so we have seen how we can use this precedence table but sometimes you want to make it really clear which operations should be done first and you can do that by using parentheses around your expressions let's grab the first expression here and do it again we're going to copy it and go down and put that in place and we're going to store the result in our result variable and notice that we are reassigning these things to the result variable so that we don't have to declare another variable i think this is clean and that's what we're doing here so what we can do here is make it clear that we want multiplication done first by using parenthesis and make it clear that we want the division to be done first and when you do this the compiler is going to see that you want this operation here done first and that's what it is going to do and if we print result again we're going to get exactly the same thing we had before stdc out result and we're going to put result out and let's make it clear that we are using parents here to signal which operation we want to be done first we can compile this with gcc we're going to run the task to build with gcc and if we run the program we're going to see that the result is 30 exactly what we had before but now it is very clear to the reader of this piece of code that we want b and c done first they don't have to go through the precedence table to really try and figure this out potentially wasting precious time another thing you can do with this is for example what if the precedence table is not working according to your needs for example you really want a and b done first you can specify this with parents here and what this is basically going to do is going to force the compiler to do this first it's no longer going to do b multiply by c and d divided by e it's going to evaluate this first then it's going to follow the order in the precedence table that we have seen before so try to guess what we're going to get now and i am going to run the code and we're going to go through this together so let's run", "18597.52 - 18895.28": "you see that the result is 72. what is happening here well let's go through this line by line we are doing a plus b which is a 9 so we're going to get a nine here we're going to put that here as a comment then we're going to multiply that by c so we're going to do 9 multiply by 8 and that's going to yield a 72 and by that time we're going to be here and we're going to do the division first d by e then we're going to take nine and divide by three that's going to yield the three so we're going to have a three here minus 3 we're going to minus f which is a 2 and we're going to do plus g which is a 5. if we evaluate this we're going to get 72 minus 3 which is going to be 69 minus 2 it's going to be 67 plus 2 it's going to be 72 and that's what we have here hopefully you can see that using the parents not only can you make it very clear which operation you want to be done first you can also define the rules that are prescribed by the precedence tables that are defined in c plus plus i hope this makes sense and this is really all we set up to do in this lecture to learn a little more about precedence and associativity and my advice to beginning programmers is not to rely on the president's table too much it is to try and make your intent very clear using parenthesis and anyone reading your code you want to have to go check these rules in the reference c plus plus documentation they are going to directly understand what your expression is going to do and that's a good thing readability of your code is really something you should strive for this is really all we set out to do in this lecture i hope you have a better idea about precedence and associativity we are going to stop here in this lecture and the next one we're going to learn about some cool things we can do with addition and subtraction go ahead and finish up here and meet me there in this lecture we're going to be learning about prefix and postfix addition and subtraction we have an example here and it is a simple example we've seen a lot of times by now we have a variable value it is an integer and we have a 5 inside we can add a 1 to it or we can increment it by one this is another term we use in programming languages when we say we are incrementing a value we are adding something to it in this case we are incrementing it by one and we are basically going to store a six and this value here so if we print this out we're going to get a six here this is what we would expect we are resetting the value to five and that we are going to minus one or decrement by one and the result is going to be saved in value again so the second stdc out statement here is going to print a 4. this is something you should expect now another thing we can do in c plus plus is do something like value plus plus here and what do we mean by that when you use a postfix increment operator like this the first thing you should know is that this is going to increment by one it's not going to increment by any other value c plus plus doesn't provide a way for you to specify another number to increment by so value plus plus here is going to increment by one but another thing you should know is that it's not going to increment directly what's going to happen here if you look to the top here we have a value 5 when execution hits this stdcl statement we are going to grab the value here so here we're going to really print a 5 but as soon as this statement is done the value is going to increment by one so the next time somebody is going to use this value here is he's going to find in a 6 and that's what we have here so the first one is going to print a five because we're going to grab the value in here as is but as soon as we have our value this is going to increment by one this is what we mean by this value plus plus here and the second statement is going to print sx because it is already incremented and we call this postfix increment because plus plus is after the value here and this is really what this operator does and sometimes it is going to come in handy in your c plus plus applications we can also do the same thing with minus minus it is going to grab whatever value we have in this variable so we have in a five so that's what we're going to print here", "18895.28 - 19195.04": "it already decremented by one because after we have our five we're going to decrement by one that's what we are saying here and we're going to find the nf4 because 5 decremented by 1 becomes a 4. i really hope this makes sense ok so what we have seen here is postfix increment and decrement but we can also do a prefix version of this thing if you look at the example we have here we have a five and we are saying plus plus value so this is going to increment the value directly so as soon as this statement is executed the plus plus value statement here we're going to have a 6 inside and if we print it we're going to get a 6 and this is what you see here if we go down we are resetting our value and we are going to prefix increment in place so in here we are going to increment the value before we actually print it here and we are also going to get a six year i hope this makes sense and if you have any problem with this i think if we go in visual studio code you're going to have a better way to say this you're going to see the code running and make sense of it okay so i think that now you understand why we're going to have these numbers printed if we go down we can do the same thing with decrementing we have a value here it's five if we prefix decrement it it's going to be a four here and if we print it we're going to get a four if you go down here we are resetting that to five and we are going to prefix decrement in place and this is also going to print a four because we have a five here and if we decrement it by one we're going to get a four and that's what we're going to get here okay this is really all these prefix and postfix increment and decrement operators are about we are going to go in visual studio code and actually see this running okay here we are in our working directory we're going to do the usual we're going to copy code from our template project we're going to put that in here we're going to go up and open this up in visual studio code so we're going to remove things we don't need and we're going to remove this and we are going to put in the code we exactly saw in the slides here we have a value it is an integer and it is five if we increment it by one we're going to get a six here okay and if we print it that's what we're going to get we are resetting this to five and if we decrement it by one we're going to get a four here so if we run this piece of code we should have a six here printed out and a four down here we're going to bring up our terminal and build this with gcc the weld is going to go through and if we run the program we're going to get the value a6 and it is four and this is really what we expect here okay now that this is really clear we're going to go down and play with post fix increment and decrement i am going to put in a separator here so that we can clearly see in our terminal here and we are going to put in our test code that we are going to use to play with this let's bring this down a little bit so that you can see everything we can remove these things we don't need them anymore okay we are going to take the value we had we're going to reset that to a five and if we value plus plus here this is going to be a five because we're going to capture the value as is so here we're going to get a five but next time we get this value it's going to already be a sex because we increment immediately after capturing the value here so here we're going to get a 5 and here we're going to get a 6. i hope this makes sense and if we go down here we are resetting our value to 5 before we do any decrementation we are going to capture the value as is because we are doing post fixed decrement and here we are going to get a 5 because we are capturing the value as s but as soon as we capture our value we're going to decrement it and the other statement here is going to get a decremented value and that's going to be a 4. so here we're going to print 5 6 5 4. let's try and build this with gcc to see that we have no problems we have no problems the world is good if we try to run rooster now we are going to get the results we had before but uh for this code we just put in here", "19195.04 - 19496.877999999997": "what we have here and we're going to get a 6 which is coming from here after we are going to decrement and we are going to capture the value as is we're going to get this 5 here and for the last statement we're going to get a 4 because the value is already decremented and that's the for we are seeing here i really hope this makes sense and this really covers the postfix increment and decrement operators the last thing we want to see in this lecture is that we can also do prefix increment and decrementation we're going to go down here and set up a place where we're going to be playing with this so we're going to say prefix and we are going to put in our code because i don't want to type all this that would waste your valuable time but i do encourage you to type these things out and really drill them in your brain because that's how you're going to learn okay let's bring this down so that we can understand this piece of code so we are starting by resetting our value to 5 and notice here that we do plus plus value this is going to increment value right away by this time the value is going to be six and if we print it out here we're going to have a six printed down we're going to reset it to five and then we're going to implement that in place this is also going to be printing six and if you go down we're going to do the same version of the same thing but we are going to be decrementing so we're going to decrement the value that we just reset here here it's going to become a 4 and that's what we're going to print and if we go down here we reset it again to a 5 and we prefix decrement it in place so the 5 here is going to become a 4 in here and that's what we're going to print out if we build and run that's what we're going to get we're going to run our task to build with gcc the build is good and if we run our rooster application the results for the code we just put in here are just going to show up here and you see that we get a six six this is six the other six and for the last two statements we're going to be getting fours and that's what we have here i really hope that now you have a better idea of this prefix and postfix increment and decrement operators and you're going to make use of them when they really helped you design your applications better okay so these are your tools use them when they make sense another thing that i want to emphasize here is that these operators only increment or a decrement by one you can't make them do things in increments of five or seven or ten they are going to work in increments or decrements of one we are going to see a way we can do that with other operators in the last lecture but these prefix and postfix operators can't do that and another thing that some of you might be wondering about is if we have the same kind of operators with multiplication or division and we don't have those operators in c plus plus maybe we're going to have them in the future when they make sense but in the current version of c plus plus we don't have them we are going to stop here in this lecture in the next one we're going to learn about compound assignment operators in this lecture we're going to learn about compound assignment operators and these are operators that allow you to do an arithmetic operation like addition subtraction multiplication division and modulus and assign the result to a value in one go let's look at an example here we have value here which is 45 it is an integer and we're going to print that out but if you go down here we are doing value plus equal five and if you look at the comment here this is equivalent to if you did value equals value plus five so what this is going to do it's going to take whatever value is in this value here it's going to increment that by five so that's going to become a 50 and we're going to store that 50 results back in this variable here so by this time if we printed this out we're going to get a 50. again we're going to take the value it is a 45 we're going to add a 5 it's going to become a 50 and we're going to store that result back in this value variable here it's going to become 50 and if we print here we're going to get a 50. this is the addition version of the compound assignment operator we also have a version for subtraction and we have an example of that here so it's going to take whatever value is in this value variable it is going to find in a 50 we're going to subtract 5 we're going", "19496.877999999997 - 19797.84": "to store in this value here and by the time we hit this stdc out statement we're going to print a 45. again we have another version for the multiplication here so that we can really play with all these things we're going to take whatever value is in here we're going to multiply that by 2 here we're going to get a 90 and that's what we're going to store back in this value and if we print here we're going to get a 90 printed out we're going to go down and do a version for a division the value is 90 we're going to divide that by 30 and we're going to store the result back in value here and we're going to get a 30 stored in here and if we print out that's what we're going to get here we also have a modulus version of this and it works really well here we have unit 30 we're going to take it and do modulus 11 and what is the reminder of dividing 30 by 11. the reminder is going to be 8 because 11 can only fit in 30 two times and we're going to be left with the knight because 30 minus 22 is eight and that's what we're going to store in the value here and if we print out that's what we're going to get again if you have trouble understanding this modulus operator here please go back in a few lectures back we had a chance to learn about it make sure you understand it and then come back here and this is all going to make sense this is really all compound assignment is all about we're going to head to visual studio code and actually play with us okay here we are in our working directory we're going to copy our template project as we always do and we're going to put that in our compound assignment operators lecture here we're going to come up and we are going to open this folder in visual studio code the project is going to show up in here and we're going to open our main cpp file and we are going to remove what we don't need we are going to put in our code so that we can start exploring this we have a 45 and this variable here which is an integer if we print it out we're going to get a 45 and down here we are doing a compound addition so what we are doing here we're going to grab whatever value is in this variable we're going to add a five we're going to get a 50 and that's what is going to be stored in here and if we print this out we're going to get a 50. let's put in a terminal here so that we can see this running and we're going to run the task to build with gcc as we always do here and if we run our rooster executable we're going to get the value is 50 and that's what we expect here okay this is the addition version of our compound assignment operator and it is really equivalent to doing this in two steps saying value equals value plus five you're going to get the same result if you do that here actually let's do this so that you don't think that i am making this up so let's comment this out and we are going to say volume equals value plus five and if we build again run the gcc task and run the application we're going to see the same thing we can also go down and run the subtraction version of this example here here we are taking the value that we have in here which is a 50 we are subtracting 5 we're going to get a 45 and 45 is what we're going to store in this value here that's what we're going to see if we print this out so let's run the test world with gcc so that our changes are reflected in our output we're going to run this and we're going to get a 45 this is what we expect we are going to go down and do a multiplication version of this here we have our compound assignment statement we are taking whatever value we have in here which is a 45 we're going to multiply that by 2 and the result of that is going to be 90 and we're going to store that back in value here and if we print value here we're going to get a 19. let's build this run the gcc task and we're going to run our program and we're going to see that we're going to see this 90 here we can go down by a few lines and put in the code to play with a division version of this again this is going to do really the same thing only it's going to be doing this for division we're going to take whatever value we have in here which is", "19797.84 - 20096.638": "that by 3 we're going to get a 30 and that 30 results is going to be stored back in value here and if we print this out that's what we're going to get let's build again and the build is going to go through if we run our program we're going to get a 30. we are going to go down by a few lines and put in a modulus version of this we're going to grab whatever value we have and this variable here which is going to be 30 we're going to do modulus 11 on that value and that's going to be basically 30 modulus 11. the result of that is going to be 8 and we're going to store that result in value here and if we print that out that's what we're going to see in this output statement here we can build again run with gcc and if we run our rooster program we're going to get an 8 printed out and this is really all these compound assignments are about and you might be asking why go through the trouble to do something like this if i can do this like this well c plus plus gives you different way to do things different people have different preferences and some people me included like to do things this way because it is compact and once you use this you're going to get used to this you're not even going to think about it in this lecture here i just wanted you to be aware of this possibility because you are definitely going to see it in c plus plus code out there this is really all we set out to do in this lecture i hope you found it interesting we are going to stop here in this lecture in the next one we're going to learn about relational operators in c plus plus in this lecture we're going to learn about relational operators in c plus plus and these are basically operators you use to compare stuff let's look at a piece of code here we have two numbers one is 45 and another is 60 they are stored in integer variables number one and number two we can print them out and we're going to see them on the console or our terminal and if we go down we can really compare them we can use the less than operator less than or equal operator greater than greater or equal operator we can check and see if two numbers are equal by using two equal signs here be careful about these two equal signs because if you use one you're not going to be comparing numbers you're going to be taking the thing on the right and assigning that to the thing on the left so if you want to compare you're going to have to type two equal signs another operator we can use to compare stuff is exclamation mark and equal which is going to basically test if two numbers are equal and we're going to get the result one thing you should notice here is that we are wrapping our comparison expression into parenthesis that's because if we don't we're going to get a weird compiler error that i am going to show you when we get in visual studio code but we don't have enough tools to really understand this error at this moment so what we are going to do is avoid that problem by putting parenthesis around our comparison expression here we're going to go to visual studio code and actually see this in action here we are in our working directory we're going to grab the code from our template here and we're going to put that in the current project which is relational operators we're going to go in and put in our code and we are going to open this up in visual studio code we're going to get rid of things we don't need here we are going to put in our code so that we can explore these things we have two variables in one we have a 45 in another we have a 60 and these are integers the name for these variables are number one and number two we're going to print them out and we're going to see them on the console now we are going to compare them one thing i haven't told you yet is that these comparison operators evaluate to booleans in other words they are going to return true all false if you look down here we want to know if number one is less than number two and the result of that is whether that's true or false and this really makes sense so because of that we are using std bull alpha here to force sddc out to print this boolean value here as a true or false instead of a one or a zero and we have seen this before so if we try to", "20096.638 - 20397.920000000002": "terminal we can use and we're going to run the test to build with gcc if we go down here and run our rooster program we're going to get our two numbers 45 and six and we want to know if number one is less than number two and that's true 45 is less than 60 so the result of this expression is going to be true now you know how to use this operator one thing i want you to see is what could happen if you didn't use this parenthesis around this expression here let's try this out we're going to remove this parenthesis and we're going to try and world we're going to run the task to world with gcc and we're going to get a really weird error because the compiler is going to try and evaluate this operator first if we go back to our c plus plus operator precedence table and look at the operators we are trying to use in the sddc out statement we're going to see that the operator to print fans on the console has high precedence than our comparison operators here so the precedence for our operator to print things to sdd out is 11 so it is higher and the precedence for our comparison operators is nine and eight so the compiler is going to try and do this operator first if we come back in visual studio code the compiler is going to try and think that you are printing number one but then again it's going to see this less than sign and things are going to blow up we don't really have enough tools to understand what is going on right now but i just don't want you to see this arrow and show you a way to go around it and move on with your life by comparing stuff in your c plus plus programs if you put parentheses around here the problem is going to go away let's try and build again we're going to build with gcc and everything is going to go back to normal and we're going to see our output if we run our rooster program here this is how you can do this okay now that we have a basic understanding of this we can try the other operators and it is going to be a walk in the park we are going to go down here and put in our remaining operators we can use less or eco operator to test and see if number one is less or equal to number two we can use the greater than operator to test and see if number one is greater than number two we can use the greater or equal operator we can use the equal equal operator to test that number one is equal to number two and we can use this operator here which is made up of the exclamation mark and an equal sign to test and see if two numbers are not equal and all these operators are going to evaluate to a boolean basically saying if what you are testing for is true or false and we can print this out and notice that we have this parenthesis around to avoid the problem i just showed you a few minutes earlier and if we run this we're going to see the results let's weld this with gcc as usual we're going to run our program and you're going to see that number one is less than number two this is true number one less or equal to number two this is also true number one greater than a number two 45 is not greater than 60 so this is false it's not greater than equal so this is also false number one equals to number two this is going to be false and uh the last statement that is going to test and see if number one is not equal to number two is going to evaluate to true because number one is not equal to number two if this is not making sense yet please go through it a couple of times and if you have a problem please do ask me i will do the best i can to help you out another thing i want you to see before i let you go is that you can store the results of these operators into a variable and use that later in your program for example here we can take our expression to compare number one and number two the result of that is going to be installed in this bold variable and we can print it out later like this if we run this we're going to build with gcc and we're going to run the program we're going to see that 45 equals to 60 is false and it is coming from this statement here you can try and change", "20397.920000000002 - 20697.04": "a 20 and see the results that we get and you can try and run these in your mind and see that they really make sense if we run rooster now we're going to get to different results because we are now comparing 45 and 20 and here at the last statement you see that they are not equal if we put into equal numbers we're going to get a true there let's try this out we're going to run the task to build with gcc and if we clear so that we get rid of all this noise and run rooster we're going to get 20 is equal to 20 and this is true this is really all we set out to do in this lecture i hope you have a better idea of these relational operators in z plus plus we're going to stop here in this lecture in the next lecture we're going to learn about logical operators in c plus plus go ahead and finish up here and meet me there in this lecture we're going to learn about logical operators these operators will work on boolean operands we're going to look at end first to really make sense of how they work here is a simple table we can use to try out the end operation it is going to be working on two operands a and b and in the third column here we're going to have the result so if a is false and b is false and we do a and b the result is going to be false if a is false and b is true the result is going to be false if a is true and b is false the result is going to be false if a is true and b is true the result is going to be true the way you can think about this and operator is that if any of the operands is false the result is going to be false and if you really use this way of understanding this it is going to be really easy and the first line here we have a false so the result is going to be false and the second line we have a force it's going to be force in the third line we have a false the result is going to be false but in the line number four here we don't have a false a is true and b is true so the result is going to be true another operator we have is or and it is going to evaluate to true if any of the operands is true let's look at the first line here a is false and b is false so we don't have a true the result is going to be false on the second line we have a true the research is going to be true on the third line we have a true the research is going to be true on line number four we have a true the result is going to be true and you don't really have to memorize these tables if you use these operators long enough these things are going to be drilled in your memory if you have any problem with these operators just look up tables like this and you can find whatever it is you need without really memorizing these things another operator is the not operator which is going to negate whatever you give it so if a is true and we negate that we're going to get a false if a is false and when you get to that we're going to get it true and we use this exfoliation mark to say that we are negating something if you go back to or it is denoted by these two vertical bars and the end operator is denoted by these two ampersand symbols here okay now that we know about these logical tables for these logical operators we can actually try to use them in code here we have three boolean variables we have a b c a is true b is false c is true we can print them out and you see that we are setting up sddc out to give us the results in the format of true and false instead of ones and zeros and down here you see that we are trying to use the and logical operator down here you have a and b a and c and we are doing this on three operators and chaining these things up so we are saying a and b and c and let's try and do this in our mind to see that we really understand this we have seen that the end operator evaluates to true when all operands are true another way to say this is the end operator evaluates to false if any of the operands is false so we're going to end a and b a is true b is false so the result is going to be false because we have a false in here a and c is going to evaluate to true because a and c are true a and b and c is going to evaluate", "20697.04 - 20996.958": "even if you have 1 000 tools and you end that with one false that's going to be dragged down to evaluate to false that's what we are seeing here we can also do all operations on these things and this is going to give you a true if any of the operands is true we know that a is true and b is false so this is going to evaluate to true a and c is also going to evaluate to true because a is true a and b and c is going to evaluate the true because a is true so let's go back and see this these are the values we're going to be using here we can also try out the nut operator and it is going to negate whatever we gave it so if a is true we're going to get a false b is false we're going to get it true c is true we're going to get a false another thing you can do is combine this logical operators so we can do something like a and b and all of that with a c and you should notice that we are wrapping our expressions here in parenthesis so that we don't have the same problem we experienced and explained in the last lecture and one thing you should know is that for the compiler to evaluate these things we are going to follow the rules in our table for precedence and associativity but we used parentheses to really make this easy to follow so we are going to end a and b and the result of that is going to be ored with c and you can try and do this in your mind and you're going to figure this out but we're also going to go to visual studio code in a minute and we're going to see all these things in action the last thing you can do is combine logical and relational operators into expressions for example here we have d e and f they are integers and we can print them out like we are doing here but we can do something like d greater than e and we're going to end the result of that with d greater than f and we know that these relational operators evaluate to booleans so we can use these booleans with logical operators like we have been doing all along in this lecture so for example let's evaluate the first one here in mind so that you really see what this is all about d is 45 e is 20 so d greater than e is going to evaluate to true d greater than f that's also going to evaluate to true so true and true that's going to evaluate to true and this should print a true on the terminal we are going to go to visual studio code and actually play with this thanks okay here we are in our working directory we're going to jump into our template project and copy the files we need and we're going to put them in our lecture on logical operators we're going to put that in here we're going to open up this folder in visual studio code and it is going to show up here in visual studio code we're going to get rid of what we don't need and we are going to put in the code to play with these things we have three boolean variables a is true b is false c is true and we can print them out and we're going to see their values and you see the setup here so that sddc out is going to show thanks in the format of true and false and down here we are ending a few values we are using the and operator and it is denoted by these two ampersand signs so a is true and b is false and c is true a and b is going to evaluate to false because we have a false in here and again if this doesn't make sense please do consult the tables for all these logical operators and all these things are going to make sense this is going to evaluate to false because we have a false in here and a and c we have true and true so this is going to evaluate to true and a and b and c this is going to evaluate to false because we have a false in here remember as soon as you have a false in your and logical operation you're going to get a false in your result so we're going to have a false here we can try and compile this and see if this is actually what we expect we're going to bring up a terminal we're going to use here and we're going to run the tasks to build with gcc and if we run our rooster program we're going to see that a and b is false this is what we expect a and c is true this is what we expect", "20996.958 - 21295.12": "is false and this is what we expect this is how you can really play with your and logical operator if you want you can change things up to really try and see if they live up to your expectations now we have changed a to false let's try and build again we build with gcc and we're going to run our program and we're going to get a and b is false because they are all false a and b are false so false and false evaluates to false a and c is false because a is false so we're going to get a false as the result a and b and c is also going to evaluate to false okay we have this tension here let's bring this back to what it was before so a is going to be true b is going to be false c is going to be true and we're going to try and play with the or operator we are going to go down and put in code to actually play with this and it is really nothing special we are just using the or operator here which is denoted by these two vertical symbols and or is going to evaluate to true when at least one of the operands is true okay so we have our values here a is true b is false c is true a or b is going to evaluate to true because a is true a or c is going to evaluate to true because a is true a or b or c is going to evaluate to true because one of these things is true and a is true here we can try and run this we're going to build this first with gcc and if we run this we're going to go down here and run rooster again and you're going to see that all these things are true here because one of these things is shown and as long as you have one true operand your or operation is going to evaluate to true and again this is following the precedence and associativity rules we have if we go back to our table in our browser we're going to try and look at logical or it is left associative so we're going to try and evaluate this from left to right so we're going to or a and b and the result of this is going to be ord with c we have also seen the not operator which is denoted by the exclamation mark here and what it is going to do is basically flip off or negate whatever it is you have if you have it true in your variable the result is going to be false if you have uniforms the result is going to be true and not a is going to be false because a is true not b is going to be true because b is false and not c is going to be false because c is true as we can see here so let's run the application and see if this is what we expect we're going to run and build with gcc and we're going to run rooster and we're going to see that note a is false not b is true and not c is false and this is what we expect we have also seen that we can do combinations of these operators so for example we can look at the expression we have here we're going to take a and b this is going to evaluate to false because b is false we're going to negate this and we're going to get a true and we're going to order that with c but because it's true we know that the result of ordering this with anything is going to be true so we expect this expression here to evaluate to true if we run this we're going to see that this is going to evaluate to true and it is what we expect the last thing we want to see in this lecture is that we can combine these logical operators with the relational operators we have seen in the last lecture we are going to put in a piece of code to play with this this is lengthy but you can play with this and see what this is going to evaluate to to start you off we are going to do the first one together so it does test if d is greater than e and if you look here 45 is greater than 20 so this is going to evaluate to true and we're going to enter that with d greater than f the result of this is going to be true so we're going to be ending a true and a true and the result of this is going to be a true and again you notice that we", "21295.12 - 21595.76": "avoid problems with the compiler being confused with what we are trying to print this is going to get rid of the otherwise ugly problems we might have to deal with if we didn't wrap this into parentheses like this so we expect to see a true here and we're going to weld and run the task to build with gcc and we're going to run rooster and if we look at the first thing here this is going to be true and you can try and do the other ones in your mind as an exercise and if you have a problem don't hesitate to ask me i am going to do the best i can to help you out this is really all we set out to do in this lecture i hope you have a better understanding of these logical operators again you don't have to really memorize them all you have to do is consult the tables and you're going to basically know the result of your two operands depending on the values you have inside for and or and the not operator we are going to stop here in this lecture in the next one we're going to see how we can format our output to make it really look better go ahead and finish up here and meet me there in this lecture we're going to look at output formatting and c plus and this is the way we can format stuff we send it to the terminal through sddc out and make them show up better as an example let's say we have a table here that has names and ages and you see that they are cramped and through output formatting we can take this and turn this into this and hopefully we agree that this is better there are a set of tools we can use in c plus plus and those we're going to be using in this lecture are going to be coming from these two libraries ios and io manip and there are a lot of things in these two libraries here is a a set of cards that show a lot of them we are going to play with a lot of these in this lecture so you don't have to worry if some of them seem scary right now before we start looking at them i want to bring to your attention that there is a piece of documentation on these things the link is here the website is called cppreference.com and you can open this up and look at some of the things we're going to talk about in this lecture okay the first one we're going to look at is stdendl this is not new we have been using it all day long to print out a new line character so that our htdcl statements print things on different lines and if we don't have this manipulator you see here on the top we have hello and world and if we print them out they are going to show up on one line because we are not separating the lines with std e and dl down below here we have another way we can do this we can post a backslash n after our text and that's going to add a new line character just like std endl does okay stdndl and slash n in here seemingly do the same thing but they are different but we don't have enough tools to really understand the differences right now for now just think of them as two things that do the same thing they print out a new character that allows your text to show up on different lines like we have hello and world here okay stdndl is the first manipulator we're going to play with in this lecture the next one we're going to look at is sdd flush and this is going to send whatever is in the output buffer to the terminal and what the heck is an output buffer let's look at an example suppose we have sddc out here and we want to print on this terminal and the message we want to print is hello world how are you so what is going to happen if the sddc out statement is executed things are not going to be directly sent to the terminal they are going to go into an intermediary buffer you can think of this as some kind of storage in which data goes before it goes to the terminal and this is what's going to happen we print out hello hello is not going to go to the terminal directly we print out world it's not going to go to the terminal we print out how are you it's not going to go to the terminal and when the buffer is full the data is going to be sent to the terminal in one go and this may come in handy in some situations so if you want the data to go to the terminal directly you're going to add an sdd flash after your hddc out statement and we are", "21595.76 - 21897.2": "visual studio code and you're going to see how this works another manipulator we have which is really cool is set with and it is std set w here and what it does it specifies a width for whatever text you want to print here we have two examples the first one is our table that is not formatted well and you see we just print out the data and it is going to show up like we see here on the right we can use std set with to set the width of the text here and for example the last name here is going to show up in a field which is 10 characters white this is what we mean here and we do the same for the first name and the age and if we do this data is going to show up nicely as we see here and again i hope we agreed that what we have down below here is much better than what we had here which was not formatted with set width and this is how you use this manipulator here we can also use what we call justification to control whether our data shows up on the right or on the left in the width that is allocated to it for example here the justification is sdd right so the data is going to show up to the right in its respective cells we can also use what we call internal justification by which if we are showing a negative number the sign is going to be left justified so it is going to show up on the left but the data is going to be right justified and this may come in handy if you want to display some tabular data in your terminal we can also use std set field to specify the field character in our empty spaces for example here we set the dash as a field character and the result is what you see down below here we have seen std ball alpha and its effect is to force stdc out to show boolean output in the form of true and false if you don't put this manipulator in you're going to see those pieces of data as ones and zeros so for example here we have two variables condition and other condition if we print them out they are going to show up as one and zero we are going to set our manipulator here so the data is going to show up as true and false we can disable this manipulator here with std noble alpha and the data is going to go back to be shown in the form of one and zero this is what this manipulator does we also have one to show the positive sign for positive numbers so if we don't enable it the data here is going to show up like this 34 and minus 45 you see that the minus sign is going to be shown regardless of the setting you have for this manipulator but if we enable std show pose we're going to show the positive number and this may make sense for whatever application you might be doing we can disable this with std no show posts and after we do this the data is going to show up in its default format that we have seen before this is how you use std show posts we also have manipulators to control the base in which the data is shown and we can show the data either in a decimal in octo or in hexodecimal if you look at the data here we have an integer which is positive we have an integer which is negative and we have a double variable here and we have some data n for us to play with we're going to show our positive integer in these three bases decimal hex and octo and the result is what you see here and this should be no surprise you already know these number systems and how they work we can take the negative number and also show it in different bases decimal hexadecimal and octo and it is what you have on the right here in our terminal if we go down and try to show a double or a floating point number in these bases the result is not going to change because these number systems have no effect on floating point numbers if you remember we have seen that floating point numbers are represented in memory following another protocol that is really advanced for a course like this so we are just going to use this but we're not going to try and understand it because it is out of scope for what we are doing here we can also use std show base to show the base of our output so here we have a positive number which", "21897.2 - 22195.68": "decimal hex and act and we're going to see what we see here to the right but we can choose to also show the base of whatever it is we output if we want to specify that the output is in decimal we're going to say that here but we can also decide to show the base and we enable that with std show base like this and if we do this we're going to see decimal is not going to have anything in front hex is going to have a 0x in front oct is going to have a zero in front and by this it is going to be very easy to see the base in which your data is displayed we can also use std upper case for the data we print out to be shown in uppercase where it makes sense for example here we are trying to print numbers in hexadecimal here in the middle so if we don't use uppercase which is the default the number is going to show up like this you see a and f are lowercase but if we enable uppercase we're going to see this in uppercase and sometimes this is going to be helpful for whatever application you are using the sun we also have a few manipulators to control how floating point data is shown on the terminal and the two of these are std scientific and sdd fixed by default stdc out is going to show in scientific format where necessary and it is going to use fixed by default so what we have here we have three variables abc and if we just print them out they are going to show up in this format here if we use fixed we're going to force the output to be in fixed format and you're going to see that the third number in c here is going to show up as 0.0 and a few zeros after that because in the precision that we have now we can't really show a number that is as low as we have here in c again we have seen this scientific format this is basically 1.34 multiplied by 10 to the power of minus 10 and this is a really really low number so we're going to do 0.000 up to 10 and that's when this decimal point is going to show so it's a number that is really close to zero that's why we are showing it like 0.0 here i hope this makes sense we can also use scientific notation if we want that and if we force scientific notation everything is going to be shown in scientific notation another thing that i really want you to be aware of is that there is no official way to set the floating point output to its defaults and here is a hack i actually learned about when i was making this course the explanation of this is really out of scope for this course but just use this to set the floating point output format to the defaults and if you do this you're going to get whatever we had here with the defaults you're going to see that it is the same things the next thing we're going to look at is std set precision which we have seen before and this is going to set the precision with which the data is going to show up on the terminal if you use a precision of 10 that's what you're going to get here here you see that we have a double number it is a number that has a lot of numbers after the decimal point if we show it by default it's going to show up like this the precision is going to be sex we can increase the precision to 10 to 20 and 50 and it is going to show up at whatever precision that you specify here please know that this precision is going to be limited by the type of this a variable if it is a floating point the precision is going to be something like 7 we have seen that if it is a double the precision is going to basically double to something like 15 and if you have a long double the precision is going to be something bigger than double but it can't go below that of a double we have seen this before we also have show point which is going to force showing the decimal point for floating point values you see here we have a 12.0 this is the most important piece of data we have here if we don't do show point this is going to show up as 12 in the output here but we can use show point to force for the decimal point to be shown and you see that 12.00 here is shown another side effect of this is that show point is going to force the showing of trailing zeros and it is what we see here in d e and f we have seen a lot of", "22195.68 - 22495.36": "going to show where many of these are going to be living so if you need to use set width this is going to be living in the i o manip header and here we have a few other ones so if you want to use a few of these things these are the libraries that you will need to include with pound include as we have been including i o stream and again the documentation for these things is shown at cppreference.com this is the exact link and you can check this out if it helps out now that we have an idea about these things we're going to go in visual studio code and actually see these in action okay here we are in visual studio code the project we're going to be working on here is output formatting so we're going to be grabbing our template files and put those in our project here and we're going to go up again and open up this folder in visual studio code let's do that we're going to close the welcome screen here and we're going to remove whatever it is we don't need we're going to take this out and we are going to put in the first code we want to play with and this is stdendl you don't really need a lot of explanations for this because we've used this all along if you don't put it out the data is going to show up on one line and uh you're going to have hello world on one line if we put stdndl like this we're going to have the data show up on different lines so we're going to have hello and world on different lines and it is possible to use a backslash n to achieve the same thing but these work very differently underground and we don't have enough tools to really understand the difference so for now just take this as the truth and i know that there are differences and the most important thing is that you recognize these things if you see them in code out there we are going to bring up our terminum and build this with our task that is going to build with gcc you're going to see that the world is going to go through and that we can run our rooster binary to see the output you see that we have hello world on one line we have hello and world on different lines and this is a result of these events we have here you see we have stdndl this is going to force the terminal to go to the next line and print world and after that we're going to force the terminal to go to the next line and that's where the next text is going to show up after that we have hello and world down here in the terminal and it is the output generated by the statements that we have in here and you can see that it is going to basically do the same thing as stdendl but again they work very differently under the hood okay so this is really how std endl works and you get access to it by including the i o stream library here the next thing we're going to play with is std flash this is going to flash the output buffer to its final destination and that's going to be the terminal in this case and if we add that to our stdcl statement like this this is going to be directly sent to the terminal and this may come in handy in some applications if we run this we're not going to really see a difference but underground under the hood the data is directly sent to the terminal and we had the chance to explain this in the slides earlier we can work this program and i see it running the world is going to go through if we run the rooster we're going to see that this is a nice message is sent to the terminal the next thing we're going to look at is set with i am going to put in the code here because i don't want to type all this and again you can get the source code for this in the results section of this lecture you don't really have to type all these things the most important thing is that you really understand how they work okay you see here we are going to use set with but we haven't really included the library that is going to give us access to this and if you don't know which library you will need to include to get access to this well you can check the documentation and to get access to the documentation you might want to consult your favorite search engine i am going to go in google here and type in std set w and i am going to search and this is going to come up with a few entries i am going to click on the one from cppreference.com because this is reliable in my opinion and if we open this up we're going to see that to work", "22495.36 - 22795.039999999997": "so this is what we need to put in visual studio code to get rid of this problem let's do that i really wanted you to see this process you can go through to know what you need to include we're going to put this in and hopefully the arrow is going to go away and we can focus on studying the effects of these things here this is going to print and formatted so the data is going to be cropped close to each other but we can format this using set width and if we pass in a 10 here we are basically saying last name is going to take the width of 10 characters even if we don't really have 10 characters in this so so you're going to have spaces fill the remaining spaces so that the data shows up nicely this is really hard to say in world so i am going to run this in a minute so that you can see this but before we run i want you to see that you can also store the width information in a variable like this and i use that instead in your std statements the benefit with that is that it is really easy to change this with if you happen to change your mind otherwise you would have to change a lot of things and this is really bad design i did this to show you how you can use this but in real code you are most probably going to store your weft information in a variable and that way it's going to be really easy to change and update if you happen to need that we can build this program with gcc and if we run it let's bring this up a little bit we're going to have our data that is unformatted and you see that it is really ugly but down below here we have our formatted table and it is really nice we have last name first name and age and it is easier to see these things we're going to see that it is possible to force the data to show on the left or to the right with justification and we're going to look at code that does that next if we go down here and put in the next piece of code we want to play with we're going to see that data is right justified by default but we have seen this also you see that gray is cramped to the right of the width of the cell for the first name so data is right justified by default and it is the same here if we change the width of our data here and trying to run we're going to have a better visualization of that so let's run a little bit we're going to build the world is going to go through and if we run this we're going to see that data is going to show up to the right gray is to the right woods is to the right and this is the default justification you get when you set with like this you can also cause for the data to be left justified and you do that by coming here and changing this to left you can do that but let's keep this in here instead for your reference and let's put in another piece of code to justify the data to the left okay let's go down and do that we're going to justify the data to the left and if we print this out the data here gray should come to the left and be aligned with the first name here i hope this makes sense we're going to run we build with gcc and if we run rooster gray is going to be justified to the left this is the meaning of std left and std right that we just saw and know that data is justified to the right by default and it is important to keep the defaults in your mind data is going to be justified to the right by default the next thing we can do is to make our data internal justified and what this is going to do is make the sign left justified and the data is going to be right justified and the best way to save this is really to see an example so here we have the data it's a negative floating point number the width is set to 10 it's going to be right justified but we are also going to set the justification to internal and see the difference let's weld and run this we're going to world with gcc and we are going to run our rooster program and if we look at the output here you see that if we have right justification the sign is going to go with the data whereas if we do internal justification the sign is going to go to the left and the data is going to go to the right and sometimes this is useful depending on the application that you are welded especially in applications where you have to display tabular data on the console or of the terminal we can also specify the field character using set field and this is really how it works the data", "22795.039999999997 - 23096.638": "going to fill empty spaces with a dash here and we can bring this up so that you see the entire thing but you don't really have to type this out you can use the code i have provided in the resources section of this lecture you can just copy it paste it in here and use it to play with these things okay with this our empty spaces are going to be filled with this dash character let's world and build with gcc we are going to run this and you're going to see that we have a field character here and you can change this basically to whatever you want if i want i can change this to a star let's do that and i can build again if i run this it's going to be filled with stars right now the next thing we're going to look at is std bull alpha we have seen this before but what it's really going to do is force the output to be in the format of true and false and the default is in the form of one and zero here we have a few variables and that they are of bull type the first set of stdcl statements here is going to print in the format of one and zero we are going to set the output to both alpha and it is going to be in the format of true and false and then we can disable the bull alpha with this setting here which says hdd no pull alpha we can vote this and see the effect of this so we're going to run rooster again and you're going to see that condition 1 0 condition true false condition 1 0 we are able to modify how our boolean data is displayed on the console using these two settings here use them if they make sense for your application the next thing we're going to look at is show pose and we're going to just put in the data we have two numbers positive number which is 34 a negative number which is minus 45 and we can decide if we want to show the plus sign for positive numbers by default the plus sign is going to be hidden it's not going to be shown if you want it shown you can use the show pose manipulator and if you want to disable that when it was enabled you can use no show pose and this is going to do what you want we can build this again and if we look at the output we're going to see that post num doesn't have a plus sign in front because by default the show pause is disabled and we set the setting here and we're going to see the plus sign and if we disable that we're not going to see the plus sign again this is the effect of std show posts and std neutral pose manipulators we can also affect the base in which the data is displayed on the terminal and we do this by setting the output base system we can set std deck to force the output in decimal std hex to force the output to be in hexadecimal and std act to force the output in octal and this is only to take effect for integral types this is not going to have effect for floating point numbers for example here we have a few variables a positive integer and negative integer and a floating point number which is the double and we're going to try and print these things in all these base systems we're going to print these things in the default format we're going to see how they look we are going to take the positive number and show that in these different number systems we're going to do the same for the negative number and we're going to show that this doesn't have effect on floating point numbers because these number systems don't really work for floating points we can run this and see the output we are going to run the task that is going to build with gcc and we're going to clear and run rooster and what we're going to see is that by default positive number is going to be this negative number is going to be this and our double var is going to be this and we are going to take the positive number show it in different base systems in decimal it's going to be like this in hex it's going to be like this in act it's going to be like this the negative number is also going to be in this format here so if we show it in decimal it's going to be like this hex it's going to be like this and octo it's going to be like this you can see that the double var which is a floating point is not really affected it's going to be showing in the same format regardless of the base that we set here one thing you should know is that this base setting here is going to stick so here for example you see that we have set output to octo", "23096.638 - 23397.76": "print out is going to be shown in octo and we have to be sure that's what we want if that's not what we want we will have to reset the output number system and it's going to take effect this is how you can use these things to affect different number systems for output in your terminal we have seen that you can also force things to show up in uppercase if that's important for your application for example here we have a positive number if we show that in hex this is going to contain a few characters and if we don't set uppercase it is going to show up in lowercase and if we want it in uppercase we can set this setting and it is going to show up in uppercase this may be helpful in some applications and i just want you to be aware of these things we're going to world and run our application we're going to see that let's bring this up a little bit so that we have some breathing room our positive integer here is going to show up in lowercase here in hex because this is going to contain characters and if we set uppercase you're going to see that the characters are going to show up in uppercase and this is the effect of this setting here we can also affect how floating point data is printed out on the terminal for example here we have a few variables a b and c and by default they are going to show up with decimal points and use scientific notation where necessary but we can choose to use fixed for example if that's what we need in our application and the output is going to be shown using fixed notation with decimal points if we want we can force the scientific format and we do it like this and all output is going to be in scientific format and we can disable all these settings and reset this to the defaults with this piece of command here there is no official way to set floating point output to the defaults and this is a hack i actually learned about when i was preparing the code for this course and the proper explanations for this are really out of scope for this course so if you want to reset the floating point output format to the default you're going to use this but we don't really have enough tools to understand this yet so just take it by faith and you're going to see that if we run this it's going to work let's try and run this through the compiler and that the world is going to go through if we run this and i bring this up a little bit so that we have a little bit of breathing room we're going to see that our double values are a b and c and that's what we have in our code here and by default it's not going to be able to show these things because of the precision limits so we're going to have 3.14159 it's going to go up to here and the rest is going to be chopped off if we use fixed formats you're going to see that whatever we had in scientific format it's going to show up in fixed format and again this is a really low number that's why we have 0.000 here we can force the output to be scientific as we did right here and all output is going to be in scientific format down below here we use our hack to set to the defaults and you see that it's going to go back to the initial format that we had before this is how you use std fixed and std scientific to manipulate how your floating point numbers are printed to the terminal we have also seen that we can set the precision of our output in the terminal here we have a variable a it is of type double as you can see in a visual studio code here if you hover over a variable you're going to be able to see its type we can choose to see this in whatever precision we want 6 is the default in our case here but we can choose to set the precision to 10 20 or whatever it is really we want please note that this is going to be limited by the precision that your type supports so for example we know that a double has a precision of 15 and if we have more than 15 digits in here the rest is going to be garbage just be aware of that we're going to try and build this and we're going to use gcc as usual and if we run this we're going to get our numbers in different precisions the first one is using the default which is going to be 6. if we use 10 we're going to get 10", "23397.76 - 23696.16": "20 digits but if we go over the precision that our type here supports we're going to get garbage i hope this makes sense the last thing we're going to see is show point and we have seen that this is used to force outputting the decimal point let's say that here and a good example for that is this 12 here if we print it out here we're not going to get the decimal point by default it's going to print 12 but if we go down and force output of the decimal point here we're going to get something like 12.0 and another effect of this is that it's going to add trailing zeros to fill whatever space is allocated for your output variable in the terminal let's try and run this so that we can actually see this running we're going to run our rooster executable and in the first group here we don't have the setting for show point and if you look at the numbers that we had in our code the first number is 34.1 and you see that we are padding a lot of numbers because we had set our precision to a really big number in the last example that we have run let's actually go there and show you that that's why we're seeing the precision of 20 it is really huge but no big deal we can reset this to whatever we want if this is too much for us the important thing here is that we have 34.1 and that's what we are seeing and if you go to our 12 here you see we have 12.0 but our output is not showing the decimal point here if it is important to show the decimal point we can do std show point here and it is going to show up this is really what is important in this piece of code here and this is really all we set out to do in this lecture we had a chance to play with a lot of these manipulators and the best way to learn about these things is really to try them out in code and try to change a few things and see how that affects the output you get in the terminal and we had a chance to play with many of these things in this lecture there is a lot of these guys i tried to make this lecture as extensive as i can that's why it turned out to be pretty long but once you've learned about these fans and played with them in code you're never going to forget them one last point i want to emphasize again is that the documentation is of utmost importance it is really good to come here and check things out for example if we go to show point here we are going to get a nice explanation of what this manipulator does enables all disables the unconditional inclusion of the decimal point character and you can read all this and the nice thing is that if you go down you're going to have a piece of code that you can use to really understand whatever it is they are talking about and this is priceless if you are learning it is a good thing to be able to use the documentation this is really all we set out to do in this lecture it turned out to be really long but i really hope it was worth it for you we're going to stop here in this lecture in the next one we're going to learn about numeric limits go ahead and finish up here and meet me there in this lecture we're going to be playing with a few functions from this library specifically we're going to be looking at the minimum the maximum and the lowest functions and this is really how you use them you can think of this t as a placeholder for the type for which you want to know the minimum the maximum and the lowest point respectively i know this might be cryptic to some of you so we're going to look at a few specific examples here we have a simple explanation of what these functions mean for floating point values the minimum is going to represent the smallest positive number that is representable with that floating point type the maximum is going to be the maximum floating point number you can represent and at the lowest number is going to be the lowest negative number you can represent with that type things change a little bit when you start dealing with integers and these functions are going to look like this the minimum is going to be the minimum number you can represent with that integer and lowest doesn't really mean anything for integral types the maximum is going to be the maximum number one thing you have to keep in mind is that the minimum may be negative if you are using a signed integer if you are using an unsigned integer for", "23696.16 - 23996.557999999997": "zero and the maximum is going to be the maximum number representable with that integer type here we are looking at numbers for short and but the same story applies to whatever integer type you are using even if you happen to be using long end or end without any modifier remember that we had to do a lot of things to get this range and it was really hard to even do this for floating point types so this library is helpful in getting a sense of what we can represent with the given type b8 floating point or integral let's head to visual studio code and play with us here we are in our working folder we are going to copy code from our template project and we are going to go in the current project which is numeric limits we're going to go and put in our files go up again and open this file up in visual studio code we're going to close this up open the main cpp file remove whatever it is we don't need we are going to include the limits library remember this is the first thing we need to do if we want to play with these facilities that we just looked at in the slides and we are going to go down here and put in the code we want to play with and it is ridiculously simple if you have watched the slides we just did in a minute so what we're going to be doing here we're going to be printing out the range for each possible type we want to play with here so we're going to say the range for short and is from and we're going to say std numeric limits short that's what we want to deal with now and we're going to call the minimum function this is going to give us the minimum value we can represent with short and we're going to say std numeric limits and we're going to call the max function passing in the type for which we want to get the range for and the same story applies for unsigned short you see that's the type we are using here we are also going to play with ant getting the range we're going to use unsigned and to see how these things behave we're going to use long and get to the range and we are also going to be playing with floating point types so we're going to compute the range using the minimum function and the maximum function and we are going to be also using the lowest function to see that this really is the same thing we described in the slides we're going to do this for double and long double and see how these ranges come up in this program what we're going to do is open up a terminal here we are going to run the task to build with gcc and the build is going to be good and we can go down and run rooster and we're going to get our values here the range for short and is from minus 32 768 up to 32 767 and you see that this is exactly the same thing we saw in the lecture where we talked about number systems we saw a way you can do this manually by plugging the number of digits in some formula that we came up you can go back and check that out if you want we do the same for unsigned short and and then we look at floating point types we're going to print the range for float and if we use the minimum function to get the start of the range we're going to get the minimum positive number we can represent with a float if we use lowest we're going to get the lowest minimum number and that the maximum is going to be the same if you think this is really small you have the option to open up this folder in file explorer and you can open a command prompt or powershell window by hitting shift and right clicking and choosing this option here open powershell window here and you're going to get a bigger window in which you can type things we're going to run rooster and we're going to see things in a much easier way here this is an option you can use or you can even use the integrated terminal inside visual studio code here like we've been doing all along there are a few other facilities you can use in this library of limits for example we can try and print out if a number is signed or unsigned or get the number of digits we can represent in an integer type these are a few examples i just chose because they are easy to understand and really helpful but you can find more about this library in the documentation", "23996.557999999997 - 24296.878": "the link is here you can really find all about this library here this library provides a standardized way to carry various properties of arithmetic types for example the largest possible value of type and is this and we have a bunch of things we can do here don't be scared of by this template thing just think of them as placeholders for the type for which you are trying to query information for there are a few functions you can call on these things for example there is mean lowest max that we just played with in visual studio code but uh you can see that there are a lot of things you can play with especially if you have some math background to understand all these concepts here you can play with us and see if it is helpful for whatever application you are doing okay this is really all we set out to do in this lecture to learn a little bit about the limits library it is helpful in trying to understand the ranges for your types if you happen to need these kinds of things this is going to come in handy we're going to stop here in this lecture in the next one we're going to learn about some math functions we can use in c plus plus go ahead and finish up here and meet me there in this lecture we're going to learn about math functions and these are functions that are built into the z plus plus standard library that we can use to do some math if you are doing some math operations you're going to find this helpful they live in the c math library and if you want to use them you're just going to include that and you're going to have access to them what you see here is a simple summary of some of the things you can use in these math functions you can use std flower to round down or hdd seal to round up you can use the abs function to compute the absolute value of a number you can do trigonometry you can do the cosine sign and things like that you can compute the exponential of a number you're going to see what this means in a few lectures you can use std log and again if you have some math background these concepts are not going to be foreign to you many of these functions are documented here at cpp reference so it might be worthwhile to go there and check what functions are available there here is an example of something you might want to do for example you have a variable it's called weight inside we have a 7.7 and if you do std floor of this variable this is going to be rounded down to a 7. if you want to round up you're going to use std seal and you're going to get that and we're going to see what this is going to give us in a minute when we hit visual studio code here is how you would use the absolute value function you have a few variables here and if you try to plug them in this absolute value function you're basically going to get the weight of the number without any sign in front of the number positive or negative the absolute value is the weight of the number without caring about the sign if i may say it like that okay we also have the x function which is going to compute the exponential of a number this is a math concept so if you don't have a background in math this is going to be a little hard to wrap your brains around but in math we have this number which is called e and its value is approximately 2.7 18 28 like you see here the exponential function is going to do what f x here is doing it's going to take e and elevate that to the power of x and for example in our code here we're going to get the exponential of 10 which is going to be e elevated to the power of tan and we're going to play with this in visual studio code and you're going to see the value of this we also have the power function here which is going to take the first parameter and elevate that to the power of the second parameter so this is going to be 3 to the power of 4 and 9 to the power of 3 and we're going to get the answer if we plug this into visual studio code and we have look functions which is basically the reverse of the power function that we just looked at if you do log 8 in base 2 for example it is like you are asking to which power should i elevate 2 so that i get 8. and the answer here is going to be a 3 of course but the catch is that the log function by default works in base e so what we are asking for example if we say log 54.59 is to which power should we elevate e to get this number in here and it is", "24296.878 - 24595.84": "see this if you plug this into visual studio code or you can try to use one of the calculators available to you and you're going to see that this makes sense we also have a special function that is going to do the same thing but in base 10 and this is going to be easier to understand for example here we are computing log 10 so what we are really saying is to which power should we elevate 10 to get 10 000 and this is easy because the answer is a 4 10 to the power of 4 is 10 000 i really hope this makes sense we also have a square route function we can use so square out of 81 is going to be nine we have a function called std round which can round and uh what it's going to do by default halfway points are going to be rounded away from zero so if you have a 2.5 it's going to be rounded up to a 3 and if you have 2.4 it's going to be rounded down to a 2. we also have a host of functions we can use in trigonometry we have a sine function we have a cosine function we have a tan function if you know these concepts in math this is going to come in really handy if you want to do this i have to say that what we just talked about is a small set of what we can do with these functions here in c math and uh we are here at cppreference.com and we can see all these functions here we can do reminder we can do f men and if you want you can check this out in the documentation for example if you go to can here and click on it you are going to get the description and explanation of what this function does and you're going to have a simple example of how you can play with us okay now i hope you have a better idea of what we can do with these functions in the cmat library we're going to head to visual studio code and play with some of these functions here we are in visual studio code the current project we're going to work on is math functions we're going to copy over our template files and we're going to put them in our directory here math functions and we are going to open this up in visual studio code and we are going to remove whatever it is we don't need and we are going to include our library which is c math and we are going to put in our code so that we can play with us and here we have a variable called weight and we're going to try and use a few math functions on it so we can use sdd floor to round down and std seal to round up so weighted rounded to floor is going to be printed out and way to round it to seal is going to be printed out we're going to have a number here in this savings variable it's going to be a negative number and we're going to try and compute the absolute value of this we're going to see it printed out another thing we're going to compute is the exponential of the value we're going to do stdx 10 and what this is going to do is going to take e and raise it to the power of 10 and that's what we're going to get printed here the other thing we want to do here is compute the power of a number we're going to take 3 and raise it to the power of 4 and take 9 and raise it to the power of 3 and we're going to see what these things evaluate to we're going to open up our terminal here and we're going to run the task to build with gcc the world is going to be good and if we run rooster we're going to get these things here so 7.7 rounded to floor is going to be seven so we're going to round down 7.7 rounded to sale is going to be eight and that's what we're going to get and the absolute value of weight is going to be 7.7 because it is a positive number and the absolute value of minus 5000 is going to be 5 000. and again when you compute the absolute value of something you are interested in the weight of that thing without considering the sign without really worrying if it is positive or negative you just want to get the magnitude of a number that's what we use in math to mean that magnitude okay so if we go down we're going to get the exponential of 10 is exponential and you're going to get that here and again what this function does is take e and raise it to the power of 10 and that's the answer here we can try and prove this with a calculator so i am going to open my windows calculator you", "24595.84 - 24897.36": "access to i am going to use a scientific calculator here and you see that we can hit e and we're going to get the value of this e number in math here it is simplified but if i take it and raise it to the power of 10 the answer is going to be 22.026 and if we look in our program we have 22 0 26.5 okay it is rounded up a little bit but it is almost the same thing okay we also want to play with log functions a little bit log is basically the reverse of the power function and we just talked about this in the slides but if we do log 18 base 2 we are basically asking to which power should we raise 2 to get an 8 and the answer to that is going to be what this log number in base number is going to evaluate to the catch is that the log function if you use it row like this it is going to be using base e and we just saw that e is 2 to the power of 7 or something let's go back to our calculator and see if we can see that why not why try to guess when we have a good calculator in our hands we are using the scientific calculator so if we hit e here this is the value of e okay so when we do log we are basically asking to which power should we raise e so that we can get this 54.59 and the answer is going to be computed and printed out here we have a version of this that is going to use base 10 so if we use this we are basically saying to which power should we raise 10 to get 10 000 and the answer is going to be printed out here and it is going to be a four because this is easy to do in your mind so let's run this we're going to build the task we are going to run the task to build with gcc and we're going to run our program and uh we're going to get our output here to get 54.59 you would elevate e to the power of this number here this is the answer and if you want you can prove this with your favorite calculator you're going to get something close to this to get 10 000 you'd need to elevate 10 to the power of 4. that's what we're going to get in here let's print this out again many mistakes sorry but i hope you get the point if we build again so that we can see things properly and run we're going to get proper data and this is really what we expected to get we have a few more functions we can play with as we saw in our slides let's play with square root and the std round function here we are going to get the square root of 81 we're going to get it printed down and we're going to see what std round does it is going to round away from zero if we are at half point and if we are not at half point if we are below that we're going to round down if we are higher than that we're going to round up we're going to run this so that you can see this running and we're going to call rooster and the 2.5 is rounded to 3. 2.4 is rounded to 2. 3.6 is rounded to 4. this is what we expect and the square root of 81 is 9. this is really all we set out to do in this lecture to play with a few of these c math function they are not really hard to use once you have the basics of math nailed down and again if you want to check the full list of these functions please come to our reference documentation here you're going to find a lot of them and if you want to see how to use one of these for example if you click on log 10 here you're going to come here you're going to get an explanation of the function and even better you're going to go down and get a nice piece of code you can play with and really make sense of what is happening in these functions here this is really all we set out to do in this lecture i hope you found it interesting we are going to stop here in this lecture the next one we're going to learn about some weird integral types go ahead and finish up here and meet me there in this lecture we're going to learn about some weird integral types and what do i mean by this well if you look here integral types less than 4 bytes in size don't support arithmetic operations and these are operations like addition subtraction multiplication division you can do these operations on those types and here i have an example of some of those types we have a car it is one byte", "24897.36 - 25195.28": "is two bytes in size on most processors so you can't do arithmetic operations if your integer value is stored in these types why is that well this has to do with processor design and they decided to choose and as the smallest type integral type for which they can do these arithmetic operations but compilers are really smart enough to notice if you are trying to do arithmetic operations on these types and they are going to implicitly convert from these smaller types to end and this is something you need to be aware of if we look at this program here for example we have var1 and var2 they are stored in variables that are of type short and and we have var 3 var 4 which are stored in a variable of type car we can try and print the resizes and we're going to get two two one one for these variables because a short end occupies two bytes in memory for my computer here and the car occupies one byte in memory but the catch is down here if you try to add them up the result is not going to be the same type as defense you added up and you would expect auto to deduce to the same type as var one and var2 and it's not resort is going to be an integer because and is the smallest type for which we can support these arithmetic operations so if we print the size of result one and reserved two we're going to get four but this is the behavior you're going to get and we need to be aware of it the same behavior can be observed on other operators that we will have a chance to look at in a few chapters ahead and these are called shift operators you use them to shift bets but i don't want to talk anymore about them because we're going to have a chance to learn about them in detail okay now is time to head to visual studio code and actually see this in action here we are in our working directory we are going to copy our template project we're going to copy this quickly put that in our folder on weird integral types this is our current project here and we're going to open this up in visual studio code we're going to open this up and we're going to open our main cpp file remove whatever it is we don't need and we are going to put in our code this must be very familiar because it is what we just saw in the slides so what we are doing here we have four variables var one and var two are short and so these are going to take two bytes in memory on my computer here and uh car is going to take up one byte and we're going to print their sizes we're going to see them printed down and we are adding things up here we are taking two short end variables and adding them up so what the compiler is going to do it's going to take this turn it into an end and then do addition and the result is going to be an end the same story is going to happen for reserved 2 here var 3 is a car so it is one byte in memory but the compiler can't really add up integral types which are smaller than four bytes in memory so what is going to happen var three is going to be transformed implicitly behind the scenes to a net and var four is going to be transformed to a net and then we're going to add that up and we're going to store that in a neat variable which is resort here if we print this up we're going to see that size of result 1 and result 2 is a 4 and this is what we expect here and this is a behavior you need to be aware of because sometimes your application logic is going to depend on the size of data if that's the case you need to care about this and if you don't know this you're going to be beaten by this and it is really hard to find problems like this so what we can do is open up our terminal and we're going to build this with gcc as we usually do and that we can run our program rooster and we're going to see that this is what we expect var1 is two bytes in size var2 is two bytes in size wire three and waterfall are one byte in size but our result is four bytes because the compiler implicitly converted our operands here to x to be able to carry out this arithmetic operation this is really all we setup to do in this lecture i hope you found it interesting we are going to stop here in this lecture the next one we're going to try and recap what we saw in the chapter congratulations on hitting the end of this chapter and this chapter was really about doing operations and manipulating the", "25195.28 - 25497.28": "variables the first thing we saw was that we could do arithmetic operations on the data we can add things up multiply divide we also saw the modulus operator which may seem weird for beginners but we had a chance to really play with us after that we learned about precedence and associativity we saw that that's a set of rules we have to follow to know which operation to do first if we have multiple operators in our expression we also had a chance to learn about prefix and postfix increment and decrement operators we had a chance to do compound assignments things like plus equal minus equal multiply equal modulus equal now these things must be making sense to you we had a chance to look at how we could compare things using relational operators like greater than lesser than and equal or not equal we also had a chance to look at output formatting and we saw a host of things we could do to make data show up better with sddc out after that we learned about numeric limits and this is a cool way to know the ranges for your data types but there are a host of other properties you can use in this limits library we learned a little bit about math functions and we played with things like the power of something the exponential the few rounding functions that we have in the cmat library and now you must have a good idea about these functions that you can use to manipulate and do math on your variables we ended the chapter by looking at some weird integral types and the main message in that lecture was that you can't do arithmetic operations on data types whose size is less than 4 bytes in memory if you try to do that the compiler is going to insert implicit conversions and if your application depends on the size of things this is something you need to be careful about otherwise you're going to have a hard time finding these problems i would like to welcome you in this new chapter where we're going to be learning about a new way we can do things in c plus plus and we're going to be doing conditional programming in other words we're going to be able to do different things based on the conditions that we have set up in our code just to give you an example here we have a few variables they are booleans and we have a few initializers in there red is false green is true yellow is false police stop is true and we can do different things based on discipline conditions for example if the light is red we may be told to stop if the light is yellow we might be told to slow down if the light is green we might be told to go and do whatever it is we want to do so we're going to be able to do these kinds of things and c plus plus provides different constructs to be able to do conditional programming in uc code we just have one of them in this slide which is this if statement here this if keyword allows you to do things like this we have a few others we have the else keyword we have the switch keyword we also have a completely separate operator that is called ternary operator that allows you to do these kinds of things and we're going to be learning about all these things and more in this chapter we are going to start and learn about the if statement in the next lecture go ahead and finish up here and meet me there in this lecture we're going to learn about the if statement and this is a statement that is going to allow you to do things based on some condition being true or false here is a simple code example we have two variables number one and number two and we have a statement here that is going to compare number one and number two and we're going to store the result in this boolean variable that we have on the left then we're going to do something based on the value that we are storing in this result here if the result in there is true we're going to print number one is less than number two if the result is not true we're going to say number one is not less than number two and notice in the first if close year we are testing for the case where the result is true but sometimes we need to do something when this condition here is not true one way to do that is to negate what we have here inside the if parenthesis and test for the reverse of whatever we have in here if that is making any sense if you look here we are testing for the case where if not the result is a true and in other words we are testing for the case where the result here is false and we're going to say number one is not less than", "25497.28 - 25796.877999999997": "about this again the if statement is used to do conditional programming this is the syntax we use to do it in c plus plus we say f we put a set of parentheses and inside the parenthesis we put the condition we want to test for and after that we're going to have a pair of curly braces and what we have inside these curly braces is going to be the body of our if statement and it is basically going to be the code we want to run if the test here is successful we can also use an else clause to catch the case where the test hasn't been successful in this case we can say if result equals true we're going to do something and else we're going to do something else in other words if research is true we're going to say is less than if it's not true we're going to say is not less than and this is a more compact way of doing what we just did in the slide here you can also directly use your expression as a condition and the requirement here is that the expression evaluates to something that we can treat like a boolean because the condition has to be a boolean it has to be true or false okay here is another simple example we have seen this in the last lecture we have a few variables containing our conditions and we are saying if the light is red for example we're going to do something if it's yellow we're going to do something if it's green we're going to do something we can also nest conditions for example we can put our outer if statement and inside that if statement set up other if statements and if our logic needs something like this you can do this and you can take advantage of this to achieve whatever it is you want to do in this case if the light is green we're going to fall in here and we're going to do another condition so if the light is green and if the police officer has stopped you you're going to stop and if they haven't stopped you you're going to go because the light is green and you can do something like this we can also use logical operators to kind of achieve the same thing and we say if the light is green and the police officer hasn't stopped you you're going to go else you're going to stop and you can do something like this and you see that you can combine the logical operators we've learned about with the conditional programming techniques we are learning about here to do really powerful stuff and we're going to be doing this all over the place in the course so we're going to head over to visual studio code and play with us here we are in our working directory we're going to be working on if statements and we're going to grab our template project the template files i should say and we're going to put them in here and we're going to open this up in visual studio code as we always do so let's do that open folder and we should fall in here and open our main cpp file let's do the usual and remove what we don't need and we are going to put in our code so that we can really play with us we have two variables in here number one and number two they are integers and we have the values 55 and 60 inside we can do a comparison between these two variables and what this comparison is going to yield is a boolean value that we're going to store in our boolean variable here which is called result and what we can do is use this to do some conditional programming so we're going to say if the result is true we're going to do something and if the result is not true we're going to do something else and this is how we say it this syntax here may be confusing to new students but try to think of it if not research is true and that's really the same thing as saying if result is false try to stream this in your mind a little bit and you really are going to understand okay so now that you have seen this piece of code try to guess what we're going to see if we run this what are we going to see on the console okay give it a try so we're going to run this in visual studio code let's open up a terminal first and we're going to world with gcc as we always do we're going to bring this up a little bit so that we have some breathing room and we're going to run rooster let's see what we have here we have reserved equals true and that's coming from this statement here and we have freestanding if statement which is coming from here and we have our meat of this program what we really are interested in we have 55 is less than 60. so our test here succeeded and we fell in this body and executed this sddc out statement that's why we're saying number one is", "25796.877999999997 - 26095.120000000003": "number two and number one is 55 which is what we see here and number two is 60 which is what we are seeing here so what can we do to make the second statement here execute you know it is testing for the case where not result is true so it's going to exactly do the reverse of what this test here is doing and if this fails this one is going to succeed which is what we have now so what we can do to really play with this we can go up and change for example number one to 65 this is going to flip the order of these numbers if i may say it like that and if we run it we're going to build with gcc and run this we're going to see result is false so result became false because number one is not less than number two so this is going to be false and the test here is going to fail result is not true so we're not going to go in here and look at here if not result is true so research is true is false if we negate this this is going to become true and this test here is going to succeed and we are going to fall in here take some time to really understand this and if you have a problem ask me i am going to do the best i can to help you out but make sure you understand this because this is really fundamental in your journey as a software developer not just in c plus plus any career as a software developer you're going to need to understand this okay what we're going to do is comment out what we just did here because we're going to see another way to do this and we don't want to have noise output in our terminal this is going to just make things hard for us to see so what we're going to do we're going to go down in here and put in another piece of code and the result was commented out we don't want to comment that out so we're going to take this out because this is our condition we're going to grab it and put that outside our comment section this is going to do and if we go down again we're going to click on this file icon and uh give ourselves some more breathing room here we don't really need to see that main cpp file anyway so if we come here we can use the else clause to test for the case where our condition fails and if you look here we are essentially saying the same thing we are saying if result equals true we're going to fall in here and else we're going to fall in here so we don't need to do the double if statements that we just did here and this is much more compact and easy to read let's look again at the numbers we have here number one is 65 number 2 is 60. this expression here is going to be false because 65 is not less than 60 we're going to have a false in here and if we come down result is going to be false this is going to fail and we are going to fall down here we're going to say number one or 65 is not less than 60 which is what we have in our values so we're going to build this again and we're going to run rooster that's clear so that we have some breathing room we're going to run rooster and you're going to see that 65 is not less than 60 which is what we expect again if you go up and change these numbers to whatever you want try to change these numbers to different values to see what you get as output if we do this we're going to see that number one is less than 60 so this is going to be true and we're going to have a true in this result variable here if we go down result is true this test condition here is going to succeed and we are going to fall in here let's click in our terminal and hit enter we're going to run rooster we're going to see 55 is less than 60 which is what we have here okay now i hope you have a better idea of how you can use the else close to make your if statements really compact and this is really cool okay another thing i want you to see is that you can not go through a variable like this and use an expression as a condition directly c plus plus allows you to do this so what we're going to do we're going to comment out what we just did let's do that i'm going to use a block comment i hope you know how to use this already and we're going to go down and put in our code it is exactly the same thing but we took the expression and put that in the place of our condition variable here because this is going to evaluate to a boolean anyway so we can use this as a condition and this is something very legal to do in c plus plus so if we run this we're going to see let's see what we have in the numbers i have forgotten by now so 55 number one sixty number two number one is less than number two this is going to be true so the test here is going to succeed and", "26095.120000000003 - 26396.718": "we're going to say we're going to weld with gcc as usual and i'm going to clear and run rooster and you're going to see that this is the output we expect if we change up the numbers again let's take this and make it a 75 number one so number one is less than number two is going to evaluate to false the test here is going to fail and we are going to fall in this block here we're going to fall in the else close of our test here we're going to say 75 is not less than 55 is that what we have in there it's a 60 but this block here is going to execute that's the most important thing so we're going to run this and we're going to try and clear and run rooster we're going to get what we expect this is one way we can do this and it is really cool let's comment this out and see another example and if we go down we can see the example we saw in the slides which was using red green and yellow to simulate a traffic light so what we really want to see here is that we can nest stuff but before we do that we need to try and use these conditions because it is just fun so if red is true meaning that the red light is on we're going to stop if yellow is true we're going to slow down if green is true we're going to go and if we look at what we have here red is false green is true false is true and a police stop is true police stop is not really being used so green is true we're going to execute the green statement here and we're going to say go that's what we're going to say let's try and run this we're going to build with gcc bring this up a little bit so that we have some breathing room and we're going to clear and run rooster and you see that it is saying go here you can try and change these boolean variables to different things and see what is printed out here this is a great way to learn but what we really want to try here is nested statements and let's go down and do that okay again we don't want what we have on top here to disturb us so we're going to comment this out and we are going to go down and put in our code for nested if statements so what we're going to say is if the light is green we should go but the police officer has the right to stop us even if the light is green at least these are the laws in the country where i leave so we have a variable called police stop here so if they stop you even if the light is green you're going to stop and we're going to see what we see here so if the light is green we're going to fall in this body again and we're going to run this inside or nested if statement and if the officer has stopped us we're going to stop if they haven't stopped us we're going to go and go on our merry way this is what we want to see here and again i want you to stop for a moment try to run this through your brain and try to come up with the value we're going to see when we run this in visual studio code pause for a minute we're going to run this we're going to build with gcc and we're going to run a program and you see that police officer stops stop and why is that the light is green okay so we we should usually go but the police stop variable here is also true so if we fall in here this is going to execute and it is going to succeed and we are going to say stop and once this statement executes the else statement is not going to execute control is going to fall outside here and we're going to keep doing whatever we have outside this if statement here this is really critical to understand if one block of a statement succeeds all the others are not going to execute and try to really understand this okay we have seen this we can now comment this out because we have something else i want to show you we're going to comment this out and that's that you can combine the if statements here or conditional programming with the logical operators we have learned about earlier in the course and do really powerful stuff for example here we can actually not use this nested statement and do this in one go like this and i think this is much cleaner so we're going to say if the light is green and the police officer hasn't stopped us we're going to go and if they have stopped us we're going to stop and you're going to see that we're going to get exactly the same result that we had before but this is really much more compact so we're going", "26396.718 - 26697.199999999997": "we're going to clear clear and run rooster you're going to see that they're going to stop us and this is really cool you can go up again and change up these variables to really anything you want and see what you get trying to really understand what is going on here it is not difficult and the if statement is really fundamental to any programming you're going to do so this is really all we set up to do in this lecture to learn about conditional programming using the if statement it is a powerful thing and you're going to see it all over your software development career so make sure you really understand this but even if it's not clear now we're going to have a chance to do many examples and you're going to really understand what this is all about we are going to stop here in this lecture the next one we're going to see how we can use the else if close go ahead and finish up here and meet me there in this lecture we're going to learn about the else if close that you can attach to your if statement and that's going to allow you to test for several conditions in your if statement and to really understand this suppose we are building a drawing application and at any given moment the user might be using the pan or the marker or the eraser already whatever tool that it is we provide in our application and if we want to draw we need to know which tool is currently selected by the user and we can do a piece of logic like this we can have the tool stored somewhere in our application and when we get to the moment where we want to do something for example when the user clicks with the mouse and they want to drag and start doing things then we're going to test for the current tool if the tool is the pan we're going to use the settings for the pen if the tool is the marker we're going to use the settings of the marker and we're going to keep doing this and select one tool that is actually selected as the current tool by the user and when you do something like this only one block in this whole chain of statements is going to execute so for example if we have the marker as the current tool the code inside this block is going to execute and say active tool is marker but nothing else in this block is going to execute after we run this statement control is going to jump at the end of this whole chain of if and else if statements here i really hope you understand this and uh this is really powerful stuff for example this is one of the applications i have done in one of my advanced course about qt and c plus qt is a framework that allows you to do graphical user interfaces like this and you can build applications like this so what i did here is i did the exact same thing that we have here i had the chain of if and else if statements and whatever tool was selected as the current tool was used to draw things on the canvas here for example if the current tool was the pen and the pen is this little pen tool here if it is active we're going to draw things like hello world here if we have the star selected we're going to draw stars if we have the rectangle selected we're going to draw rectangles we could do all kinds of crazy things using this piece of logic here but it is powerful stuff and you really have to make sure you understand this so this is how the else if clause can really help you the main thing is to allow you to test for several different conditions you could do this with a lot of if statements but that's not going to be really cool it's going to be ugly and hard to read this is what you should do now that you have an idea about this we're going to head to visual studio code and actually see this in action here we are in our working directory we're going to grab our template project pretty quick and we're going to use the else if project here that's our current project so we're going to do that and open this up in visual studio code as we always do we're going to open this up we're going to open main cpp and we're going to remove what we don't need the first thing i am going to do is to put in a set of variables that are going to store our tools and we can do something like this we have a variable for pen marker eraser rectangle circle and ellipse i have to say that this is not the way to go about this we're going to learn about another way we can do this but that's going to be there in the course when we have enough tools to understand this for now we're just going to be happy with this okay 10 is going to represent the pan 20 is going to represent the marker 30 is going to represent the razor and we can go on until we hit ellipse which is represented by 60. now if we go in main and set up a variable and call it tool for example and initialize it with whatever tool we think that the user is currently using for example we can use", "26697.199999999997 - 26995.44": "a chain of s and else if statements to do whatever it is we want to do when this tool here is selected okay we're going to go down and put in our code i don't want to type all this so i'm going to put this up here and if you want you can copy the code from the resource section the code is going to be there you can copy it and paste it in here and do things with that okay we have a chain of if and else if close is in here and the first one is going to test and see if the tool is the pan and notice that we are using double equal signs here this is what you use to test for equality you don't use one equal sign you have to use two equal signs if you use one equal sign that's going to be an assignment and this is going to always evaluate to true so you don't want to do that again to test for equality you're going to use double equal signs in c plus plus so if the current tool is the pen we're going to say active tool span if the current tool is marker we're going to say that so we are basically going to do this for all the tools that our application supports so what do you think we'll see when we run this the active tool is circle so we should print active tool is circle here let's try this out we're going to open the terminal so that we can see the output nicely and we're going to world with gcc and the build is going to go through if we run this we're going to see active tool is circle you can go up here and change the tool to rectangle for example if you build again you're going to see that the correct block of code is going to be executed we're going to clear and run rooster active tool is rectangle if we try to put in something that doesn't exist let's say let's put in bird just to mess with our compiler here we're going to get a compiler error because that type is not known by our code here so we're going to get bird was not declared in this scope we don't know what it is you have to put in whatever thing you have declared beforehand here so if we put in a razor for example we're going to weld with gcc the world is going to go through going to clear run rooster the tool is going to be eraser and this is exactly what we expect again the main message in this lecture is that you can use this else if close if you have several conditions that you want to test for just like we have here and again one of these blocks is going to execute and once we hit the end of this chain of if and else if closes we're going to fall here and code after that is going to execute so let's say moving on so that you can really see this here very clear moving on and if we bolt this we're going to see only one block from this whole chain and once one block executes control is going to go after all this chain and execute whatever is after that so we're going to say moving on after we print that the active tool is eraser here i think we have built this so let's try and run this and you see active tool is razer and moving on so after we print the code from the eraser block we're not going to execute rectangle or a circle or ellipse it's going to jump at the end of this whole block this is really what i want to be super clear and again make sure you understand the syntax here the else if statement is followed by a set of parentheses and inside the parenthesis we have the condition we want to test for the condition has to evaluate to boolean and after that we have the block of code that we want to execute and this is really all you have to do to get this to work to your advantage we are going to stop here in this lecture in the next one we're going to learn about switch go ahead and finish up here and meet me there in this lecture we're going to learn about the switch statement and this is an alternative way to do what we did with these else if clauses in the last lecture basically testing for several different conditions but it's going to be in a much more compact way than what we did in the last lecture we are going to be using the exact same example we did in the last lecture and we're going to look at the switch statement and how it works in c plus plus and this is how it works we have our variable which is going to store the current tool and we're going to say switch inside the parenthesis here we're going to pass the variable that we're going to be basically switching on or testing the conditions on and inside the block we're going to be basically testing for each case so we're going to say if the current tool is the pan we're going to say case pan we're going to put a colon in here and we're going to put the code we want to execute for the case where the current tool is the pan in these curly braces here and one thing", "26995.44 - 27296.638000000003": "break statement here this is a statement that tells c plus plus that after we successfully execute a block of code we're going to jump out of this switch statement if you omit this break statement everything after the case that you just executed is going to execute and that's not probably going to be what you want if this is not making sense yet please bear with me you're going to see it run in visual studio code and you are going to understand so what you're going to do you're going to put all the tools you want to test for in separate cases you see here we have marker and after that you can put a default case that is going to be matched when nothing has been matched in whatever it is you have tested for in this switch block here and when we run this piece of code we're going to get exactly the same results that we had in the last lecture but hopefully you can see that this is much more compact than the series of else if closes that we had in the last lecture again the break statement is really useful if you don't put it in c plus plus is going to be confused and after you hit your successful case everything after that is going to be executed so the break statement is basically telling c plus plus if you hit it after a successful case is jump out of this switch block because you are done you don't have to do anything else in here and another thing you should know is that the condition which is what we have inside this parenthesis here can only be an integer or an enum so basically it can be ant long unsigned or car basically every integral type we have seen before but it can't be another type such as string because that doesn't really make sense so be sure to keep this in mind now that you have an idea about this switch statement let's head to visual video code and actually see this in action here we are in our working folder the current project is going to be switch so we're going to grab our template files and we're going to bring that in here i'm going to go up a little bit and open this up in visual studio code as we always do and we're going to open up our main file we're going to get rid of what we don't need we are going to go outside the main function here and put in our tools just like in the last lecture we are using integers each one is represented by 10 20 30 up to 60 and these are the tools we have and i don't think i explained this but we are flagging them const because we don't want them to be modifiable we have seen about const earlier in the course we are going to jump into main and set up our variable it's going to be ant and we're going to call it tool and we're going to initialize this whatever tool we want let's use eraser why not and then we're going to put in our switch block we're going to say switch and if i type this you see that visual studio code is going to give me intelligence or suggestions on what thing i could do one cool thing that visual studio code does is give you snippets to really help you type things out so we can click on this and it is going to auto complete a starter version of our case and we can type in our expression here which is going to be what we're going to be switching over so we're going to switch over the variable tool here and we can put in our cases so in our case we're going to start with pan which is what we have here so we're going to say case pan we're going to remove all this uh let's remove this and say pen i'm going to put a column and we're going to put a block of code that is going to execute when the current tool is the pen and we're going to put that in here let's bring this to the right a little bit and inside the block we can say sddc out active tool is pan okay so after that we're going to put this break statement if it's not here we're going to have a problem because when the current tool is the pan and this code here executes every case after that is going to execute and that's not what we want we have to remember to put this break statement here okay so we're going to put in all our other cases so we're going to copy this and look at the next one it's going to be marker so we can go on the next line and put in marker we're going to paste this in we're going to say marker and we're going to say active tool is marker and we can keep doing the same thing we're going to go download them and paste this in the next one is going to be eraser so let's do that we're going to say eraser and we're going to say current tool is razer and we're going to go down again i am doing this live because it really is important for you to see me type this otherwise you may be confused because this is a slightly confusing construct", "27296.638000000003 - 27595.52": "rectangle so we're going to use that and we're going to say current tool is rectangle the next one is going to be circle and ellipse so let's do that we're going to put in circle we're going to go down and paste this in and bring this back a little bit and i'm going to say circle and we're going to go down and put the next one in which is going to be ellipse and after that notice that video studio code also inserted a default block and this is a block that is going to execute when none of the cases here is head so this is really important so you can also add a block of code and say no match found okay so we want to see this print out and we're going to try this out in a minute okay after we do this we should get this to work and do whatever we were doing in the last lecture so the current tool is going to be razer the block here is going to be matched so code here is going to execute after that we're going to meet this break and what it's really saying is you have done what you have to do jump out of this switch block here and we're going to go to the end of this switch block and we're going to execute whatever is after that so just like in the last lecture we can say moving on and if we execute the program as we have it now it's going to say active tool is razor and it's going to print moving on let's bring up the terminal so that we can really see this and we're going to build with gcc the world is going to be good and if we run rooster let's clear a bit we're going to see that active tool is a razor and we are moving on this is really cool and it is exactly the same thing we had in the last lecture but now we are using a much cleaner construct which switch provides okay we can try to change the tool and see that this really works we can put in circle why not i'm going to build with gcc the world is going to go through as you see here and if we run rooster we're going to see active tool a circle we are moving on you can try and change this however you want if we put in ellipse and world again we're going to build with gcc and if we run we're going to get active tool is pan and moving on why is that ellipse we are saying active tool is pen we didn't change that so we just code a really bad bag here so let's fix this and we're going to build again i'm glad i found this so we're going to clear and rooster and we're going to see active tool is ellipse and we are moving on okay so let's see what could happen if you forgot your break statement after your case here so the current tool is ellipse and it is the last thing we have in here so it's not a good test case what i am going to do is make the current tool the pen or the marker let's use marker that's going to do and i am going to remove the break statement here okay so and i am going to remove all the bread statements we have until we hit the last default case so we're going to go down and we're even going to remove that for the default case here and if we both we're going to build fine you're going to see that the world was good but if we run this try to guess what we're going to get the current stool is the marker so we should print marker and hit the end of the switch block and do moving on but let's see what we get did we build let's build again just to be sure so we're going to run rooster and notice what happens active tool is marker active thought is eraser active tool is rectangle we basically print every other case after the macro case is head and if we try to change this for example not use marker and use eraser let's change this you're going to see that we're going to match the eraser case and everything after that is also going to execute and it is not what you want so let's clear and run rooster you're going to see eraser rectangle circle ellipse and no match found so you have ready to remember to put in this brick statement i am going to hit ctrl z a couple of times and bring those in and i think this is enough we have to hit again so that marker also has it and if we run now we're going to get what we expect let's try to use an eraser again and if we both again and clear and run rooster we're going to see active tool is razer and we are moving on this is what we expect okay this is really how you work with a switch block you have to pass in your expression or your test case and you", "27595.52 - 27897.52": "here you say case you pass in whatever it is you want to match and you put a column and you put your code inside this block here and remember after each case you have to add this break otherwise everything else after this is going to execute and it is not going to be what you want before i let you go i want to show you that you can actually group these case statements if this is what is making sense for your application so for example for rectangle circle and ellipse this can be grouped into the group of shapes so we can actually say case rectangle and uh put them on different lines something like this so let's delete this and say case rectangle and we're going to delete the other things and say case circle just like this and we're going to say drawing shape i think this syntax is supported in c plus plus okay so let's try in world and uh we're going to world with gcc and the world is going to be good so if we have a razor which is what we have in here we're going to say drawing shape let's clear and run rooster you're going to see drawing shapes moving on we have grouped different cases and handles them with one block and this may come in handy in some situations one thing you should keep in mind is that there are limitations on what you can use as an expression or a condition in your switch statement and that has to be an integer something like ant car unsigned shorter things like that we have seen all of these things but it can also be an enum but enam is something we haven't learned about yet we will learn about it later when we have enough tools to understand that but know about this limitation so if we can in our project in visual studio code for example and say std string name and say john for example and use this as a switch condition or expression we have to include string for this to work so let's go up and include the string library we're going to do string and if we go down again and try to do switch and use name as an expression and take out everything we have in here and try to compile this you see that the compiler is not happy okay it's going to say expression must have an integral or enum type so this is not even going to compile this is a limitation you have and you have to make sure what you pass as a condition here is an integer something like ant or car or other integral types we have learnt about in this course this lecture we're going to learn about ternary operators and this is an alternative way to do tests with the if statement suppose here we have a variable called max we have two variables called a and b and we want to find the maximum between these two things one easy way we can do this is say if a is greater than b we're going to store the maximum in max else then b is going to be the maximum and we're going to store that in our maximum value and we're going to print this out if we do this we're going to get whatever is the maximum between a and b to be printed out on the console and this is going to work really well but we can also use a ternary expression and the ternary expression looks like this and it starts with a pair of parentheses you're going to put your condition inside the parenthesis you're going to follow that with the question mark you're going to put your option one and after that you're going to put a column and option two and because this is a statement in c plus plus we're going to end this with a semicolon here is an equivalent version of that using f as we have been doing all along so we say if condition results equals option one if condition is false result is going to be equal to option two and this is exactly the same thing we are doing with our ternary expression here if the condition is true we're going to take option one and assign that to result if it's false we're going to take option two and assign that to resort so this is really a syntactic sugar or a shorthand for this thing here and it's going to make your code shorter and you're going to see this all over the place in c plus plus code out there so you really need to be familiar with this okay so here is our example of computing the maximum you see that we have the same variables max a and b but we have a one liner that is going to store the maximum in max and we can print this out and hopefully you can see that this is shorter and better than this okay one", "27897.52 - 28195.68": "option one and option two should be of the same type or at least the types must be convertible and if that fails you're going to get a compiler error we can also do ternary initialization here we have a boolean called fast we initialize this to false we can use this to initialize our speed variable here we are basically saying if fast initialize this with 300 if not fast initialize this with 150 and we're going to print the speed here and this is going to work and here you see that i lied a little bit in my explanation to make it really obvious what we had in our ternary expression you don't have to always wrap your condition in parenthesis but it makes the code much cleaner okay now that you have an idea about distance it's time we headed to visual studio code and actually tried this and so for ourselves okay here we are in our working folder the current project is ternary operators we're going to grab our template files and put those where they belong it is in this lecture here on ternary operators and we're going to open this up in visual studio code as we always do we're going to open this and we're going to open main cpp and take out whatever we don't need we are going to go down and put in our test code we basically have a few variables let's kill these spaces so that our code is not cluttered here and we're going to print our maximum and we're going to be using a regular if we have three variables max a and b we are saying if a is greater than b we're going to store the maximum and max otherwise we're going to store b in max and this is going to allow us to print whatever is the maximum between 35 and 20. if we build this let's bring up a terminal and we are going to build with gcc as we always do let's bring this up a little bit and we're going to clear and run rooster we're going to see that the maximum is 35 if we put our maximum in a beam we're going to get the maximum steel so we're going to run this out to build with gcc and we're going to run this clear rooster max is 200 so we're going to get the maximum regardless of where it is stored in a or b this is how our code works but we can use ternary operators to do the same thing so what we're going to do here we're going to comment out our if statement and use a ternary version so what we're going to do we're going to say result equals and we're going to say a greater than b we're going to put a question mark to signal the start of our two options option one is going to be a because if a is greater than b then a is going to be the maximum so we're going to grab a here and if a is not greater than b then b must be the maximum so we're going to put that as a second option here this is what we mean with this statement and we don't have a variable called results that's why we have a problem here we're going to put our result in max and this should solve this problem you see the squiggly lines go away and we can build this and we're going to get exactly the same result so this is our ternary operator if we build this it is going to go through and if we run this we're going to get exactly the same result max is 200 and it is what we expect okay so take some time and really make yourself familiar with this syntax it is really nothing complicated you just have to make sure your brain is aware of something like this and you're going to recognize that everywhere you see it in code out there okay we have mentioned that you can't pass types that are not compatible and the requirement is that a and b be of the same type or at least types you can do conversions between so for example if we try to do something like pass a hello in here we can't really turn a strength into a integer and this is going to give us a compiler error and let's look at the error we see from visual studio code operand types are incompatible and and the const car are not compatible and they have to be compatible if we ignore this and go ahead and build we're going to also see an error from the compiler and it should be the same error so operands to question mark and column have different types and and cost car and they have to be stands you can really compare so for", "28195.68 - 28497.84": "and put in a floating point let's put in a 22.5 and say that this is a fluid you're going to see that the problem is going to go away here let's wait for a minute it's not going away we're going to build anyway you see the world is good we're going to clear so that we don't have all this clutter you see problems by the way and if we both again let's try to do that the builder is going to go through and if we run this we're going to get max is 22 because we are comparing a and 22 here and the compiler inserted an implicit conversion from this floating point to integer that's why we are seeing this here so what is the type that's the compiler really used here okay to make it really clear what is going on we're not going to use max here let's say auto max one and see what the compiler is really deducing to so we're going to take this out and by this we're going to see what implicit conversion the compiler really did here because what we had before we were doing an assignment so whatever was on the left was being turned into an integer because we were doing an implicit conversion from an assignment so whatever is on the left is turned into the type of whatever we have on the left of the assignment i hope you know this already but if we do things like this we're going to deduce whatever is on the left and assign that into max one so we're going to do so we're going to see the implicit conversion that the compiler did in here and it is good to be able to see things like that it is a curiosity thing so let's see what happens here we're going to print max one and i'm going to world with gcc this is going to go through and we're going to see what is printed so let's run rooster and you're going to see that the implicit conversion happened from end to flood and we deduce the flood here in max one so this is really interesting one might have thought that we had a conversion from float to end but it was actually the reverse and this is quite interesting this is really all we set out to do in this lecture i hope you found it interesting again make sure you have this syntax here drilled in your brain because you're going to be seeing this a lot in your career as a software developer not only a c plus plus developer actually and it is going to be helpful for you to know this congratulations on hitting the end of this chapter this chapter was all about flow control and we had the chance to learn about many of the tools that c plus plus provides to do conditional programming and we were able to see all kinds of crazy things we had the chance to do things like if red is true we're going to run the code inside if yellow is true we're going to run code inside if green is true we're going to run code inside and you had a chance to play with those things on many occasions we have seen that the tools that c plus plus provides really revolve around these four things here we have if statements we can do else closes on this if statements we can do else if to really do long chains of things where we do different decisions to do things in our applications we also saw that switch is an option if you have several decisions you can make in your application and we saw that a ternary operator can really be used to do two decisions if you have two decisions you're going to be able to reduce the number of lines you used to do these decisions with to one line and we had a chance to really look at that in detail in the lecture on ternary operators this is really all i had to share in this chapter i hope you found it interesting we are going to stop here in this lecture in the next chapter we're going to start and learn about loops go ahead and finish up here and meet me there in this chapter we're going to be learning about loops and this is a construct that is provided by the c plus plus programming language to allow you to do repetitive tasks relatively easily suppose we have a task to print a message 10 times we can go down and do it like this and it is going to work but what if they try and tell you do this 100 times then you're going to start scratching your head you're going to type this 100 times and you're going to run your program and it is going to work then your manager comes up and they say i want you to do this 10 000 times or even 100 000 times and then you're going to start pulling your hair or running around breaking vents because that's impossible to do not to worry here c plus plus provides a way to do this relatively easily and we're going to be learning about ways we can do this in our program in this chapter the constructs we're going to be using are these you see here there is a for loop a range base for a loop a while loop and", "28497.84 - 28796.320000000003": "these tools to not go crazy printing a message one million times because that's really bad okay so that's what we are up against in this chapter we're going to be learning about these loop constructs and you're going to find that they are really cool for your application i am excited to be teaching you this so let's get started in the next lecture and learn about the for loop go ahead and finish up here and meet me there in this lecture we're going to learn about four loops for loops are one of the constructs we have in c plus plus to do repetitive tasks they allow us to do something like this much more easily for example we don't have to type stdc out of c plus plus 10 times or 100 times we can do this in less than five lines and you're going to see how cool this is the syntax for for loops looks like this and it may look intimidating for first users but we're going to break this down we have a few parts in here the first part is the iterator which is a variable that we're going to be using to navigate through the loop and that variable is this unsigned int i here we are going to initialize this to zero and the value we initialize this with is going to be our starting value and that's another key point of any loop any loop is going to have a starting point we are also going to have a test which is going to control when our loop ends for example this loop is going to start with i equal to zero it is going to keep doing stuff until i is no longer less than 10. as long as i is less than 10 it's going to keep doing whatever it is we want to do and the first part of the loop is this plus plus i thing here and this is an incrementation part that's how i'm going to call it for simplicity but at least a part that keeps changing our iterator to make our loop move forward after these four points we are going to have a pair of curly braces and inside these curly braces we're going to have the body of our loop and this is the code we want to execute multiple times and inside this loop body we can really do all kinds of crazy things you're going to see how cool this is again we have a few parts with our loop we have our iterator which is this variable i here we're going to be initializing this with a value that denotes where we want our loop to start we then have a test which is going to control when the loop is going to end we're going to have our incrementation part which is going to allow our loop to move forward and it's going to be doing that through incrementation or decrementation but to make explanation easier here we're going to call this part the incrementation part of the loop after that we're going to have the body of the loop and it's going to be within this curly braces and it's going to be whatever it is we want to execute inside this loop okay these are the parts of a loop and you need to keep this in mind okay now that you know the main parts of the loop how does it really work let's go through this and see how it's going to print i love c plus plus 10 times so when this code gets executed we're going to start with i equal to 0 because that's what we are initializing this value with after the incrementation part we're going to run the test and the test is going to say is i is 0 less than 10 and that's going to be true so if the test turns out to be true we're going to jump into the loop body and if it's false we're going to jump to the end of the loop and execute whatever is after our loop this is how it works so if we jump in for the first time when i is 0 we're going to print i love c plus plus for the first time then after the body is executed we're going to execute the incrementation part this is going to make i equal to 1 then we're going to come back to the test we're going to say is 1 less than 10 that's going to be true we're going to come in the body and print i love c plus plus for the second time after that the incrementation part is going to run we're going to have a 2 inside i here 2 is less than 10 this is going to be true so we're going to follow him the body again and print i love c plus plus for the third time we're going to keep doing this until we hit nine for example if we increment and get a nine we're going to form the test and say is nine less than ten that's going to be true so we're going to fall in here and print i love c plus plus again and after that we're going to run the incrementation part again this time i is going to become 10 we're going to do the test 10 is not less than 10 so the test is going to fail and we're going to fall on the outside of the loop here and by that time we'll have printed i love c plus plus 10 times", "28796.320000000003 - 29095.52": "the first time we're going to run this initializer part here to initialize our iterator which is this value i and then after that we're going to run the test if the test is good if it's successful we're going to fall in the body we're going to execute whatever code is in the body and after that we're going to keep doing the cycle increment test the body increment test body increment test body until we hit a point where the test fails and if the test fails we're going to fall outside this for loop here we're going to execute whatever is after this closing curly brace and this is how a loop works i want you to go through this one more time by printing i love c plus plus and making sure that this is printed 10 times and one thing you should have noticed now is that we use this test to control how many times the loop is going to start for example if we wanted it to run 20 times we would start from zero and and at 20. and you don't always have to start from zero you can really start from anywhere for example you can initialize i with a value like 30 and end when i is equal to 55. let's say that as an example you can really do anything the main important thing is to understand how a loop works one thing i want you to notice is that we are saying unsigned int here to declare our iterator iterators are a common thing in c plus plus code and they're not just used for loops like we are doing it here there is a type we use to do iterators and it makes our code much more readable and that's called size t this event is a representation of some unsigned and type in your c plus plus compiler this is going to be different from compiler to compiler but for example on my system this is eight bytes so it has quite a good range of values you can put in there if we use size t type to declare our i iterator here we're going to say something like this for size t i we're going to put our curly braces we're going to put a semicolon we're going to put our test and we're going to put our incrementation part and i think i really emphasize this but the parts of our loop inside this parenthesis are separated by semicolons like this so we have the iterator declaration we have a semicolon we have the test we have a semicolon and we put our incrementation part and then we go on and put our curlies and inside we can do whatever it is we want to do inside the loop so size t is something you're going to see a lot make sure you know what it means remember that it is a representation of an unsigned and type so it can only represent positive numbers and it is used to represent things like sizes in c plus plus thank the number of students in a classroom for example that can never be negative think about the number of seats in a car that's something that is always going to be positive and it won't make sense for that to be negative so for those kinds of things we can use size t to represent the size of those things and you're going to see how this works in a minute okay now that you have a pretty good idea about how a loop works and the main parts that make it up i want you to know that you can also do all kinds of crazy operations inside the body of your loop for example here we are printing out the current value of our iterator and we're going to print the double that we can do this we can also leave out the curly braces and this is only valid if we have one statement we want to run in the loop so this is going to print this message here five times because this loop is going from zero all the way to four it is going to stop when i stops being less than five and this is going to be five times if you go through this you're going to see that this is going to print five times you should also know that this iterator that we are declaring like this is going to be scoped inside the body of the loop so you can only use it inside these curly braces and if you try to use it outside for example here after the closing curly braces of the body of the loop you're going to get a compiler error again you can only use this variable i which is our iterator inside the curlies that mark the start and the end of our loop body if you want the iterator to be usable outside the scope of the for loop you can do something like this you can declare your iterator outside the loop and you can initialize that with whatever you want and then you can set up your loop like this you can say for j and put and your test and your incrementation part and inside do", "29095.52 - 29396.718": "body of the look if we do it like this then j is going to be usable outside of the loop and we're going to see its value if we print it out like this so this is also something you can do you can even go all crazy and leave out the declaration part if you happen to have the iterator declared outside so if you do something like this it is also going to work okay the last thing i want you to see before we head over to visual studio code and actually try this out is that it is a bad thing to hard code your values in for example you see here we are saying j less than 10 this is really bad design because every time you need to change the number of times that your loop is going to run you're going to have to hunt for these loops and change these values and this may be in a lot of places in your code so a good thing to do is to put the value that controls how many times your loop is going to run in a variable like this we're going to store that value in this count variable notice that it is of size t because it is a representation of the size of things something we don't really want to be negative and we're going to use this in our test part of our for loop here instead of saying j less than 10 we're going to say j less than count and if we want to change this we have one point of control to go and change this value here and this is really good design you should do this okay we have talked a lot about loops it is time we headed over to visual studio code and actually tried these things out here we are in visual studio code the current project is for loop here we're going to grab the code from our template project and we're going to put that in place here and we're going to open this in visual studio code so let's do that pretty fast for loop that's the current project we selected and we opened this in visual studio code we're going to open up our main cpp file which is going to show up here and we're going to remove things we don't need here so let's remove that okay the first thing i want you to do is the bad way to do things again if we want to print i love c plus plus 10 times we can do it like this and if we run the program it's going to work but this is really bad design because you would have to copy and paste this for example a thousand times or even a hundred thousand of times and that's really bad so if we bring up our terminal and build with gcc like we always do the build is going to go through you see it's successful we're going to clear and we're going to run rooster and it's going to say lfc plus plus 10 times if you count this it's going to be 10 times because that's what we're doing here but this is really bad design you don't want to do something like this so we're going to comment this out and do this better using a for loop let's say that this is the bad way and we're going to use for loop which is the good way sorry so we're going to start by declaring our iterator so we're going to say for we're going to say size t let's use unsigned end to show you that you can use that and we're going to say i and we're going to initialize this with a zero and this is going to be the declaration of our iterator this is the first part we have in this parenthesis here we're going to put in a semicolon and put in the test we want the loop to run ten times so it's going to run from zero to nine we're going to stop when i stops being less than ten this is one way you can understand this after we have our test and we're going to put the incrementation part which is going to change the iterator to make the loop move forward and we're going to do that by incrementing our iterator after that we're going to put a pair of curly braces not angle brackets and we're going to fall inside the body of the loop this block here delimitated by the curly braces is the body of the loop and inside here we're going to put whatever we want the loop to run so we can go down here and say i love c plus plus 10 times let's say that but before we do that let's say i so that we know the current iteration where we are at and we're going to put a column and say i love c plus plus this is going to be better to follow in the terminal i guess and we're going to put in our new line character move to the new line and we need to put our stream output operator here for this to make sense to the compiler and this is our loop now if we run it we're going to see exactly the same thing like this but we're going to have these iterators prepended to the message so that it becomes easy to follow this and again how this is going", "29396.718 - 29695.28": "declare and initialize the iterator after that we're going to do the test we are going to start with i zero so zero is less than ten this is going to succeed we are going to fall in the body here and after that we're going to print sddc out i love c plus plus and this is going to be zero we're going to increment i and we're going to do the test again we're going to have to do is one less than 10 the test is going to be successful so we're going to fall in here and we're going to print a one and we're going to run the incrementation part again we're going to run the test and we're going to keep doing this until we hit a point for example when we increment this to be a nine and after that we're going to run the test we're going to say is 9 less than 10 the test is going to be successful so we're going to follow in here and we're going to print nine and after that we're going to increment again we're going to run the incrementation part and we're going to make i 10 if we run the test we're going to say is 10 less than 10 the test here is going to fail we're going to stop running the loop all together and we're going to fall on the outside of the loop and say loop done let's say that so that we can see this on the terminal and this is going to run and print i love c plus plus 10 times and we expect i to go from zero all the way to nine try to run this in your mind take a piece of paper try to print this as you fall into the body of the loop you're going to see that's exactly what is happening here so what we're going to do we're going to boil this again so we're going to run the task to work with gcc the world is good we're going to go down and run this we're going to clear and run rooster and you're going to see that we have zero i love c plus plus all the way to nine i love c plus plus our loop is working exactly the way we want okay so this is the first step we are able to run our code a lot of times without really having to manually do things like this and the benefit of this is that if we want this to run for example 100 times all we have to do is change our test to go until i is equal to 100 and we're going to stop when i stops being less than 100 and if we run this we're going to see the message from 0 all the way to 99 and this is pretty cool the torso is going to be 100 times so let's weld again to show you how cold this is we're going to run this task to weld with gcc again and we're going to clear run rooster prepare to be amazed run and it's going to run all the way to 99 we can change this to even 1 000 or even 10 000 why not we're going to weld again and we're going to be successful and we're going to clear and run rooster and this is going to go all the way to 10 000 times we're going to wait for this to get there now 3 000 4 000 5000 6000 7000 8000 ten thousand it's going to go all the way to nine thousand nine hundred ninety nine and it is going to stop and the total of times the loop run was from zero all the way to this storping number here okay now we can see that our loop is really working fine we don't have to do these hddc out statements a crazy amount of times okay and the benefit again is that regardless of the number of times the code here is going to run our loop is going to stay relatively the same it's just going to be one two three four lines of code and this is really cool okay so i think this now makes it very clear how loops work so we're going to comment this out and show you another thing and we're going to show you that you can use size t to actually denote the type of your iterator and it is easy to do that so we're going to say use size t and for us to be able to see all this here let's hit this file icon here to close this pane and we're going to have a better chance of seeing our code here so what we want to do we're going to declare a group we're going to save for we're not going to say our design and we're going to say size t and this is going to be the type of our iterator we're going to say i we're going to initialize this with a zero and we're going to put a semicolon like we just did we're going to put in the end test we're going to put in the test so we're going to say i less than 10 no problem with us and we are going to increment to put in place our incrementation part we're going to fall in the loop we're going to say stdc out this is the code we want to run so we're going to put in our coverage value for the iterator and we're going to say i love c plus plus", "29695.28 - 29995.760000000002": "line character and if we build and run this it's going to work and run the same so let's say loop done here so that we know when it's done and we're going to weld and run we're going to world with gcc the world is going to be good and what we're going to do we're going to clear and run rooster and this is going to say i love c plus plus 10 times from 0 to 9. again the message here is that you can use size t to represent the type of your iterators and this is the type that is even used in the c plus plus standard library so this is going to be something people expect from your code if you are representing sizes in code that should be compliant with the c plus plus standard library nothing stops you from using unsigned it like we do here but we're just going to follow the convention from the c plus plus standard library and use this type here to represent all sizes and some of you might be wondering how big is this thing we have the tools to know how big it is so let's do that pretty fast so we're going to go down here and say sddc out and we're going to say size of size t and we can print this out and let's say what we are doing here so that it is easy to use this code as the reference and if we print this out we're going to see the size of this thing on the system where this code here is going to run so we're going to build with gcc again the bolt is going to be good we're going to go here and clear and run rooster you're going to see that it is eight bytes on my system so you're going to have quite a huge range of numbers you can put in here because this is going to only be positive okay if you try to put in a negative number you're going to get an underflow and we have learned about overflow and underfloor in the previous chapter okay so let's comment this out and keep learning more things about for loops okay the next thing i really want you to focus on and learn is the scope of the iterator and we're going to grab our code again here so that we can use this as a learning tool so we're going to go down here and put that in and what we're going to have let's move this a little bit to the right i think we can do something like this i am going to select the entire thing here and hit tab and it is going to be aligned with whatever we have here okay so we have our loop it is going to run 10 times it's going to print i love c plus from 0 to 9 but what is the scope of this i think here and the fact is it is scoped inside this loop here you might have guessed that if you try to use it outside the loop you're going to get a compiler arrow because it is only usable inside the body of the you can also use it inside the control part of the loop here but you can't use it outside the loop so if you try to print i here for example you're going to get a compiler error so let's try and do that and show you how wrong this can be so if we try to print i here let's say i to make it clear what we want to print if we try to do this we're going to get a compiler error because i is not in scope it is only in scope inside these curly braces that show the body part of our loop okay visual studio code is showing the problem here it's saying eyes undefined here so you shouldn't really do this but if we move on and ignore the message from visual studio code and compile we're going to get a compiler error and it's going to say i don't know what you're doing here i was not declared in this scope where you are using it and i think it's even going to give me a line a number it's going to tell me 46 that's where you are doing something wrong and if we go in our code we're going to see that this is the line where we are making the mistake so i is not in scope here we're going to comment this out and say compiler error i is not in scope that's what you're going to get if you try to do this and the main message is that if you declare your loop like this ah is only going to be scoped in the body of the loop and that's the only place where you can mention its name and use it if we comment this out and world again the compiler error is going to go away you're going to see that the world is good let's clear so that our output here is good we're going to build again and show you that the build is good and uh this is really cool both finished successfully okay this is one way we can set up our loop but there is a way we can make our iterator usable outside the body of the loop and we're going to show you how you can do that next so let's comment this out and go down again", "29995.760000000002 - 30295.2": "we don't want to type all this again and we're going to say iterator declared outside the loop we're going to go down and put in our code and we're going to align this nicely and we're going to take the iterator and declare it on the outside of the loop so we're going to say size t and we're going to say i and initialize this to 0 and we're going to say this very clearly iterator defined outside and we're going to say in our [Music] declaration part of the iterator we're going to just say i and this is going to work pretty fine if we build this you're going to see that the world is good and if we run this it's going to do the same thing it's been doing it's going to print i love c plus plus 10 times and if you want i usable on the outside of the loop now you can use it we can grab the code here that was failing in the last run of our code and put that out here and we're going to align this a little bit and if we compile this the book is going to be good and if we try to run rooster we're going to see i love c plus 10 times we're going to say loop done and we're going to print the value of i and you see that if we do things like this i is going to be usable on the outside of the loop body and sometimes these may come in handy depending on the logic of the application that you are designing just know that this is something you can do in your loops okay you can go even crazier and leave out this iterator declaration part in your loop all together so you can remove that and we're going to show you how you can do that in a minute so let's comment this out i don't want to remove code because i want you to have this as a reference if you need to look at this later so we're going to say leave out and what you can do is grab the code we had before i'm going to grab it and we're going to paste that in here and what we're going to do is take out this eye this can work and you may see code like this out there in the wild so we're going to run this task to build with gcc the world is going to be good and we're going to clear and run rooster and it's going to do exactly the same thing so this is one way you can set up your loops okay the last thing we need to see about loops is that this test here is using a hard coded value and if we needed to change this loop to run for example for a thousand times we would need to manually hunt for this line of code change this and this is really not good design so what is recommended is to store this value in a variable and test against that variable name instead let's comment this out and show you that so we're going to comment this out and go down and copy this entire thing i don't think i want to do my loops like this because this is really unintuitive most times so i am going to declare my iterator inside and i'm going to copy the code that does that here we're going to go down and say don't hardcord values okay we're going to say that it's really bad and we're going to go down and show you a better way to do things and again right now we are hard coding in this value but we can say const size t and we can call this value count for example and we can initialize it with whatever we want in this case we want to control our loop to run 10 times so we're going to put in a 10 and instead of hard coding and this 10 we're going to say count okay and if we build and run it the loop is going to do exactly the same thing it's going to print i love c plus plus 10 times so let's do that and run rooster it's going to do the same thing but now we have one point of control if we want this to run for let's say 100 times we can change the count value to 100 times and if we both again that's how many times the loop is going to run and this is much cleaner so i do recommend you store the values you use in your loops in variables like this and it's going to make your code look better so it's going to run 100 times and this is exactly what we want this is really all we set out to do in this lecture i hope you found it interesting i am sorry that this lecture turned out lengthy because we had a lot of things to talk about but now i hope you really know a lot of things about ways you can use your for loops to make them do things and again many loops that we're going to use in our c plus plus code are going to have five parts we're going to", "30295.2 - 30595.039999999997": "variable we use to manipulate how a loop moves forward and does things the starting point is going to be where the loop is going to start we're going to have a test in place which is going to control when the loop ends and we're going to have the end point encoded in that test we're going to have the incrementation part of the loop which is going to control how our loop moves forward and we are going to set up a pair of curly braces that are going to contain the body of our loop in this lecture we're going to learn about while loops and this is another construct we have in the c plus plus programming language to allow us to do repetitive tasks the syntax for a while loop looks like this we have five parts in our loop we have the iterator the starting point the test the incrementation and the loop body it's just going to be set up differently for while loops the iterator is declared on the outside and you see here we have unsigned in i which is exactly the same type of iterator we've used in the last lecture but know that you can also use size t here i am just using unsigned and for this case after you have your iterator declared you're going to fall to this part here and say while open a set of parentheses and inside you're going to put in your test after that you're going to open a pair of curly braces and design them you're going to put the body of your loop and you're going to do whatever it is you want to do in the loop in there and after your code to do whatever it is you want to do is executed you're going to put in your incrementation part after you code and that's what we have here and this is the setup we're going to be using for our while loops again we have the iterator declared on the outside and we can initialize it with whatever it is we want to start with then we're going to put in our test it's going to be within this parenthesis and after that we're going to set up a pair of curly braces and inside them we're going to put whatever code we want to run in the loop and then we're going to follow that with our incrementation part and if we try to run this we're going to run this line we're going to declare the iterator i and it's going to start with zero so the test is going to run and 0 is less than 10 and we're going to succeed and we're going to run the body here we're going to say i love c plus plus and after that we're going to run the incrementation part i is going to become one we're going to run the test again so one is less than 10 we're going to succeed we're going to fall in print i love c plus plus we're going to increment again then we're going to have a 2 in i here we're going to run the test again we're going to say is 2 less than 10 that's going to be true so we're going to be successful we're going to fall in the body of the loop we're going to increment and get a three we're going to test against our three value three is less than ten we're going to succeed we're going to print i love c plus plus we're going to increment again we're going to test again and we're going to say is for less than count or 10 we're going to be successful and we're going to keep running until we increment and get a 9. once we get a 9 we're going to run the test again and we're going to say is 9 less than 10 that's going to be successful so we're going to fall inside print i love c plus plus we're going to increment and get a 10 and if we run the test again i'm going to say is 10 less than 10 that's going to fail and we are going to fall on the outside of the loop and we're going to run whatever code is on the outside here this is really how a while loop works and i hope you can see the similarities between the for loop we have seen it is really the same thing we just have different syntaxes to do these things okay if you look at these things we already have the same pieces of information it is just different syntaxes that c plus plus provides to do the same things and sometimes you're going to find it convenient to use while loops and sometimes you're going to find it convenient to use for loops and you're going to have to decide what works better for whatever it is you are working on for now we're going to head over to visual studio code and try this out okay here we are in visual studio code the current project is while loop we're going to grab our template files and we're going to go in our project and put those in and we're going to open this in visual studio code so let's do that we're going to open the folder and we're going to work on while loop here we are going to open our main cpp file pretty quick and we're going to get rid of this and what we're going to do is remove what we don't need and again we're going to show you the bad way to do things you don't really want to do this manually we want to print i love c plus plus 10 times so we're going to build let's bring up a new terminal so that we can use this when we run thanks and we are", "30595.039999999997 - 30895.68": "pretty quick the world is good so we can clear and run rooster and we're going to have i love c plus printed out 10 times so what we can do is comment this out and use a while loop like we want to do in this lecture here and as we have seen with the slides the first thing we need to do is declare our iterator on the outside so we're going to say size ti we're going to initialize this with zero and that's going to be our iterator declaration and we're going to say while i is less than the value where we want to stop and again we don't want to hard code these values and so what we're going to say is really const size t and we're going to call this count and make it uppercase this is a convention we use to declare constants in c plus plus but you don't have to make them uppercase it is just a convention that is going to make your code easier to read for other people so we're going to put a 10 in here because we want our loop to run 10 times and we're going to say y i is less than count and we're going to set up a pair of curly braces and they are going to delimitate the start and the end of the body of a loop here and inside we're going to put in whatever code we want the loop to run multiple times and the code is now very familiar we're going to say sddc out and we're going to print the current iteration and we're going to say i love c plus plus sdd endl for our new line character and after that we will need to put in our own incrementation part if you forget that you're going to get something really bad happen we're really going to look at that later in the chapter but for now remember to put the incrementation part and we're going to say plus plus i this is really easy and we're going to say that this is the test and this is going to do what we want but let's go down here and say that loop is done when it is done so we're going to say loop done and we're going to say stdendya and before we run this we're going to go through it and see how it is going to work so let's click on this file icon here to close this pane so that we have some breathing room i am going to open a notepad file we're going to use to see these things really happen when this loop runs we're going to initialize the iterator here what we're going to do is put in a 0 and we are going to run the test to see if 0 is less than 10 and the test is going to be successful so we are going to fall in here and say 0 i love c plus plus so let's say that here to make this super clear inside the loop we're going to print this message zero i love c plus plus and after we execute this line we're going to increment i is going to become one we're going to go up again and run the test and we're going to say is 1 less than count or is 1 less than 10. the test is going to be successful we're going to run inside the loop and we're going to print 1 i love c plus plus that's what we're going to do here so let's do that and after we do that we're going to run our incrementation part again i is going to become two we are going to run the test we're going to say is 2 less than 10 that's going to be true of course and we're going to fall in the body again and say two i love c plus plus so let's say that we're going to increment and we're going to get a three we're going to run the test again the test is going to be successful because three is less than ten we are going to fall in here and say three i love c plus plus okay so we can really follow this and we are going to increment to get a four and the test is going to say is four less than ten that's going to be true so we're going to succeed and following the body again and we're going to say 4 i love z plus blocks we're going to keep doing this and we're going to increment again we're going to get a 5. the test is going to run again we're going to say is 5 less than 10 that's going to be true of course and we're going to run the code to print five i love c plus plus we're going to increment again to get a six we're going to run the test we're going to say is 6 less than 10 that's going to be true of course again and we're going to print sets i love c plus plus and we're going to increment to get a 7 we're going to run the test our iterator we're going to say is 7 less than count that's going to be true we're going to print the message again and say seven i love c plus plus and we're going to increment again to get an eight we're going to say is eight less than and count that's going to be true we're going to fall in the body and say eight i love c plus plus we're going to increment to get a nine we're going to run the test against our", "30895.68 - 31196.08": "that's going to be true we're going to fall inside and we're going to say nine i love c plus plus and after that we're going to increment again and we're going to get a 10. now if we run the test we're going to say is 10 less than 10 and that's going to be false because 10 is not less than 10 and if the test here fails we're not going to fall in the body of the loop control is going to fall at the end of the loop body and we're going to print loop done that's what we're going to say here we're going to say loop done and our loop will have run 10 times by the time we print this loop down message here if you count here you see that the loop is going to run 10 times and it is going to say i love c plus plus 10 times which is really what we want okay i really had to show you this manually so that you can really see what is happening but now we can weld and run this and let the computer do the heavy duty of running this and showing us all these messages so the build is going to be successful of course we're going to run rooster and it's going to exactly show the same thing we just came up in our trusty notepad file here you see it is the same thing but the beauty is that we don't have to do all these crazy computations again what we can do is we can even change the count to 100 so it is going to run for 100 times that's pretty cool so we can clear and run rooster and is going to do that 100 times and that's pretty fast for computers this is really all we had to share with you in this lecture the main thing is to learn about the syntax of a while loop and again notice that we have these five parts that make up our loop we have an iterator we have the starting point we have a test we have the incrementation part and we have the loop body it is just set up differently with a while loop like we can see here in this lecture we're going to learn about do while loops and this is yet another construct we have in c plus plus to do repetitive tasks let's look at the syntax here we have our declaration of the iterator on the outside and after that you're going to say do you're going to put a pair of curly braces like this you're going to put whatever code it is you want to run inside the loop and then you're going to do your incrementation and after the closing curly brace you're going to say while and you're going to put in your text this is really the structure again notice that we have those five parts and this is the declaration of our iterator and we're going to initialize this in place for example if we want to do that after that we're going to fall in the body of the loop and after that we're going to do the incrementation after we run the code it is we want to run in the body of the loop and then we're going to do the test later and the special thing about a do while loop is that it is going to run first and then you do the test last this is really something you need to be careful about make sure that when it runs it is doing whatever it is you want to do because the test is going to run after your code has actually run and you can tweak this to do whatever it is we want it to do as we are going to see when we hit visual studio code in a minute okay again one thing you need to keep in mind is that the do while loop is going to run the body of the loop and then do the check or the test and that may come in handy in some of the applications you'll be doing within your career as a c plus plus developer okay this is really the syntax we're going to be using we're going to head over to visual studio code and play with us okay here we are in our working folder the current project is going to be do while loop we're going to grab the template files pretty fast and we are going to put them in our current project let's open this up and put them in there and we are going to open this in visual studio code do while loop is our project we're going to open this and the main cpp is opened up so let's remove whatever it is we don't need and we are going to show you the bad way to do things the bad way to do things is typing your code to do things manually if you wanted them to be done multiple times and this is something bad if we bought this and run we're going to go down and run this clear not that's g brush we're going to run rooster and we're going to get i love c plus plus 10 times and you don't want to do something like this what we want in this lecture is to use do while loops to solve this problem we're going to comment this out because it is really bad and we're going to go down and set up", "31196.08 - 31496.798000000003": "need to do is to set up the count because we want to store this in some variables so we're going to say const and count and we're going to put in our value let's put in a 10 not 190 we're going to say 10 times and we're going to set up our iterator we're going to say size t and we're going to say i and initialize this with our starting point we're going to start from zero and what we're going to do is say do and put a pair of curly braces and inside this pair of curly braces we're going to put whatever it is we want to do multiple times so we want to print i love c plus plus so that's what we're going to say we're going to put in the current iteration and we're going to put a column and say i love c plus plus and then we're going to jump to the new line with stdendl and after that we don't want to forget our incrementation part so we're going to say plus plus i and this is going to be the part that moves our iterator to the next step this is going to be the incrementation and this is going to be the iterator declaration and after the closing brace we need to say our test so we're going to say while and we're going to put in our test here and we want to keep doing this as long as i is less than count of course and we're going to put in our closing semicolon here now this code is going to run 10 times but let's go through how it's going to run so that you can really see everything that is happening here okay so when this code here is run we're going to hit the initialization line here we're going to declare i and we're going to put in a 0. we're going to say do and inside we're going to print whatever we have in i and say i love c plus plus so we're going to say 0 because i is 0 at this point and we're going to say i love c plus plus and after that we're going to increment i is going to become one and we are going to do the test at this time we're going to say is one less than ten that's going to be successful so we're going to run the body again and we're going to say 1 i love c plus let's copy this and print this again so that we don't have to type this all the time we're going to say 1 i love c plus and after that we're going to run the incrementation part again so we're going to get a 2 inside i we're going to test and say is 2 less than 10 that's going to be true so we're going to run the body again and print 2 i love c plus plus and we're going to increment to get a three in there we're going to run the test against our three is three less than ten that's going to be true so we're going to fall in the body again and print three i love c plus plus let's do that we're going to do the incrementation we're going to get a 4 inside this i variable here we're going to run the test we're going to say is 4 less than 10 that's going to be true of course we're going to say four i love c plus plus when we fall in the body again we're going to do the implementation and get a five we're going to do the test it's five less than ten that's going to be true so we're going to fall in the body again and say five i love c plus plus let's say that we're going to increment again we're going to get a six the test is going to run and we're going to say is six less than ten that's going to be true again then the body is going to execute and say 6 i love c plus plus we're going to do the incrementation and get a 7. we're going to run the test against our 7 so we're going to say is 7 less than 10 that's going to be true we are going to fall in the body again and say 7 i love c plus plus we are going to do the incrementation we are going to get 8 we're going to say is 8 less than 10 that's going to be true we are going to fall in the body again and say 8 i love c plus plus we're going to do the incrementation we're going to get a 9 and we're going to run the test we're going to say is 9 less than 10 that's going to be true so we're going to go inside and say 9 i love c plus plus and we're going to do the incrementation again now we're going to get a 10 and the test is going to say is 10 less than 10 and that's going to be false now the test is going to fail and we're going to fall after the while loop here so if we had a statement here that said stdc out loop done we would print that we would go down here and say loop done and this is what we're going to get if we run this program and again i", "31496.798000000003 - 31796.718": "mind print this in some file you have on your computer or you can even use a regular piece of paper but make sure you understand the flow we go through to get this code to run multiple times okay now that we have done this we can work this and let the computer do the heavy work for us and run this fence multiple times the world is going to be good so what we're going to do we're going to say clear and run rooster and it's going to say exactly what we expect i'll have c plus 10 times and then it's going to say loop done okay one thing i want you to see is that the do while loop runs before it does the test and this may cause crazy things happening in your program if you're really not careful let's say that you wanted this program not to run and initialize this thing with a zero for the count so it's going to run zero times but that's not going to do what you expect with the do while loop because it runs things before it does the test so if you run this program it's not going to just say loop done it's going to say i love c plus plus and have zero value in here and it's going to say loop done but that's not going to be probably what you intended by putting a zero in here you put a zero in here if you want this code to run zero times or the code in the body not to run that's another way to say that but in this case a do while loop is not going to do what you expect because it runs before it does the test here let's build this and show you this so we're going to go through the world is successful and we are going to clear and run rooster you're going to see that it's saying zero i love c plus plus loop done it is running even if we set our count to zero here so be sure the do while loop is doing what you want but if you are careful about this you're going to have no problems and if you want the rope to actually not do anything when you have zero counting here you can use the while loop or the full look like we have seen before i would like to welcome you in this new chapter where we're going to be learning about arrays and arrays are a way to set up collections in our c plus plus program so far we have been working with single variables for example you have a bunch of integer variables you can even have 10 or 20 variables of integer type and that's going to be fine but sometimes you don't want to manage all these variables it is really desirable to group all these variables into one single unity and manage them as one single entity and we can do something like this group them together and give them a name so that we can refer to them or manipulate them under this name here and c plus plus has the array construct to help us do this okay so again if you look in memory how things are laid out you're going to have a bunch of zeros and ones for example here each red defend is a net it is four bytes in size and it can be used to represent a net so if we have a bunch of events like this we might want to group them together and give them a name and manipulate them under this name this is another way to look at what we just talked about here and again arrays are a way to do these kinds of things in c plus plus and we're going to be learning all about it in this chapter we are going to stop here in this lecture and we are going to start and look at how you can declare and initialize an array in the next lecture go ahead and finish up here and meet me there in this lecture we're going to see how we can declare and use arrays in our c plus plus program and again arrays are a facility we have in the c plus plus programming language to group many variables together and manipulate them as a single unit for example here we have a bunch of integers in memory each of these red things is going to be four bytes in size so we can think of it as an integer and we can group them together and give them an a we call them scores here and they are going to be living under that scores entity so if we want to refer to each of these things z plus plus provides an indexing system so we cannot use angle brackets like this and refer to the first of these integers as zero so we can go from zero all the way to nine here but your array can even be bigger than this many times bigger than this and we're going to see examples of how we can do that but this is an example of how you can take many", "31796.718 - 32096.557999999997": "give them a name and be able to reference each of these events that are under that entity and now that the idea is pretty clear let's see how we can do this in c plus plus the way to do that is to say and you have to specify the type of your collection you have to specify the name after that and then you're going to put a pair of angle brackets like this and inside those angle brackets you can specify the size you want that collection to have or that array to have and after this statement is run we are basically going to have something like this in memory we're going to have 10 integers so if you count here 0 all the way through 9 that's 10 integers they're going to be grouped together under one logic entity that logic entity is going to be called scores and we can go through that name to manipulate all these things that are in this entity okay after your array is declared and you have space for it in memory basically something like this we need a way to read data from at and we're going to see how we can do that and it is what we have here for example if we want to print the first of these elements we're going to say scores angle brackets and specify the index of the first element in that array or that collection of integers that is called scores okay one thing you should really keep in mind is that arrays are indexed from zero they don't start from one so the first element is going to live at index zero it's not going to live at index one so here scores zero is going to print the first element and scores nine is going to print the last element which happens to be the last in our collection here of integers okay once our array is declared it's not going to have data in it there is going to be data in but it's not going to be data that we put in so we can think of this data basically as garbage another thing i wanted to bring to your attention is that your array has clear boundaries when we declare an array like this notice that we specify 10 as the size of our array it's only going to have 10 elements inside and you can see that we have from index 0 all the way to 9 and inside we have garbage data but we're going to fix that in a minute what i want you to see here is that you can to try and read outside the bounds of your array c plus plus is funny in that it allows you to do that but if you do that you're going to get weird problems for example your program would crash or do something really bad so you shouldn't really do this be aware of the boundaries of your array if you try to read the data from the outside of your balance you may read garbage data you may even cause failure of the operating system because you don't really know whose memory you're reading it's not going to be memory that is allocated to your program so array boundaries are something you need to keep in mind when working with arrays okay we just saw that we could read data from the array using this angle bracket syntax we can even do that through the loops and read all the elements in the array and this is how we could do that and you can see that the loops we learned about in the last chapter are starting to come in handy okay we have seen how we can read data from the array but what if we want to put something back in what if we want to write our own data in an array well the syntax is pretty much what you would expect we also use this angle bracket syntax but we're going to assign data to that element in the array for example if we wanted to assign data to the first element in our array we're going to say scores angle brackets 0 and we're going to assign a 20 in it and we can assign a 21 into the element at index 1 and the 22 in the element at index 2 and if we do that we're going to have something like this in our array so index 0 we have a 20 index 1 we have a 21 index 2 we have a 22 and the rest is still garbage because we didn't put in our data we can also write data in a loop for example here we have our array declared and we're going to loop around putting data at different indexes notice that the index is going to be the current iteration we are at so this is a common way to do things in c plus plus and you need to be familiar with this and after we put in the data we can read that back and make sure that it is the actual data that we put in and we're going to have a chance to play with this in visual studio code in a minute so don't worry if some of these things don't make sense yet but again the main thing here is this angle bracket syntax we can use that to either write data in the element of the array or read data from the", "32096.557999999997 - 32397.039999999997": "syntax here scores angle brackets i okay so far our array has been declared and we didn't really put in data and there was junk data inside but there's a way you can declare an array and put data in in one single statement and this is how you would do it here we have another array it's going to be grouping double variables we call the array salaries and we specify that it's going to be of size five and we can put these elements in a comma separated list using braced initialization like this and it is going to work if we try to print it out we're going to see these elements here and you see that we can read this using the same syntax we've learned about salaries we say the array name we do angle brackets and inside we put the index of the element we are reading from and this index is coming from our loop here and it is going to work you're going to get this element printed out this is pretty cool when initializing your array you can leave out elements for example here we have a neat array it is called families it's going to be of size 5 but we are just putting in three elements the rest are going to be initialized to zero when we do things like this and this is something you need to be aware of and we are going to try this out in visual studio code and you're going to see that this is actually true it is possible to also omit the size when you are declaring your array and the compiler is going to deduce the size from the elements that you initialize your array with for example here we have in one two three four five six elements this array is going to have a size of six and if we print elements we're going to get those printed out notice here that we are using a ranged base for loop and hopefully you can see that it is easier to read data from a collection like this using a ranged base for loop because we don't have to set up an iterator initialize it to do the test do the incrementation we can just read the value and use it and be on our merry way this is pretty cool it is possible to also declare your array constant and when you do that you won't be able to modify elements of that array that's what it means if you make it constant you basically want it to stay constant and you don't want to allow modifications of your array and we're going to see this in a minute when we get in visual studio code the last thing i want you to see is that you can actually do operations on the data that you have stored in an array for example here we can sum the elements up and store the result back in our variable sum and this is something you would do and it might come in handy in many times okay one thing i want you to see before we head over to visual studio code and play with us is that arrays store elements of the same type repeat after me arrays store elements of the same type you can't try and store variables of different types in an array i don't even know how you would actually declare that and if you try and store a different type than the type that was declared for the array you're going to get a compiler error so this is something you should keep in mind but it makes sense because when you declare an array you're going to be given a bunch of bytes in memory and those bytes are going to be collections of data that is of the same type for example here we have a bunch of integers again each of these red events is an integer and if you try to put in something that is smaller or bigger than an edge then the compiler is going to be confused that as to how to read these text so for arrays to work the types that you store in the array have to be the same and they need to be consistent this is something you should know and if you try to break this rule you're going to get a compiler error now that you know about arrays we're going to head over to visual studio code and play with them a little bit okay here we are in our working folder the current chapter is raised the current project is declaring and using arrays we're going to grab our template code and we're going to copy and move the files over and we're going to open this thing up in visual studio code pretty quick we're going to open up the main cpp file and remove things we don't need and we're going to see how we can declare an array of ants okay the way you do that you say the name of the arrays and you put these angle brackets and specify the size of your array if you want you can put a space in here it's really not going to make a difference and you're going to put a semicolon at the end the moment this line executes we're going to have the space for 10 integers allocated to us in memory and that space is going to", "32397.039999999997 - 32695.679999999997": "able to read data from it or even write data back into it for now let's see how we can read the data and it is really simple we're going to use this angle bracket syntax that we just saw in the slides so if we want to read the first element we can say sddc out we want to print it out and we're going to say scores specify the index we want to read from so we say zero and we're going to say std endl to move to the next line if you have this typed out you're going to see that this is going to work and it is going to print whatever is stored in the first element in this array here and again i want you to keep in mind the memory structure of your data when you are working with arrays so what we're going to print right now is whatever junk data is in this first element here okay in here we're going to say that we haven't jumped yet and let's bring up a terminal so that we can play with us and we're going to build this with gcc as we always do the build is going to be good and we're going to clear and run rooster you see that this is the junk value we have in here we don't have any useful data in here it's just junk data because we didn't initialize this array we can also read the element at location two and see what we have in there when you run the program i'm not even sure if it is guaranteed that you're going to get the same data if you run the program multiple times but we don't really care we know that it is junk data so we can't use this in our program what we're going to do is run this and see the value for the element at index one let's build with gcc the world is going to be good we're going to clear and we're going to run rooster and you're going to see that at index 1 we have a zero end but doing it manually like this is really time consuming and it is possible to actually do this in a loop we know the size of this array so it's a 10. and we can loop around 10 times pretend each element at each iteration and the way we do that we're going to read with that loop and we're going to say for okay size t and we're going to start from index to zero this is really important because arrays are indexed from zero they don't start from one again this is something you need to drill in your brain and we're going to put in our test case we're going to say i less than 10 because we want to go from 0 through 9 and we are going to increment our iterator after we do that we're going to have to jump into the body of the loop and we didn't name our iterator that's why we're having this squiggly line here let's do that pretty quick we're going to jump into the body of our loop and we are going to say sddc out and we're going to say scores and we need to be careful about how we format this because i is not something we have we're going to be getting that from our iterator here so we're going to print it like this and this is going to work no big deal and we're going to say squares and we're going to say i that's going to be our index that we want to print the data for and we're going to say stdendl and uh because we don't want this to confuse us we're going to comment that out and we're going to go up and make sure our comment is nice and neat and we're going to try and run this and what do you expect to see well we don't have any real data in here we're going to have some junk data so it could really be anything we get printed here so let's build with gcc and we're going to give ourselves some breathing room we're going to go down and clear and run rooster and you see that um this is really some junk data and if we run it again let's see that we get the same output it is the same data in here if we want to have in some reliable data we need to write in our own data and we're going to see how we can do that we're going to see how we can write data into an array and the syntax is really simple so the way you do that you just say the index for which you want to write data in and you say scores and you specify the index let's say zero and i'm going to put in a 20 for example this is how you do this you say 20 let's say scores we're going to grab the index one the first element and we're going to put in a 21 why not and we're going to say scores we're going to say 2 for index 2 and we're going to put in a 22", "32695.679999999997 - 32998.96000000001": "print this out or read data with the loop and make sure that the data we did writing is actually n so we're going to copy this and comment this out because we don't want this to confuse us on the console and we're going to do that we're going to come down here and print the data out let's say what we're doing here and if we build this we expect to see that at index 0 1 and 2 we have the values 20 21 and 22. let's build and see we're going to run the test to build with gcc the build is going to go through we're going to clear and run the rooster and look at this score is a 0 20 score is 1 21 score is 2 22 and our data is actually getting gain now we're going to see that we can also write the data using the loop to make it really easy without us manually doing things like this for that we're going to copy what we have here to print data out and we're going to comment what we had out here so let's comment this out and we're going to go down and uh print the data again we're going to put in the code here and before we print the data we're going to put data in with the loop so the loop is basically going to be the same thing we're going to say size ti we're going to initialize this we're going to say i less than 10 because we want to loop 10 times we're going to increment and we're going to fall in the body of the loop what we're going to do is write data at the index of the current iteration i should say so what we're going to do we're going to say scores i and we can really put in anything for now let's say we want to put an i multiplied by 10 so we're going to take the current index multiply it by 10 and we're going to store that in the index at the current iteration this is what we are doing here and if we print this out try to think about what we're going to get here so at index 0 let's put in a 0 to be super clear here that we are starting from index 0. at index 0 we're going to take 0 and multiply that with the 10 so we're going to store 0 at index 0. the loop is going to run again at index 1 we're going to take a 1 multiply with 10 we're going to get it 10 at index 2 we're going to multiply 2 with a 10 and store a 20 at index 2 and we're going to keep going and basically have 0 10 20 all the way to 90 stored in our array here so if we print it out we expect to see 0 10 20 all the way to 90. let's weld and see that that's actually what we have in our array we're going to work successfully let's clear and run rooster and you see that this is exactly the same thing we have in our array how cool is that okay another thing i want you to see is that we can declare and initialize an array in place but before we do that let's say what we were doing here we were trying to write data in a loop and we're going to comment this out because we don't want a lot of confusing output in our console and we're going to go down and put in the data because i don't want to type all these thanks so we can declare and initialize an array in place and the way we do that the array is going to store doubles now we can really declare an array of anything but so far we have seen that we can do that for ant now let's try a little bit and show you that you can do the same thing for double times so we can declare an array of double types the size is going to be five and we're going to initialize that with this data here so at index zero we're going to have a 12.7 index one a 7.5 index 2 a 13.2 index 3 an 8.1 and index 4 and 9.3 and that's what we're going to have if we print this out here we have a simple loop to print it out and it's going to basically say salary 0 12.7 and it's going to go all the way to salary 4 and print a 9.3 and this is something you can do if it makes sense for whatever you are designing with c plus plus we're going to build this with gcc let's clear and run and you see that this is exactly what we expect okay now this is super clear the next thing we're going to see is that if you don't initialize all the elements in the array those you leave out are going to be initialized to zero and we are going to put in a piece of code to play with that so here we have an array it's a net array it's going to be called families and the size is going to be five but we are only initializing three elements and these elements are going to be elements on the front so elements at index 3 and 4 are going to be left out and they are going to be initialized to 0 by the", "32998.96000000001 - 33298.238": "expect to get 12 7 5 and 0 0 at different indexes in this array here let's build this with gcc we're going to clear because the build is successful and we're going to run this this is exactly what we expect we have a 12 a 7 and 5 and the last two elements are initialized to zero and this may come in handy sometimes okay let's comment this out another thing we want to see is that we can actually omit the size when we are declaring our array and initializing it so here is a simple example we have an inter array called class sizes we don't specify the size but we initialize it and the compiler is going to deduce the size of this array from the elements we put in here so if we put in two elements so it's going to be of size 2 if we put in 10 elements it's going to be of size 10 and this is how this works but if you do something like this and not to initialize the array let's take this out for example you're going to get a compiler error because the compiler now doesn't know which size it's going to give to this array so be sure to either put in the size or initialize your array like this and it is going to work in this case we're going to have six elements and and you see that a range based for loop is going to come in handy here because we don't really know the size of this array if somebody comes and adds another element let's say 23 the size is going to change and if we hard to code the size in our full loop the code is going to break but a range based for loop is going to use whatever size this already has so we're going to try and build this we're going to build with gcc as usual and the world is going to go through if we run rooster we're going to get the elements we have 10 12 15 11 18 17 23 if we add a new element this is going to work you see that we don't need to modify the loop here to put in the new size and this is really cool i like this about range based for loops we're going to build again and we're going to clear run the rooster and this is going to give us exactly the data we have in the array so this is one way you can do things another thing we saw is that you can't modify const arrays so let's do an example here for example we're going to grab this thing and uh put an array declared down here we're going to copy that and use that here and we're going to make this cost let's give it a name let's say birds for example for example we want to keep track of lines of birds or whatever this is just an example to show you that you can't modify this array so if you try to do something like birds and index 2 for example and you want to change this to an 8 the compiler is going to complain you see that visual studio code is complaining already expiration must be a modifiable value so it is saying that the array stores const elements so you can't modify elements of this array okay so this is something you can do if you don't want people to be able to modify data in your array and the last thing i'm going to show you is that you can do operations on the data in an array so let's bring up our scores array again so we're going to go up and copy it because the code is using there so let's put in our own scores array it's going to be pretty fast and we're going to say that it is an array with this angle brackets we're going to initialize this let's put in a bunch of values and what we can do is sum these things up we're going to store our results in the sum variable and we're going to loop around with a ranged based for loop because we don't really know the size of this array it can change any time with however many elements and a range based for loop is really cool in that we don't have to keep track of the size of ourselves so we're going to go in here and get each element and add that to some so for example for the first time sum is going to be 0 because that's what we initialize it with we're going to get into this loop here the first element is going to be 2 we're going to add that to 0 and get 2 we're going to add a 5 we're going to get a 7 we're going to keep adding this element and at the end sum is going to contain the sum of all these elements in the array here and this is one cool way you can sum up the elements in your array so if we run this we're going to get the sun printed out let's do that pretty quick we're going to run this has to build with gcc and we have ourselves a compiler error", "33298.238 - 33597.04": "redeclaration of scores where did we declare scores before let's go up and make sure it is not declared somewhere and it is declared here so we want to comment this out come back to our code so that we can see it and we're going to build again with gcc and now the world is going through we're going to clear and if we run rooster score sum is 37 and if you sum these things up i'm sure you get 37. this is really all we set out to do in this lecture i hope you have a better idea of how you can declare your arrays put data in read data out of those arrays make them const or even do all kinds of operations on them and this was really what this lecture was all about we are going to stop here in this lecture in the next one we're going to see a cool way we can use to get the size of an array go ahead and finish up here and meet me there in this lecture we're going to see a way we can query for the size of an array at runtime if you remember in the last lecture we had an example like this showing how we can declare an array and initialize it in a single statement like this but the problem we had with this is that if we tried to print the array using a for loop for example we would have to use the size and the size of this array may change if somebody decides to add elements or remove elements then the size is going to be irrelevant c plus plus provides a way we can query for the size of an array at runtime and we're going to get the real size accounting for the current number of elements that we have in the array and for that we use the std size function this is a function that comes with the c plus plus standard library so you're going to have it already if you have a compliant compiler if you see here you see that it was introduced in c plus 17 and it is a cool addition we can use it to make our code easier to work with if you look here we have a simple loop which is going to print data out it is going to loop starting from zero all the way to the size of the array you see that we use this to control when this loop is going to end we then put in our incrementation part and then we jump into the body of the loop and print the current element in the loop and if we do things like this we're going to be able to print all elements in the array regardless of the number we initialize it with okay so this is one way and it was introduced in c plus plus 17. but some of you must be asking how did we do things before z plus plus 17 well we had to kind of do a hack to get something like this we use the size of operator we have seen a lot of times right now and the way you use this if you do size of and passing the array you're going to get the entire size of the array so if we take that and divide that with the size of a single element in the array we're going to get the number of elements of the array and this is really what we are doing here we are setting up a count variable and we are taking the size of the array and dividing that with the size of a single element in the array and we are just grabbing the first element because you can really use any element here and once we have this we can use this count to do a loop like this and it is working pretty well please remember that you don't have to go through this craziness we're doing here you don't even have to use std size because you can use a ranged base for loop and get access to the elements you have in the array and it is going to work pretty well now that you have an idea about this let's head to visual studio code and actually play with us okay so here we are in our working folder we are going to be working on this project size of an array we're going to grab our template project we're going to copy the files and put them in place and we're going to open this up in visual studio code let's do that it's going to open up in visual studio code and we're going to try and clean it up a little bit and we are going to declare an array if we want to print this thing we need to know how many times we're going to loop and print elements in here so one thing you might want to do is to say okay we have 10 elements in here so i'm going to loop for 10 times you might think this is going to work and it is going to work if we bring up a terminal and build this with gcc like we usually do and uh clear and run rooster we are going to get our numbers this is what we have in the array from one to ten but what if somebody comes and changes the elements we have in here let's add an 11 and a 12.", "33597.04 - 33895.2": "the moment we change this we will need to come and change the size in here and this loop here might be buried somewhere deep in your project and it might not be as easy as it is now to see that we also need to change this this may be a really big source of hard to debug problems so what we really need is a way to get the size of the array at runtime and be able to dynamically query for that size and use it in our program and that's exactly what std size provides so we're going to say end count and we're going to put in a value let's use a braced initializer so we're going to say std size and we're going to pass the array we want to get the size for and if we do this we're going to get this size here and we're going to be looping for this number of times so we're going to test for i is less than the count here and now it doesn't matter how many elements we have in here we're going to get them at run time we need to only update this initializer here so what we can do is weld with gcc again now we're going to come here and run rooster and we're going to get the numbers here you see that we get all the elements if we take out a few of these elements let's take out a few of these let's leave it up to seven or eight let's build again and we are going to clear and run rooster we're going to get however many elements we have in there and this is pretty cool again you might ask how did we do things before c plus plus 17 because std size was introduced in c plus plus 17 let's say that here before that we had to get the size of the entire array and divide that with the size of each element in the array and we could use the size of operator to do that so before we do any of that we want to play with the size of method to really show you what it does so what we're going to do is say sdd the out size of scores the entire array and we're going to print that and we're going to say sddcl size of you know one element let's say scores and use the first element this is the easiest thing we can find here but you can use any element so we're going to say size of here and we're going to say scores and grab the first element which is at index 0 and we're going to print its size if we build and run this program we're going to build and run and the world is good we can clear now and run rooster you're going to see that we're going to get size of scores is 32 the entire array the size of one element is four because we are storing in integers and i want you to see that 32 is four times eight because we have an eight elements so it's going to give you the combined size of all of the elements that we have in here if you do size of an array but if you do size of a single element you're going to get the size of a single element so c plus plus developers were clever enough to see this and see that we could use this information and get the count of elements inside so we can do something like ant account and we're going to assign a value to this in our braced initializer so we're going to say size of we're going to say scores and we're going to divide that with size of and i'm going to grab scores we can really use any element in the array but we're going to grab the one at index 0 and now we're going to get the count stored in our account variable without using std size and we can uncomment our array here or the code to print the array and if we run now it is going to work exactly the same thing regardless of the amount of elements you have in here let's put a few numbers randomly and if we will then run we are going to clear and run rooster and we're going to get all the elements here and you can really use any of these techniques just choose what you feel works better for you okay we are going through all this trouble to set up an iterator we're going to do the test we're going to increment this is really too much work to try and get data from a collection like an array so what we can do instead is comment out all this hard work here and we can use a ranged based for loop as we have seen before and it is", "33895.2 - 34195.596": "with so what you can do is say for auto i we're going to do type deduction on whatever it is we have stored in our array so we're going to put a column and say scores and we're going to print out the element so let's do that we're going to print stdcl and here we're going to say value let's say value in the array and we're going to say i and this is going to print all the elements and we can work with the values inside if we want that but you see that we have lost the information on the indexes so if you really need the indexes you will need to go through something like this and if you just need the values in the array ranged based for loops are going to be really cool let's say range base for loop and if we boiled and run this it's going to work pretty well so the world is going to go through let's bring this up so that we have some breathing room we're going to clear and run rooster and we're going to get our elements printed out here and you see that it is the exact same thing we have in scores here so this is really all we set out to do in this lecture i just wanted you to be aware of the sdd size facility that we have in the c plus plus standard library if you don't want to use it for any reason you can also go in and do the division we did here to get the count of elements in the array and uh do your best to try and use ranged basis for loops because they make it easier and cleaner to get data from a collection like we are doing here with an array we are going to stop here in this lecture and the next one we're going to see how we can work with arrays of characters go ahead and finish up here and meet me there in this lecture we're going to work on array of characters and show how special they are you can declare an array of characters just like any other array so here we have an array called message it stores elements of type character the size is five and we initialize it with a bunch of characters if we want to print it out we can look like we loop through any other array in this case we're going to be using a ranged base for loop we say for auto c we pass the message and then we're going to be printing each character in the message and if we do this we're going to see hello printed out on the console we can also modify elements in our array for example we can say message1 and change the e here to an a and if we print out we should see hello printed out on the console nothing really special so far the cool thing you can do with character arrays is that you can print them to the console directly without even doing the loop you can do something like this you can do sddc out you say whatever you want to do in quotes here and you're going to print the message but sometimes this one to do what you expect because only proper c strings can be printed on the console and what makes up a proper c string a proper c string has this thing you see on the end here this backslash zero is called a null termination string and it is what is going to tell c plus plus that we have hit the end of the string and we are going to stop printing it if we are printing with things like stdcl so this is really important to be in your strength if it's not there it may work but sometimes it's also going to print some garbage characters after this because what tells sddc out that we have reached the end of the string is this backslash zero here if it's not there it's going to keep printing until it sees one and then you're going to probably have some garbage characters added to your string and that's not what you want so to have your strengths printed out correctly be sure to have in this null termination character here and if we print it out we're going to get it and we're going to see the size printed out properly if we do things like this but it is possible to get to this auto field for us if you look here we have a character array called message2 inside we have said that we need six elements and we say hello so we have one two three four five elements and the elements we don't initialize properly is going to be initialized with a zero version of a character and that happens to be the null terminator of the null termination character so this is going to print correctly and we're going to have the backslash n appended to this for us by the compiler but be sure you understand the difference between this and this here we have specified the size to be a 5 and we are putting in five elements so", "34195.596 - 34496.16": "this string but here we have said that we can put in six elements and we have only put five and the compiler is going to autofill then the null terminating character these two things are different and make sure you understand the difference okay so now take a look at what we have here we have a strand we didn't specify the size and we just initialize it with hello someone might think ah this is also going to autofill but it's not because the compiler is going to deduce the size of this array using what you initialize it with and you didn't put in a null character so it's not going to be accounted for you're only going to have this here and if you print this out you may get garbage characters appended to your string here so be careful but it is possible to do literal c strings and only say hello like this in quotes and you're going to get the null terminating character appended to your string here so if we print this this is going to pretty nicely and this is the recommended way to initialize your character arrays if you want to put in string data like this you have to use double quotes and the cool thing about this is that you can even put in spaces between words like this it is going to work this really looks like how you would like to type text and store that in your character arrays and we're going to be using this a lot in the course again i want to bring to your attention that character arrays are special in that you can directly print them on the console like we are doing here you see this is a character array and we are saying stdc out message for you can't do this with other arrays and this is really all i had to share about character arrays so what we're going to do next is head to visual studio code and play with us okay here we are in our working directory the current project is arrays of characters we're going to grab our template project and we're going to copy the files bring them in here and we are going to open our folder we're going to open the main cpp file and we're going to get rid of what we don't need here let's put in some startup code so that we can start playing with this without typing this too much so we're going to declare an array of characters it's going to be called message the size is going to be five and we're going to fill it with characters like this so if we do this we might want to print it like we print any other array we're going to use loops and in this case we chose to use a range base for loop so we take a toast c c for character in message and we're going to print out each character notice that we're not adding std endl here because we want the characters printed close to each other so that we can read this easily and after this we will need to go to the next line so that the next thing we print doesn't disturb us so we're going to say sddc out std endl and if we do this we're going to see hello printed out on the console but we had to do too much work to print something simple like hello but let's do this we are learning so we're going to bring up our terminal and we're going to build with gcc let's do that the world is going to go through and we're going to clear and run rooster you're going to see that it's going to say message is hello and this is what we expect and this is really how you would declare an array of characters and initialize it with whatever it is you want to initialize it with but you notice that it's really not convenient to put data in here if you want to store a message for example for someone you don't want to do this thing you see here it's really ugly it's convenient and nobody would definitely use your program if you required your users to type things like this so we need to change this and we will but before we get there let's also see that we can change characters in our array so if you look here this e here is at index two so what we can say is a message and uh we're going to target the element on index two oh it's index one let's use that so this is index zero the h and the e is at index one let's make sure we get this straight and we're going to store in an a in quotes remember characters are surrounded by single quotes like this once we do this and we try to print the array out again using our technique here we're going to copy the code and we're going to paste it down here just to do this simply and if we do this we're going to see the message printed out here to be hello and the second message is going to be", "34496.16 - 34795.520000000004": "because we changed the second element to an a it's no longer an e so that's what we expect we're going to run the test to build with gcc and we're going to bring this up and clear and we're going to run rooster you see that we have message hello and message hello and we are able to print things successfully this is really cool but we are doing too much work really to print something on the console and there should be an easier way to do this and there is so what we're going to do is comment this out because we don't want noise output in the console when we try to do something else so what we're going to do is comment out all we've done so far we're going to leave in our message here and we're going to try and print it directly on the console so we can say sddcl and say message and we're going to print out the message and take a moment and look at this and try to compile this it is going to go through it is going to compile because c plus plus supports printing character arrays like this but uh in most times this is not going to do what you expect let's try and run this and see what we get we're going to run rooster and you see that we're lucky to get something that really isn't what we expect it's pretty hello and you see that we have a bunch of other things and the reason is what we have discussed in these slides for character arrays like this to be printed out properly on the console they need to be null terminated in other words they need to have the null character which is a backslash zero appended to the string for sddc out to know that it has reached the end of the string so this is what makes your character strings legal now you see that we are getting a compiler error because we have overflown the size of the array i think that's the message too many initializer values and this is exactly what we have done now we can try and change this guy to a six to say that we have six elements in here this wiggly line should go away and if we try to build and run we're going to build with gcc let's bring this up a little bit and we're going to clear and run rooster now and you see that now we have hello printed out correctly if we turn this back to five elements and take out the null terminator we're going to try and build again and we're going to clear and run rooster you're going to see that we get the garbage back so for your strings to be printed out correctly they need to be now terminated that's why it is not safe to prank something like this when your character array is not now terminated i really want you to understand this so in c plus plus we have a proper name for these strings that are null terminated a null terminated string is called the c string because these things come from the c programming language okay and we're going to see a few ways we can set up c strings now and the first one is to say car we can call this message one and it's going to be an array of characters and we're going to initialize this with hello let's copy this because i don't want to type all these things here so let's copy this and initialize this properly notice that we didn't specify the size so the compiler is going to get the size from however many elements we put in here and we're going to put in our null terminator here and if we print this this is going to work and we are going to comment this out and i'm going to say that this will give you garbage okay if we come down here we're going to see that we have a car array it is called message1 and we have initialized it with data we have hello and we have a null terminator here and the compiler is going to deduce the size so this is going to be a proper c string and we will print it correctly let's try and weld this the board is going to go through if we clear and run rooster we're going to get our message here and this is one way we can set up a proper c string the second way is to actually not putting the null terminator but let the compiler add that in for you and the way we can do that we can say car message to and we're going to say this array is of size 6. let's say that we're going to put in a six and a fix how we end things here we're going to put in our code and end this with a semicolon now what is going to happen is the compiler is going to see that this array is of size", "34795.520000000004 - 35097.276000000005": "the remaining slots are going to be auto filled and it is going to be using null terminators to autofill this then if we try to print the size here we're going to get a because the null terminator is added in by the compiler let's try and print the sizes here actually so that you can see these things so we're going to say size and we're going to say that size of message one and we're going to put in a new line character and this should be what we expect so what we're going to do we're going to copy this and i put that down here because we're going to be doing the same thing for message to so we're going to say message to let's select this and i say size of message to and do signs of message too so what we're going to see is a message 1 and message 2 printing out and we expect to see a size of 6 because both of these guys have six elements inside so we're going to run the task to build with gcc and bring this up clear rooster and this is exactly what we expect message one is hello the size is six message two is hello and the size is six and these are a few ways you can declare your character arrays and initialize them with proper data that is going to print correctly with stdc out make sure you don't do something like we did here by printing message here because it is not null terminated this is going to give you a lot of problems again i want to make it really clear that message three here is not a proper c string because the compiler is going to deduce however many elements we have in here and this thing is going to be of size five and we're not going to have a null terminator and if we print it out we're going to get some garbage so let's try and copy this so that we are consistent with what we've done above here and if we compile with gcc we are going to compile successfully but we may get weird things if we print out message three like we do here and you're going to see that the size is five because we only have five elements in here so let's clear and run rooster and you're going to see that we have hello for message one we have hello for message two but for message three we have things we don't expect because it's going to keep printing and it's going to go overbound and it's going to stop when it hits the first no terminating character like what we have in here okay so this is not safe don't do it make sure your strengths are null it if you intend to print them with sddc out like this okay so working with character arrays like this to print messages and do all kinds of crazy things is nice but it really isn't convenient as i said before you wouldn't expect your users to type characters like this by surrounding them with single quotes this is really ugly and it is painful to do if you want to do some productive work so c plus plus allows you to use what we call string literals and we're going to see an example of that down below we're going to say string literals and uh what we can do is car message for it's going to be an array as usual and we can initialize it with a string that is surrounded by double quotes and what this is going to tell c plus plus is you know take these things break it into characters and store this in this array here and make sure you properly now terminate this string here so if we print the size of message four we're not going to get five we're going to get six because c plus plus is going to see these double quotes and know that we intend for these things to be properly null terminated and it's going to add a null terminator so let's try and print this out so that we really are sure and we're going to weld this with gcc as we always do the world is going to go through let's go up and clear and we're going to run rooster and you see that message 4 is hello and the size is indeed a sex so this is one way we have to do things and we can even put spaces and do all kinds of crazy things and it's really cool and if we try to build this we're going to get the proper message printed out you see the world is good if we clear and run rooster we're going to see hello world how are you doing and this is really cool so from now on if we need to store a string in our program this is how we're going to do it because this is much more civilized and it is how you would really", "35097.276000000005 - 35395.52": "i have said that character arrays are really special because you can directly print them out with stdc out like this i want to prove this so we're going to try and declare another array so we're going to call this numbers and we're going to make this an array and we're going to initialize with one two three four five this is going to do and we're going to put our closing semicolon and we're going to try and print this out i'm going to say std see out and say numbers let's see what we get let's try and compile this and see what we get it is not actually going to give us a compiler error but it's not going to print what we expect and let's put a message here so that we know that it is this thing we are seeing here so we're going to say numbers and we're going to put a column here and we're going to weld this with gcc and we're going to clear and if a run rooster look out for the output that says numbers here so let's run rooster it's not a one two three four five it's something we don't really know and we will get to understand what is happening here in the next chapter for now note that you can't directly print arrays other than those of characters if you try to do that you're going to get weird numbers printed out and we're going to understand why this is the next chapter so let's say that here okay this is really all we set out to do in this lecture i hope you found it interesting character arrays have a few things you need to be careful about and we try to cover those in this lecture we are going to stop here in this lecture and the next one we're going to try and look at array bounds go ahead and finish up here and meet me there in this lecture we're going to look at what could happen if you try to manipulate data out of the bounds of your array we have seen that when you allocate space for an array the computer is going to give you a bunch of memory locations you can use to store your data and it's going to be of the size that you have specified or that is deduced by the compiler so here is an example of an array that is going to store seven elements and we have green slots for these elements and these are the locations we are allowed to manipulate in our c plus plus program if we try to go overbound for example if we try to modify something before our array or after our array it might be a memory location that is owned by another program it might be a memory location that is even being used by the operating system so bad things can really happen if you try to use data that is outside the bounds of your array let's try to look at a simple example here here we have an array called numbers we have 10 slots inside so we are only allowed to modify the memory locations for these 10 numbers and if we try to access something outside the bounds of this array something might happen but some people say that c plus plus is really funny because it should be stopping you from doing something like this but c plus plus allows you to do this if you look at code here we have an array we have 10 elements n so the valid indexes we can really use are from 0 to 9. but if we try and access something at index 12 the code is going to compile and if we run it we're going to get something printed out but that's something this is going to give you garbage data or you might be even trying to read some restricted memory and your program is going to terminate immediately and we're going to say that it has crashed if you try to write over bounce the compiler is also going to allow it but you don't own the memory so other programs might come and change that memory location and if you try to read from it again you're not going to get what you expect another thing that could happen is that you try and modify data that is owned by other programs and you might imagine how bad that really is so the message here is don't go over your array balance and you're going to be playing in the safe zone let's head over to visual studio code and play with us a little bit here we are in our working directory the current project is array balance we're going to grab the template files and we're going to put them in place and we're going to open this up in visual studio code we are going to declare an array and try to read beyond the legal bounds of our array so let's try and bring up a terminal here and we are going to build this with gcc the world is going to go through you're not", "35395.52 - 35696.479999999996": "run this we can really get anything and you see we have a number we don't really know what it means and this means that you have read out of the legal bounds of your array and c plus plus allows you to do this and the reason they do this is because they expect you the developer to know what you're doing when you try manipulating things like ray and now you know this and be careful when you are working with arrays like this so don't go overbound that's the message we may also try to modify data beyond balance so let's go down and put in the code to modify thanks and i have put a clear message here as a comment to let you know that this is really something you should be very very careful about so we're going to try and change that number to 1000 and we're going to try and print it out and see what we get but this memory location at index 12 is not something we own so other programs might come and write to this location and if we try to read from it again we might not get what we put in here even worse this memory location might be owned by other programs and if they read they're going to get what they didn't put in they're going to get what you put in and this is something bad we might try and really go crazy with us let's put in a really huge number and see that we can do that this is a good way to learn by the way it's going to compile and let's try and print what we have in there and we're going to say this location here and that's what we're going to say here and we're going to build again the world is going to go through you see that we are doing something really crazy our array has 10 elements but we are trying to modify something 1 million memory locations away and uh this is really crazy and c plus plus allows you to do this so let's clear and run did we world let's make sure we have world so let's build with gcc and clear and run rooster our program is crashing because we are trying to access something that isn't really ours and you see it has crashed okay for example if we have something printed out after this let's say std program and then so that you can see it is really crashing and say stdndl this statement here is not going to print because once we hit this location we're going to try and modify this and the program is not going to be able to do that it's going to crash the operating system is going to notice that we are trying to do something crazy and it's going to say this program is really crazy it doesn't know what it's doing i am going to kill it and it is going to stop that's basically what is happening here so let's weld again with gcc and we're going to clear let's clear and run rooster you see that it's going to try and do this it's going to try and put a value in here the program is going to end here and this is really bad because memory locations you have allocated for before here are not properly released and returned to the operating system and this is something really bad so the message is don't go overbound make sure you are working within the legal boundaries of your array welcome to this new chapter and we are going to be talking about pointers pointers are one of the important topics in c plus plus and they allow you to do some of the things very conveniently and we're going to be learning about all those tricky things you can do with them in this chapter but now i want you to have a basic understanding of what a pointer really is so far we have been working with variables like this we set up a variable in our c plus plus code we get to a point where we put a value inside that variable and we could use it for example we could print it out on stdc out or we could even store a value or assign another value to the variable we've been doing that quite a lot but there is a point we haven't really been talking about those variables have an address in memory and here for example you see that our var is stored at location one zero zero eight of course this is a simple example i came up with but i hope it drives the point home all the variables you use in your code have some kind of address in memory and we can grab that address and store that in a special kind of variable which is really a pointer so we can say that a pointer is a special kind of variable that stores addresses of other variables make sure you really understand this here we have p var so it is a pointer its type is end pointer and we denote", "35696.479999999996 - 35995.756": "type if you see something like this you're going to know that this type is a pointer to end its name is going to be p var because it's a variable and its value is going to be the address of another variable you see it is storing 1 0 0 8 which happens to be the address of our var here in memory pointers and variables we've been talking about can work hand in hand and we're going to be seeing how this is done in the next few lectures in the chapter but the basic idea is really the same here you see that we have a pointer to it but you can have a pointer ready to anything in your code you can have a pointer to car you can have a pointer to double you can have a pointer to float even pointers to custom types we haven't really talked about now but we will learn about them later in the course again a pointer is a special type of variable in your c plus program that is going to store addresses to other variables that's what it really is and we're going to start and see how you can declare initialize and use them in your code starting in the next lecture go ahead and finish up here and meet me there in this lecture we're going to see how we can declare and use pointers in our c plus plus code in the last lecture we say that a pointer is a special kind of variable that can store addresses to other variables in our c plus plus code and we have seen a slide like this to drive the point home now we're going to see how we can actually use pointers in our code here is a simple example of how you can declare a pointer variable in your c plus plus code you say ent you put a star after the type to mean that this variable is not a regular variable like we have seen before it is a special kind of variable that is going to store addresses to other variables and here i have to say that you have to be really careful and only store addresses to value the types of variable in your pointers for example this is a pointer to end it can only store an address of a variable of type and for other types if you try and put in their addresses in here you're going to get a compiler error down here you see we have another example and it's called p fractional number because it's a double and you see that our pointers here are initialized using braced initializers and this is going to initialize the pointers with a special address that really denotes that these pointers are not pointing to anything yet okay you can also say that explicitly and put now ptr inside and this is going to mean that these pointers are not pointing anywhere you can't really use the values at the addresses where they point this is the message here don't use pointers that contain null pointer all pointers on a given system are going to have the same size for example if you have a pointer to end and the pointer to double they are going to be the same size because they really store the same thing they store addresses to variables and addresses to different variables even if they happen to be of the same type on the same system are of the same size that's why all the pointers you're going to use in your code are going to have the same size and this is something you should keep in mind and here is a simple example to really play with that we have a size of it printed out we have a size of our pointers printed out and we're going to compare these things when we get to visual studio code in a minute and you're going to see that all pointers are of the same size a question i get from many people is if the position of this star symbol really matters and i have to break it to you it doesn't but i prefer to put it on the left some people prefer to put it on the right but definitely don't put it in the middle i've never seen anybody do this but it's going to work it's going to be legal c plus plus code another thing i see people do which is really confusing is to declare your pointers on the same line and do a comma like this this is really going to be confusing and now i want you to guess and see what is happening here is either it var a pointer or it's a regular end i want you to keep this in mind i'm not going to tell you we're going to try this out actually in visual studio code and we're going to figure this out together but now i want you to try and think about it we're going to leave this question unanswered and we're going to answer it in a little while but for now don't really do this because it's confusing and it's going to make your code less readable if you have to do something like this make sure you just put them on different lines and it's not going to be confusing for example if you look down here you're going to know that p number seven is a pointer other", "35995.756 - 36296.479999999996": "no room for confusion this time use code like this and don't put things on the same line like we have on top here okay now we have seen that we can declare and initialize pointers with null pointer now is the time to see how we can put actual data in those pointer variables here we have a variable which is called into var it is of type and and its value is a 43 we can also set up another pointer variable end pointer its name is p underscore int and we can initialize it with the address of another variable and here is a new operator we haven't seen before this ampersand variable here really means the address of this ant variable that's what we mean here so we're going to initialize this p end variable with the address of enter variable and this is how we do it if we go down here we print antivirus we're going to get the value printed down if we print the pointer directly we're going to get the address of this little guy printed out on the console and we're going to see it okay so this is how you can store things in your pointer variables and what you have to store and has to be an address of another variable down here you see we have another variable called into r1 inside we have a 65 and if you go down here you see that we are storing something else in our point of variable here we had in the address of into var now we are putting in the address of into var1 using an assignment operator and this is something you can definitely do it's legal c plus plus it's going to work if we print it out we're going to get a different address printed out this is how you can store values in your pointer variables again you can't cross a sign before different pointer types here we have an eight pointer which is called pn1 and we have a double variable it's called double var we can't take the address of double var and store that in pnt1 this is going to be a compiler error the variables whose addresses you store in payment 1 have to be of type and again the basic idea is that a pointer is really a special kind of variable that is going to store addresses to other variables and if your pointer is a pointer to end the variables whose addresses you can store in this pointer to end can only be ends if you try and put in doubles you're going to be in trouble you're going to get a compiler error and it's not going to work now we're going to head over to visual studio code and actually play with these things here we are in our working directory the current chapter is pointers the current lecture is declaring and using pointers we're going to grab our template files and put them in place so put them in our project here and we're going to open this in visual studio code the first thing we're going to see is how we can declare and initialize pointers and we're going to use a pointer to end as a first example we're going to set up an inch pointer and we say in store we're going to give it a name we're going to call this p number and you can leave it like this uninitialized but it is really advised to always initialize your pointers so we're going to do that with a brist initializer which is going to do that for us this is going to implicitly initialize it with zero equivalent of pointers and that happens to be null pointer so we'll initialize okay so this is what we're going to initialize with no pointer we say no ptr and this is how you should do things you can also do a pointer to double why not let's do double pointer and we're going to say fractional number pointer to fractional number and we can also initialize this with null pointer implicitly and once you do this the program is going to be legal if we try to world at with gcc like we always do the build is going to be good but we don't really have any useful thing we can see if we run this program we are just getting started we will get to see things later for now just understand that p number is a variable we have in our code this variable can only store addresses to other variables that happen to be of type and if you try and store in an address of a variable which is of type double for example or flute you're going to get a compiler error you shouldn't do that the same for p fractional number it can only store addresses to other variables which happen to be of type double keep this in mind we can also explicitly initialize with no pointer so we can say end pointer and say p number one why not and we're going to explicitly use no", "36296.479999999996 - 36598.96": "as well you can also say p fractional number and say one why not and say now pqr this is going to work this is something you can do you're going to see that if we compile this the compiler is going to be happy with this the world is good okay now you know how you can declare and initialize your pointers now we want to see that pointers to different variables are actually of the same size on whatever system you are working on it's not consistent across operating systems or riffing systems but it is guaranteed to be of the same size on the same machine i am going to go down and put in a piece of code that is going to show us all these things on the console and i am going to click on this file icon here and give ourselves some breathing room so that we can see the entire thing here if you look here we are printing the size of ant we know that this is going to be a four size of double this is going to be an eight on our system here but we don't know what the size of a double pointer is or the size of an end pointer and we're going to see that in a minute here you see that we are also using the pointer variables immediately this is something you can do you see that visual studio code is not complaining and we can go on top here and boulder with gcc let's do that the world is going to be good now we can open up a terminal and actually run this program here we're going to clear if we do there we're going to see that in our directory here so you see that we have rooster.exe and we can run this and it's going to say sizeofant is four size of double is eight this is expected but pointer types are of size 8 on my system they occupy 8 bytes in memory so it doesn't matter the type we are pointing to a pointer to it is always going to be 8 bytes in memory this is something you should really know and keep in your mind another thing we have said that i want to play with right now is the location of the star symbol some people say you should put it on the left some people say you should put it to the right i don't really think any of these dense matters i prefer to put it to the left but if you put it to the right it's also possible it's going to work you see that even if you put it in the middle here which is really crazy the compiler is going to take this we can run the task to build this to make sure the compiler is really happy and you see that there's no problem the compiler is going to accept this and we are going to build successfully if you put your declaration on a single line like this what is other ant var going to be is it going to be a regular end variable is it going to be a pointer to end we don't really know now and i don't want to tell you we're going to find out together so what we're going to do we're going to print the size of these things i am going to go down here and put in the code and come back in a minute here is our code typed out and we're going to see the size of these things what we're going to do is run the task to build with gcc as we always do let's clear properly and run rooster and you see size of p number five is eight because it's a pointer size of either end is four and the same applies to the second line here so from this we can tell that other interval and other ant versus x are not pointers they are regular integers and this can be really confusing so to avoid this confusion i would advise not to declare your thanks when you have pointers inside like this because that's going to be really confusing what you can do is put them on separate lines and do something like this so here it is very clear that p number seven is a pointer other eight var seven is a regular it variable and there is no room for confusion with this way of doing that so make sure you put things on separate lines like this and you're going to be fine now what i want you to see is that we can actually store data in all pointers i mean valid data that is not null pointer in this case we're going to set up a variable a regular end variable it's going to store a 43 inside and we're going to set up another pointer and initialize that with the address of this it variable and this is going to work properly what we can do now is print the interval we're going to print it out if we try to print the pointer we're going to get the address of this into var in memory and this is something you need to see with your eyes this is the first time we are printing out an address that is stored in a pointer and we're going to see that on the console here what i am going to do before we build and run this i am going to comment out everything we've done before because our console is now", "36598.96 - 36895.756": "so let's come and comment out everything and let's go down again now if we print we're going to see these two statements and that's going to be easier to follow on the console here the build is good so we are cool let's run rooster and the var is 43 and its address in memory is this number here it is in hexadecimal so this is the address in memory and we can print that out and see what it is okay so this is really cool but we can also change what is stored in our pointer here for example we can set up another variable call it into our one and uh change pnt which is a pointer to contain the address of this new variable and we can do that now if we print payment we're going to see that it contains a different address and we can do that so let's build with gcc again we're going to go down and clear and run rooster and we're going to see that now we have a different address the one we had ended in d e4 now we end in de0 these are different addresses and we are storing different things in our pointer this is really cool you can do something like this and the next thing we want to see now is that we can't cross a sign between pointers of different types and what i mean here is that for example if we have two variables here one is a pointer to end it is initialized with no pointer and we have another variable which is a double var it's going to be of type double and we can't do something like payment equals address of double bar you can't do something like this if you do it you're going to get a compiler error and you see that we have squiggly lines in visual studio code this is a good indication that something might be wrong if we open the problems tab we're going to say a value of double pointer cannot be assigned to an entity of type 8 pointer so this is not something you can do if you do this you're going to get a compiler error be aware of this visual studio code has warned us enough but we can also try and get a clear compiler error by building this with gcc and we're going to get basically the same thing you can't cross-assign between pointers of different types we are trying to assign a double address into a pointer to enter and this is not going to work so let's comment this out because we don't want this compiler error now you know this and before we close this lecture i want to mention what is called the referencing and that is the act of reading something through a pointer so if we have an address in a pointer we can go through that address and actually read the value contained in that address and we can do something like this so if we have for example an end pointer let's call it p and two do we have a variable like this so let's say we initialize this with nodepointer and we have an end variable and this is a 56 for example and we do something like we do say pnt2 we're going to make it contain the address of int data this is something you know you can do now now we want to go through pm to 2 to read what is contained in interdata because pn 2 contains the address of our integer here so what we can do we can do stdc out and say value and the syntax we use in c plus plus is like this we say store and we say our pointer variable we're going to say pnt2 and now if we run we're going to get the value here printed out okay now if we try to build we're going to build fine let's try with gcc the world is good we can clear so that the arrows from a previous run are cleared out you see the bullet is good we can now run rooster and we're going to see that value is 56 we are successfully reading the value stored in the address pointed to by our pointer here and this is the syntax used and this is called the referencing a pointer we are basically reading something stored in the address of a pointer this is what we mean here this is really all we set out to do in this lecture the lecture turned out to be lengthy but we had a lot of ground to cover and now i hope you have a good grasp on how to declare initialize and use your pointers to do all kinds of crazy things we are going to stop here in this lecture in the next one we're going to learn a little more about pointer to character types because they are also special go ahead and finish up here and meet me there in this lecture we're going to", "36895.756 - 37195.36": "and you can declare a pointer to a character just like this we have car pointer and we say p carvar to give it a variable name we initialize this with a null pointer and after that we set up a character variable and it is called corvar and we store in an a in uppercase a after that we take the address of car of r and assign that to our pointer variable this is how we store data in a pointer and we can go through this pointer to access data in this character variable if we do something like this we're going to print a down here we declare another variable we store in a c and we assign the address of this new character variable to our pointer variable and if we print this again we're going to get a c printed out this is really what we have done in the last lecture we are just extending that to character pointers but with character pointers you can do something really special what you can do that is special you can initialize that with a string literal something like hello world which is wrapped in quotes like this when you do something like this the string here is going to be expanded into a character array and the first character of our array is going to be pointed to by p message here this is what we mean i realize i might be throwing a lot of things at you right now i am mixing up arrays and pointers but they have a really strong relationship and we're going to learn about that in detail in a few lectures ahead but for now think of it like this this hello world string is going to be turned into a character array and the p message is going to point to the first character in this array here this is what is going to happen and this is going to give us the flexibility of treating our strengths as character pointers and this is going to come in handy at many occasions one thing i should tell you though is that some compilers will refuse to compile this code for example visual studio 19 that i have installed on my computer right now is going to refuse to compile this code and the reason is the compiler is going to expand this strength into a character array of const car and here what we are using to point to that is not a cost car pointer so this pointer here can be used to try and modify data into an array of cost cars and that's going to be disastrous because if you try to modify that that's going to fail and that's not going to be good so some compilers are going to try and protect you from this and force you to use pointers that are qualified with cost to really mean that they are closed car pointers and to get the code to work we will have to do that and i will show you how we do that in visual studio code but i have to tell you this in case you just want to jump ahead and try this code out if you get a compiler error that's going to be the reason now that we have our strength stored in memory we can really print it out like this if you print p message you're going to get this ring printed out but i want to give you a question here what do you think we will get if we dereference p message try to think about this i told you that the compiler is going to expand this hello world string into an array of characters or to be specific an array of const cards and p message is going to be pointing to the first character in that array so if we dereference p message we're going to get that character printed out in this case we will get an h and that's what is going to happen here but character pointers are special in that if you print them out directory the compiler is going to do its magic and make it possible to print out the entire string that is stored in p message here that's how character pointers are special and you really need to be aware of this because this is going to come in handy many times just to emphasize that this is going to be expanded into an array of constant characters if we try to modify something inside p message here for example we try to change the h into a b we can try to do that because p message is pointing to the first character so we can try to dereference and assign a new value and if we do that we're going to get a compiler arrow or even worse we might get a crash at run time so this is something you shouldn't really do and you should really flag your p message here as the cost card pointer and that's going to prevent you from doing things like this which may turn out to be very bad but most compilers are going to even prevent you", "37195.36 - 37495.68": "times for example if you are using a very recent version of visual studio you're going to get a compiler error but i don't believe gcc is going to give us a compiler error so we will have to try this out and see how it behaves but the message is if you have to do something like this make sure you use the cost car pointer and you're going to be playing on the safe side okay now i think you know enough about character pointers what if we want our users to be able to change this string and make it be something else for example change the first character here into a b well in that case don't use character pointers use regular arrays like we have seen before so you can set up an array like this it's going to be a character array and you can initialize it with the string literal and this is going to allow you to modify things inside so if we do something like this we will get the message printed out and the message is going to be tailored because we changed the edge to be a t and this is going to work so this is something you really need to be aware of but character pointers are very helpful in many cases and in most cases you just want to store the string and print it out you're not interested in changing it so that's why this is going to come in handy in a lot of occasions now that you know this we're going to head over to visual studio code and actually try this out okay here we are in our working folder the current project is pointer to car that's what we are exploring here so we're going to grab our template files and put them in place and we are going to open this thing into visual studio code and we're going to jump into here and set up our first const car pointer let's do a car pointer to see how this thing behaves we're going to call this message and we're going to initialize this with our trusty message here hello world okay once you do something like this your string is going to be referred to by message let's try and compile this and see that gcc is happy we can compile with gcc and uh it's going to tell us we can't really do that and this is really good for base converting a string to constant card pointer so what we are doing really is making an array of const characters and refer to it as a car pointer and this is not going to work this is a good thing so you can't really do this and this is a good thing and let's try and see if visual studio can actually do this we're going to build with msvc in this case let's do read to rooster before we do that we can right click to add and say delete let's click to it first make sure it is selected and hit delete to remove it move to recycle bin in this case now we're going to clear here let's bring up our terminal again and we're going to clear and we're going to build with gcc we're going to choose the msvc compiler if you're trying to build this world finish it with errors and the error is going to be basically the same thing this line here won't work what we can do is make this cost and make it super clear that message here is going to point to an array of const car if we try to build again i think we're going to be good now so let's try and do that we're going to build with msvc this time and world finished successfully now this is really cool and we can print this out we can say sddc out message and we're going to say message and this is going to work let's go back to gcc because that's my favorite compiler and you see that the compiler from visual studio is going to clutter our folder here with a lot of files we don't want that what i'm going to do i'm going to select all this collector here and remove that and i'm going to hit delete with the right click and it's going to go away we're going to go back to gcc and use it and build with gcc the build is going to go through because we qualified our character pointer with cost here and everything is going to be good be sure you know what is happening here because this kind of problems can be really hard to solve okay now that we have this we can try and change something inside but the compiler is not going to allow it so if we try and do something like this is not going to work because message is a pointer to closed car and we can't go through this pointer to modify something so we're going to get a", "37495.68 - 37795.840000000004": "should know but we can add the reference this pointer and print something that is inside and i want you to guess again and see that you can come up with what is going to be printed if with the reference message and print out when we run this program if we have this thing printed out here again we are the referencing the pointer and printing whatever result we get from that remember that this string literal is going to be turned into an array of const cars and the first element of that array is going to be pointed to by this message car pointer here so if we dereference this thing we should get the h here printed out that's what i think we should get let's try and bolt with gcc of course the bolt is going to be good let's clear and run rooster see that message is h this is exactly what we expect here now that we have this working what if we really want this thing here to work what if we wanted to allow our users to go through this message thing and modify what is stored inside because sometimes that's going to be useful okay we wanted to allow our users to modify this trend if you want to do that you can use row character arrays and the way we do that we can say car message one and we can make it an array and initialize that with hello world and once we do this we can go through the angle bracket syntax and modify the first character or whatever character we really want to modify in this string here in this case we are going to target the first so we're going to say message 1 and we're going to grab the index 0 because that's going to be the first character here and we're going to assign a new character let's say b like we just said and if we print this out say message one and uh put that out we're going to see what comes out if we run this program we're going to build with gcc so let's do that the world is good so we're good here if we're on we're going to get below printed down and we have successfully changed this thing here so if you don't want to allow modifications to your strength use this thing here if you want to allow modification to your strength use this syntax here and this is really all we had to say in this lecture in this lecture we're going to revisit our idea of a c plus plus program memory map we have seen that the c plus plus development workflow really goes like this we have a program typed out in our ide we pass that through the compiler and we get a binary executable which is a binary representation of the code we have in our c plus plus program you can then run that program on an operating system for example here i am on windows if i double click on my dot exe file for example our applications are called rooster.exe you've seen me run this a thousand times by now if we double click this program is going to be loaded in our computer memory and by memory i mean random access memory the memory that is going to be actively running things when they happen in your computer is different from the hard drive storage that can also be called memory and this can throw off a lot of beginners we are talking about ram here when we mean memory random access memory to be exact if you double click on your program or open it on the terminal like we've been doing the program is going to be loaded in memory and it's going to be stored in a special section of memory called program area and so far we have been thinking that our program is really loaded in real memory on our computer but that's not the case it is an idea of the memory that the program thinks it has but it's not the real thing and i am going to explain but before we explain let me elaborate on the reason why this is done if we have many programs and each program is going to use real memory on our computer we could quickly run out of memory because there are many programs you might even have hundreds or thousands of programs running on your computer you may never have enough memory to run them all if real memory was used by each program so the idea was born to create what is called virtual memory and it is a trick that pulls your program into thinking it is the only program running on your operating systems and it owns or the address space or all the memory on your computer that's what your program thanks and the view that your", "37795.840000000004 - 38096.479999999996": "memory map each program is abstracted into what we call a process you can think of rooster.exe that we have been welding as a process on the system and each process has access to the memory range between 0 and 2 to the power of n where n is the number of bits that your operating system supports for example i am on a 64-bit operating system so the range for my memory is going to be between 0 and 2 to the power of 64. and that's a lot of memory my program is going to think that it owns all that all and it can never run out it's going to do whatever it wants if you are on a 32-bit system that's going to be between 0 and 2 to the power of 32 and that's going to be your virtual memory the amount of memory that your program fans that it owns and it happens to be the entirety of your ram that you have on your system each program basically thinks that it owns the entire memory and it can do whatever it wants okay so we have the rio memory which is random access memory and we have virtual memory which is going to be between 0 and 2 to the power of n okay so now we're going to update on the idea of the program execution model because now we know more we know about virtual memory here is our c plus program it's going to go through the compiler and we are going to generate a binary file which is going to be a representation of how things are going to be laid out in memory in our program and if we run the program it is going to go through a section of the cpu called memory management unit or mmu for short so that mmu is going to be basically transforming between the memory map of each process and the radio memory layout that we have in ram what the memory management unit does is really transform between the representation we have in the memory map and the real thing we have in ram the entire program is not loaded in real memory by the cpu only parts of the program that are really going to be used soon unloaded in memory and this is going to make effective use of the memory parts that are not likely to be used are going to be discarded from memory and stored on the hard drive instead and this is really cool please note that the real way these things are done is really complicated but it is buried down into the logic of the cpu and whatever you don't really need to worry about this as a super plus programmer but there are a few things you need to know as we are about to see in this lecture so memory management unit helps out in mapping between the memory map you have in your program basically the idea that your program has of memory and the real thing that we have in memory okay here is a slide that is going to drive this home we have a few programs with their own separate memory maps we have program one through four if we execute them they are going to go through the memory management unit and the memory management unit is going to assign them sections on the real ram that we have in our computer and they are going to be using that section on the real random access memory that we have on our computer the thing is your program is going to really think it owns the entire thing but it's not just going to be using a part of it and the memory management unit is going to be transforming between the idea that your program has and the real memory that we have on our computer and the memory map is a standard format that is defined by the operating system this is why for example you can't take an executable that was set up on windows and directly run it on linux this is an operating system thing the memory map or the structure of your program is defined by the operating system that is going to be running that program so all program written for an operating system must conform to the memory map that is defined by that operating system so all programs on windows if you had a way to go in and look at the memory map they are going to be pretty similar so we have been talking about the memory map but what does it look like well here is a slide that is going to try and clear that out so we're going to have a bunch of memory locations from 0 all the way to 2 to the power of m and the memory map is really divided into a lot of parts for example we have the text section we have the data section we have the heap stack and system and this is one view you can have on this there are a few different versions of this slide that you're going to see on the internet but what is really important is stack and hip for our", "38096.479999999996 - 38395.755999999994": "store our local variables thank the a that we have here in main bc thanks we had inside functions those things are stored inside the stack section of our memory map besides the stack we also have the hip which is going to be the location where we get additional memory we can use to make things better for our program we also have the text section which is going to load the actual binary of our program so that the cpu can execute it but we're not going to worry too much about this section in this course because it is out of scope for what we are trying to do here we are going to focus on stack and hip because hip is actually going to be very important from the next lecture when we start talking about dynamic memory hip is going to be additional memory that you can use in your program if you run out of stack memory and we're going to see a few other reasons why you might want to use this as we progress in this chapter so our memory map is going to have a lot of parts but the parts that we really care about in this course are stack and heap this is really all we set out to do in this lecture i hope you have a better idea of the memory map and how this really works we introduced another view that you can have on how your c plus plus program is executed and i hope you have a better idea of the memory system and we are going to start and see how you can work with dynamic memory allocation which is going to really use the heap starting in the next lecture go ahead and finish up here and meet me there in this lecture we're going to start and learn about dynamic memory allocation and this is a technique we can use to start using hip storage that we have in the memory map of our c plus plus program we can use that to get additional memory we can use and do stuff if stack memory isn't enough for our purposes this is how we have been using pointers so far for example we have a variable we set up a pointer and we store the address of the variable n so we can go ahead and use this pointer to manipulate the variable or do all kinds of crazy things if you go down here we have a pointer p number one and we have a number one variable and we can store the address of number one into this pointer it's really the same thing like we have on top here but the pointer is not initialized at declaration here and you have to make sure you put invalid data and one thing i haven't really stressed enough is that it is really bad really bad to try and use a pointer that is not initialized for example here we have p number two which is a pointer it is not initialized it contains junk and we try and write into it okay so try to think about what we really are doing here this is a pointer that we have set up we haven't really initialized that so it's going to contain whatever address is possible it can contain an address that is used by another program it may contain an address that is being used by the operating system it's not your address to mess with and here we are actually trying to mess with that by storing in a 55 so this is going to cause the crash possibly or even corrupt data that is being used by other people so don't do this another thing is to try and use a pointer that is initialized to know for example here we have a pointer p number three and it is braced initialized this is going to initialize it to null pointer but we are trying and storing in a value here so this is also going to be bad it's not granted what you're going to get actually c plus doesn't give you any guarantees this is called undefined behavior so you're going to get a crash and don't do it as a good practice the first thing you should do is initialize your pointers before you use them you can initialize them with no pointer and make sure that you are modifying valid addresses into those pointers if you don't know what is in a pointer don't use that pointer because bad things can happen okay rule number one don't try to use a pointer that you didn't initialize rule number two don't try to work with a pointer that is pointing to no ptr that's going to give you bad things you don't want to really deal with okay so far we have been using memory that lives on the stack section of our memory map we were using variables that we have declared in the main function we were using the variables that we have declared inside some functions and that's all stuff that live on the stack now we want to see how we can use the hip okay let's take a closer look at our memory map we have the stack we have the heap and the differences between these two guys are", "38395.755999999994 - 38695.52": "the stack memory is finite so you don't have infinite memory but the same is true for the heap but hip is additional memory that you can use if you don't want to run out of stock memory for a stack memory the developer isn't in full control of the memory lifetime so if you declare something on the stack for example if you say int var1 and you initialize that to 23 you don't control when that variable is wiped out of memory the variable is going to be killed when the scope in which it was declared is going to run out and you developer don't really say when the variable dies and sometimes you really want to control when your variable dies so this is a limitation we have with the stack memory okay so for stack memory lifetime is controlled by the scope mechanism we just say that for heap the developer is in full control of when the variable comes to life and when the variable dies and this is a benefit you might have with heap storage and you might want to use this and we're going to see how we can use that in the next few lectures okay so make sure you understand the difference between stack and hip here if you look at the example here we have a variable which is called locoscope var it is stored within this block delimited by the curly braces and the variable is going to come to life when this statement is executed but it is going to die when we hit the closing curly brace here so the lifetime of this variable is controlled by the scope mechanism but it is possible to use dynamic memory or use memory on the heap and we're going to see a syntax you can use to do that the first thing we want to do it to set up employer that is going to be pointing to that heap allocated memory the way you do that you set up a pointer here we have p number four we initialize it with no ptr but what we do to allocate memory is the second statement here we say p number four and we say new end the moment this statement is going to be executed the operating system is going to allocate a piece of memory on the heap the memory is going to be large enough to accommodate for an integer so it's going to be four bytes long and it is your memory now your program can use it to do whatever it wants and no other program on the system can use this piece of memory so it is going to be yours until you explicitly return this piece of memory to the system and we're going to see how you can do that in a minute once this memory is yours you can use it you see here we already referencing the memory and the story again is 77 and if we're trying to print this 77 we're going to get it printed out okay this is how you can use dynamic memory and when you do this things are not being stored on the stack things are being stored on the heap i really hope you understand this because it is very important okay so here is our view of stack and heap so if you use new to allocate for memory stuff are going to be stored in this hip section here of your memory map here is another example to try and understand the lifetime of our variables docovar again is limited to this scope it is going to come into life when this statement here is executed and it is going to die when we run out of this scope here so if you try executing code out of this scope locovar is no longer going to be available you can't use it but that's not the case for locro ptr var because this is a pointer it lives on the heap and if you go out of this scope the memory is still going to be yours if you have a way you can access it and use it you're going to be able to use it and it is going to be yours until you decide to return it to the operating system so we have been talking about returning the memory to the system how do we do it well you use the delete keyword in c plus plus here we have our memory which is allocated using new and so the operating system is going to give us a new piece of memory it is going to be four bytes because we're going to store in an integer and we are going to be pointing to that memory through p number four here we can use this memory however we want through the referencing and do all kinds of crazy things and when we are done with this memory we are going to say delete p number four and this statement is going to return the memory to the operating system the memory is no longer going to be hours after this statement and a good thing to do after you release your memory is to reset it to no ptr so that other people know that you don't really have any valid data in that memory because if you try to use a deleted memory section bad things are going to happen that's not going to be your", "38695.52 - 38997.276": "problem of trying to use an uninitialized piece of memory don't do that so whenever you release memory also reset it to no ptr to play it safe we can also initialize our pointers with dynamic memory when we declare them and this is how you can do it we say p number five and we initialize that with new and this is going to give us a new piece of memory on the heap and it is going to be pointed to by p number five we get the same thing here but uh here we are just pointing in new values and p number six and p number seven the memory locations on the heap are going to be containing 22 and 23 for p number six and p number seven and here we have a few examples of how we can print the contents of these memory locations on htdc out and after you are done using your hip memory you're going to release it using the delete keyword and you are going to reset that to no ptr to really play it safe this is how you should use dynamic memory allocated on the heap another thing you should know is that it is really bad to call delete twice on a pointer so here we have a memory location that we allocate on the heap we stored this in a pointer and we are trying to use it here in sddc outputting whatever is inside and if we delete it for the first time that's going to be cool it is going to be returned to the system but if you try to delete it for the second time you're going to get a crash don't do this this is really bad okay now that we have a slightly clearer idea about pointers and dynamic memory allocation i think it is time we went to visual studio code and actually played with a few of these concepts here we are in our working directory the current project is dynamic memory allocation we're going to grab our template files and we're going to put them in place dynamic memory allocation let's do that and we're going to open this in visual studio code the first thing we're going to do is review how we have been using players so far we have been using them like this we had a variable stored somewhere on the stack again this is the stack memory that we are using here and we stored addresses of some variables you know pointers something like this and we could go through the pointer to manipulate that memory location for example we can print the address of that memory we can even the reference and print the value in here by doing something like we do here and we are not printing here so let's say that and say p number we can do something like this and we have been doing this quite a lot so far we can also have a piece of memory that is uninitialized and we store the address of some variable in that piece of memory and we can do the same thing for example if we print p number one we're going to get the value 12 printed out here and we could run this so let's try and do that we're going to bring up a terminal first and close this pane so that we have some breathing room and we are going to build with gcc like we always do we're going to build successfully going to clear and run rooster and we're going to see that we have these things printed out here the variable we have in here is 22 so we're going to get that if we print the variable directly if we print pointer we're going to get the address printed out we can also go through the address of operator to print the address of this variable here but we can also print our value through the referencing our pointer and we can get access to it here down here we have a pointer that is not initialized so it will contain a junk address that you shouldn't really use but we're not going to do that because we're going to store in the address of number one here and we can manipulate the value here through the pointer using the the reference operator here and if we print this p number one we're going to get 12 printed out this is pretty cool okay so this is how we have been using pointers so far let's comment this out because we're going to see some other things okay before we really look at how dynamic memory works we are going to show you a few bad things you need to be aware of so let's put in a piece of code for us to play with and here we are saying that writing into uninitialized memory is really bad so here we have a pointer it is uninitialized and we are trying and directly right into it through the reference and this is going to be bad you see that visual studio code is not complaining it thinks that we know what we are doing here and it's not going to warn us but this pointer could really be pointing anywhere including operating system specific memory and here you may be trying to modify things that your operating system is going to need so clearly the", "38997.276 - 39295.916": "happy about this and the bad things can happen to this program so now we have this memory location we're going to try and write into it and we're going to see what happens if we run this program for now let's try and take this little section here and comment it out and we want to see what happens on the program here the code here that we might want to run let's try and build it with gcc we're going to run the task to do that the build is going to be good you see that we don't even get a compiler error and if we're trying to run rooster you see that the program is going to try and run you know the operating system is going to say this guy doesn't know what they are doing and i am going to close them you see that it's not even running this statement here let's go on top here and put in an sddc out statement so that we can really see where this program is failing let's say that stdc out writing in the 55 okay so this is what we have we have a few statements other than and we want to see if we actually get to run these two things to see where the program is actually failing we are going to build it again with gcc and we are going to clear and run rooster you see that it's going to say writing in a 55 but this statement here is going to fail because we are trying to ride into memory that is not ours and the operating system is going to stop us so our program is crashing and it is terminating before it even runs the things that are down here hopefully you can see how bad this is you have designed your program to do things but it is going to stop without having done any of the other things that you have designed below so this is really bad and another bad thing is that you might have allocated some dynamic memory beforehand and your program is going to end before it even releases that memory properly and returns that to the operating system so this is bad you don't want crashes in your programs and don't ever try and use and reference memory that you haven't initialized this is one bad thing we're going to comment this out i hope you really know how bad this is and we're going to go down again and uncomment what we have done here and uh it's going to be another bad thing because we are trying to write into memory initialized to null pqr okay here we have a pointer this is called p number three and it is initialized with no ptr you can think of ptr as an address that says i don't have any valid thing in me don't use me that's what no ptr is saying so we have the pointer initialized to ptr but we are trying to store something in here and you can imagine how bad this is this is memory that isn't really valid the memory itself is saying i don't contain anything valid don't try to use me and if you try to use it bad things are going to happen so if we try and compile this program it is going to compile the compiler is not going to stop us to do something like this and these are some things you need to be aware of in c plus plus but if we try to run it you're going to see that we are also going to get a crash again let's try and put a statement in front of this failing line and uh below this line i can say done writing and i can do stdndl here and both of the programs so that we can see which std statements run and which dot after our program crashes so we're going to clear the world is good and run rooster you're going to see it's going to say what it's doing it's going to try and fail and the operating system is going to kill this program because it is crazy it is doing what it shouldn't really be doing so this is something bad don't do it be aware of this thing okay we're going to comment this out and actually look at how we can dynamically allocate memory from the heap and we're going to put in a piece of code to play with that it's not really complicated we have a pointer we initialize it with no pointer to say that this pointer doesn't point to anywhere valid don't use it and we are calling new and when we do this the operating system is going to give us a new piece of memory on the heap this piece of memory is going to have the size enough to contain it so it's going to be four bytes in memory and we are going to be pointing to that piece of memory using p number four here this is what we are trying to say here the moment we do this we own this piece of memory and nobody else on the operating system can use it so that's something you should know once you have it you can manipulate it through the pointer here so here we can go through the the reference operator and store in 77 and", "39295.916 - 39596.479999999996": "that printed out here okay this is really cool this is the first time we use hip memory and i am excited about showing you this thanks we're going to try and build this program and the build is going to be good and we are going to clear this and if we run rooster we should see a 77 pretty down let's do that i'm going to get our 77 but this 77 is stored on the heap now it is not stored on the stack and this is really really cool we can control when this variable comes alive by allocating memory on the heap and we exactly control when this variable dies if we want and we're going to see how we can kill this variable from memory but for now just take a moment and appreciate how good it is to be able to allocate stuff on the heap it is really cool now that you have used the memory it is really time to return it to the system because we have no more use for it the way you release memory to the system is to call the delete keyword and say the pointer pointing to the memory that you are trying to release to the system so we're going to say p number four here let's bring this down a little bit so that you can see the entire story so we have a pointer here and it is pointing to dynamically allocated memory from the heap this memory is four bytes large because it stores an integer we have it dynamically allocated we use it here and it is time to return it to the operating system okay i hope this is clear the moment you call the delete keyword now the memory is going to be containing some junk and you don't want to really use that anymore if you try to use it it's not your memory you're going to run into trouble so for example after we delete this memory if we try to use it i'm going to show you here i think i can let's say p number four and um storing something notice that we are using the the reference operator and let's try and put in a 45 why not so let's build this with gcc as we always do it is going to world compiler is not going to stop you from doing something like this writing into memory that you have already released to the system but we're going to see what happens so run rooster and it is going to say done writing but you see that the program has really crashed because here we are trying to write into memory that we don't really own and this is bad don't do this so the moment you delete the memory or the moment you return the memory to the operating system it is good practice to reset that memory to no ptr so we're going to say p number four and make sure it contains no ptor at least when we do this other people have a chance to check and see that that's valid memory before they use it that's the use of resetting your memory here so this is something you should do again the flow to use dynamic memory is really simple you set up a pointer that is going to point to your memory you're going to allocate the memory from the heap using the new operator you're going to specify the type you want to allocate memory for the operating system is going to give you that memory and you're going to be pointing to that memory with your pointer you are going to manipulate that memory using your pointer and doing all kinds of crazy things and after you are done with that memory you're going to release it to the operating system and please please remember to reset your pointers after you have deleted them like this that's going to make your life a whole lot easier and other developers are going to thank you for doing this when they get to use your code because your code is going to be much safer to work with okay let's comment this out and show you another example of what cool things you can do with dynamic heap memory we're going to go down and put in a piece of code and show you that you can actually dynamically initialize your pointers at declaration this is something you can do the first one is not initialized so it's going to contain junk volume p number five if we try to print it we're going to get some junk address print it out p number six we're going to dereference it and print the value inside so we're going to see that and we can do the same thing for p number six and p number seven after we are done using the pointers we are going to release the memory here and notice that we are resetting the pointers to no pointer to say that they don't really contain anything useful don't use them make sure you have something valid and before you use them this is the meaning here if you're trying to run the program you can guess what we're going to see so try and guess and we're going to build we're going to weld successfully going to clear clear not clear and we're going to run rooster and we're going to see that p number five contains some junk address okay and if we try to dereference that we're going to get a junk value this is", "39596.479999999996 - 39895.2": "because you didn't put this value in in the first place you're going to see that p number 6 is going to point to some other address but we're going to have a valid value inside because we have put that n at initialization here the same is true for p number seven it's going to point to some address and we're going to have 23 and because we put in our 23. this is how you really use these pointers another thing i want you to know is that even if we have called delete and reset these pointers they are still available for use in our program so if we want we can reuse these pointers so for example p number five we can take it and use it to allocate new memory so we can say new and and uh store an 81 why not okay so we can go down here and use that this is going to be valid c plus plus code okay take a moment and look at it it is p number five not p number and the visual studio code is going to take this because it is valid c plus plus code the memory has been returned to the operating system and the pointer has been reset to no ptr but we can reuse this end pointer to allocate new memory so we are allocating new memory on the heap the memory is going to be four bytes because it is going to contain an integer and we are using this pointer to point to that new memory so this pointer is being reused it was pointing to the memory that we allocated here which was uninitialized and we are using that to point to new memory location on the hip i really want you to understand these things because many beginners get them wrong and it is hard to correct these things in your mind once you have a wrong idea about them in the first place so make sure you understand this so if we print this we're going to get the 81 printed out but we have allocated new memory we have to remember to release it again so we have to come and say delete p number five and we need to reset it to no pointer and we're going to do that right here once we do this we're going to be playing it safe let's try and run and see that we see the at1 printed out we're going to build with gcc the world is going to go through and we are going to clear and run rooster and you see that we see our 81 and we don't have any crazy crash for example to prove that we don't have a crash we can say that our program is ending well is ending well and uh we're going to know if the program has actually reached the end before it dies we're going to build again with gcc and we're going to clear and run rooster and you're going to see that the program is ending well the other thing i want you to see is that it is really bad to call delete twice on a pointer again it is really bad to call delete twice on a pointer don't do that okay we're going to see an example of that here so we're going to allocate new memory using p number five why not so we're going to say p number five and we're going to say new and going to allocate new memory on the heap and we're going to store in a 99 in that memory we can print out the 99 so we're going to say and after we are done using this memory we are a good c plus plus citizen so we're going to call delete and say p number five okay this is good it is going to work if we will then run we're going to get what we expect we should get a 99 printed out last in our program before it ends and we see that printed out here program ending well this is really cool but if we try to call delete twice and say p number five again and try to boil you see that the compiler is not going to stop us because it thanks we know what we are doing so this is something you need to be aware of in c plus plus if we run this program you're going to see ah the program is not going to end well the c plus plus runtime or the operating system is going to get here and see uh this guy is trying to release memory twice and i don't do that this is a bad program i am going to kill it and it is going to be killed the bad thing again is that anything you have in your program after these lines is not going to run because the operating system is going to kill your program at this line here so if you had memory allocated that you planned to release later on in your program your memory is not going to be released because those statements to release the memory will never be run this is where the program is going to be killed the operating system is going to see that", "39895.2 - 40195.276000000005": "kill the program so don't delete your memory twice this is something you should really watch out for and you might think uh-huh i know this why would i call delete twice in a single line here well you may not do it like this but your program might have multiple files where you have pointers pointing to the same memory and if you try to delete that memory twice you're going to get this error and this is really good so watch out for these kinds of things and we're going to see different ways you can use to really make sure you are doing things right in c plus plus this is really all we set out to do in this lecture giving you first-hand practice on how to do dynamic memory allocation i hope you found this useful we are going to stop here in this lecture and the next one we're going to learn about dangling pointers go ahead and finish up here and we'd be there in this lecture we're going to focus on dangling pointers and show you how they can be bad a dangling pointer is a pointer that is pointing to a valid address and we have seen a few examples of this already but in this lecture we're going to focus on that and show you common solutions we can apply to these problems here and download pointers are really bad they are going to lead you programs to undefined behavior and we have seen that that can crush your program many times there are three kinds of dangling pointers we're going to look at in this lecture the first one is a pointer that is not initialized the second one is a deleted pointer and the third case may come if you have multiple pointers pointing to the same memory location and let's look at these cases one by one here we have an example of a pointer that is not properly initialized this is p number five it is a pointer to end and it is not initialized it doesn't really point anywhere and it is going to contain junk address if we try to dereference it we're going to get bad things to happen because we don't really know which address is stored in there and putting something in there might lead to a crash so this is something you need to watch out for the second kind of dangling pointer that can really lead you to bad places is a deleted pointer here is a pointer p number one it is initialized with dynamic memory and we can use it for example here we are dereferencing the pointer and printing the value inside and deleting the pointer after we delete the pointer don't really use it before you properly initialize it with some kind of memory if we try to do that this is going to be undefined behavior and your program might crash so make sure you don't do something like this another case is if you have multiple pointers pointing to the same address and here is a simple example to drive the point home we have pointer three which is pointing to dynamic memory here we are using new ant in our braced initializer and we are putting value 83 in that pointer location and here we set up another pointer p number four and we initialize that with another pointer and if we print these things out we're going to get that they contain the same address and they contain the same value we're going to see that if we delete p number three and try to use p number four later we're going to get problems because this memory has been deleted by p number three but p number four is still pointing to that and if it tries to use that it's going to be deleted memory basically and we're going to get undefined behavior so be sure you know these problems and try to avoid them in your programs okay these are problems but how do we solve them well there are a few solutions one is to always initialize your pointers the moment you declare a pointer make sure it is initialized if you don't know what you can initialize that pointer with put in null pointer first and then you're going to put in an address later when you have a clear idea of which address you can store in the second solution is to reset your pointers to now ptr after you delete the memory that's the second thing you should do every time you call delete that's going to give other developers or even yourself a chance to check and see if that memory location contains a valid address before you do that and for multiple pointers pointing to the same address you have to choose and make one pointer the master of the controller of the memory and all pointers are basically going to be slaves which can't release the memory but they can read and do something with that memory that they don't have the task of releasing that memory and here is how you can apply solution one for example we have pointer number five and we're going to brace initialize it this is going to initialize it to null pointer the other thing you can do", "40195.276000000005 - 40496.48": "memory like we are doing here with p number six and this is going to put in the value and we are going to be playing on the safe side now if your pointers are initialized developers have a chance to check your pointers against no ptr to see that they contain something valid before they use it and if they see that it contains no ptr they are not going to try and use it and this is going to be very safe for the second problem with deleted pointers we are going to reset our pointers after we call delete for example here we have pin number seven initialized with dynamic memory and 82 is stored in we can print it out all do things with it when we delete the memory we're going to reset it to null p2r so that other developers or even ourselves can check this memory against no ptr and if it's different from no ptr we can use it if it's equal to no ptr we're going to leave it alone and do something else this is going to be very safe if you have multiple pointers pointing to the same address like we have here then you're going to have to decide which pointer is the master pointer and other pointers are going to be slave pointers and before use all the other pointers are going to check against the master pointer and see that it contains valid memory because the master pointer has the task of deleting this memory let's go through this and see how this could work in practice so p number five is our master pointer we are setting p number five and initializing it with p number eight we are creating things using p number eight we can either use p number eight or pin urban eye this is going to work but before we use the memory location we're going to check against the master pointer if the master pointer contains no ptr we're not going to use this memory if the master pointer doesn't contain now ptr we're going to use this memory here okay if you go down you see that the master pointer is going to be releasing the memory and if we try to use that memory after it was deleted we're going to see that it contains now ptr and we're not going to be using it this is something cool and it is really easy to implement this safety guidelines in your programs now that you know about this we're going to go to visual studio code and show you this in action okay here we are in our working directory the current project is dangling pointers so we're going to grab our template files pretty quick and put that in our project and we're going to open this in visual studio code we are going to look at the first case of a dangling pointer and this is a pointer that is not initialized properly like p number here if we try to reference it we're going to get something bad to happen so let's see that and let's go down and say that program is ending well just to know that we didn't get a crash because a crash is basically going to terminate your program on the offending line that's what it's going to do so if the program works well and ends well we're going to print this line here let's bring in gcc to build this program and let's open a terminal so that we can run it we're going to clear the world was good and we're going to run rooster you see that the program didn't end well it crashed and it crashed because we are trying to use uninitialized memory when the operating system is going to try and run this thing it's going to see ah this guy is trying to modify memory that doesn't really belong to him it is a road program i am going to kill it and it is going to be terminated on this line here this is really bad you should avoid these kinds of situations so don't do this we are going to comment this out and show you another offending event we can do in our program and that is using a deleted pointer if you do that you're going to get something bad in your programs so here we have a small example we have a pointer to end we initialize this with a dynamic piece of memory and we're going to store in a 67 and we can print this out this is going to work pretty well but we delete the memory down here and we try to use it after we have deleted the memory so the operating system is not going to be happy about this because once the memory is deleted it is no longer our memory so we have no business the referencing pointer one and trying to use that here and we're going to get a crush and this is something you should avoid so let's try and build this and show you this in action we are going to clear and run rooster and you're going to see that program is ending well but in some cases it might crash and hopefully this shows you the danger that these things might put you into sometimes your program is going to seem working fine but sometimes when this", "40496.48 - 40796.96000000001": "number one here is being used to do something really important by the operating system you are going to get a crash so you're not guaranteed to get the same behavior every time you run your program some of you might be saying aha the program is working here daniel why are you making this such a big deal well it is a big deal because you are not guaranteed to get the same results every time you run this program so be sure you really avoid these kinds of situations let's try and clear and run the program again hopefully we're going to see it crash but we're not okay so let's clear and rebuild again and see that we have a better luck that time that's clear and run rooster it is going to end well but you notice that we are trying to use a piece of memory that has already been deleted and this is bad don't do this make sure you don't do something like this we're going to comment this out again and show you another offending thing we can do with our programs and bad things might happen if you try to have multiple pointers played into the same address and that's what we have here we have p number three and p number four here p number three is allocating new space and it is pointing to it we have an 83 inside and a p number four is initialized with p number three we can do that so these two pointers are basically pointing to the same memory location let's run this and show you that we're going to comment out this delete statement here and run the program first to really prove that they are pointing to the same addresses and they contain the same values let's build and run we're going to use gcc for that and we're going to clear and run rooster and you see that p number three the address is this and it contains an 83 p number four contains the same thanks so let's see what happens if we try to delete using p number three and using p number four later to try and read stuff this is what we are doing here and we're going to see if the program actually gets to end well we're going to build again the world is going to be good let's bring this up and clear and run rooster and you're going to see that the program is also going to end well but we are using a deleted piece of memory here and anything can really happen okay so you might get garbage you might have really any piece of junk inside or you might get a crush in some extreme cases so this is really bad don't do it don't try to use a piece of memory that you have already deleted through a pointer and these are problems you might run into in your programs if you try to use dynamic memory allocation let's look at how we can solve them and the ultimate advice is to make sure you put a little ptr in a pointer if you don't know what that pointer is actually stored at okay let's go down and look at solution one solution one is to initialize your pointer to no pointer every time if you don't have a value you can put in use null ptr that's what we are using here implicitly but we can explicitly put that end because it is good and before you use a pointer you have to check and see if it doesn't contain null pointer this is how we do it if pointer six is different from null pointer we're going to use it if it is equal to no pointer we're not going to use it and we're going to be playing on the safe side and you're going to see that the program is going to end well here if we have a null ptr inside we can say else here and say invalid address okay and that the user is going to know that they are trying to do something really bad so let's try and check against p number five so let's go and store a null pointer in p number six to really try this out and show you that we're going to get this warning if we're trying to use it and we're going to build with gcc and we're going to clear and run rooster you're going to see that invalid address and the program is going to end well and if we try to put this statement somewhere where we're not shaking against no pointer we are going to get a crash so let's comment this out so that it's clear what it is we are running here so if we run this we're going to get a crash we have seen that but let's show this again and really highlight that we are solving the problem here if we run rooster the program is going to crash because we are trying to use uninitialized memory but if we try and check against no ptr like we are doing here let's do that we're going to be playing on the", "40796.96000000001 - 41095.755999999994": "invalid address and we're not going to get a crush and the program is going to end well this is really cool so let's try and do that again we're going to world the world is going to be good we can clear and run rooster and the program is going to end well okay so if we have a value inside we're going to get that so let's put that n and say new ant and put in an 87 for example it doesn't really matter what we put in so we're going to build again the work is going to be good and we can run rooster and you see that we are getting a value here if we are not storing no ptlr in p number six and you can do the same checks against p number five but i think this is really enough so this is one way you can avoid dangling pointers the next thing we're going to look at is if we are using a deleted pointer and again the solution is to set a pointer to no ptr after we delete it here we have p number seven it has 82 inside we are using it here and printing stuff out we're going to delete it after we are done using it and after that the first thing we do is to reset it to no ptr when we do that other people or even ourselves have a chance to check it against no ptr and we're going to know that it doesn't contain anything useful for our program and if we do something like this we're not going to run into all these weird problems and our program is going to have consistent behavior across different runs and this is really cool so we're going to run this we're going to get things printed out and the program is going to end well because right now we are checking against no ptr we can even be explicit in showing the warning here we can say invalid memory access and if you run this program you're going to really know this so let's finish this up and we're going to bolt and the bulk is going to be good if we run this and run rooster we're going to know that we are doing any valid memory access after we have deleted the pointer and this is going to save you from possible crashes that you might experience if you don't do this so this is a second solution you might want to implement in your programs and i'm going to comment it out and show you how you can get away from the problem of when you have multiple pointers pointing to the same address we are going to go down and put in the code it is what you have seen in the slides and it is really nothing new so we have pointer eight and pointer nine here and p number eight here is pointing to dynamic memory and the value inside is 382 p number nine is initialized with whatever we have in p number eight so they are going to be pointing to the same addresses here but we have made p number eight the master pointer so it is the only pointer that is going to be able to delete this memory location even if we have multiple pointers pointing to that okay so every time we want to use this memory we have the option to check against the master pointer and see that we have some valid data inside if it is no pointer we're not going to use that and we're going to be playing on the safe side this is really what we are doing here if we run this we're going to see that the program is going to end well the world is going to be good and if we run rooster we're going to see that we get things printed out we're going to go through p number eight we're going to print stuff we're going to go through p number nine we're going to print stuff and if we try to use the pointer after the memory has been deleted we're going to get a clear warning that we are trying to do something really bad and this is really what you should aim for in your c plus plus programs that use dynamic memory allocation and pointers this is really all we set out to do in this lecture i hope you know how you can avoid these problems with dangling pointers we are going to stop here in this lecture the next lecture we're going to see what can happen if this new operator fails to give you the memory that you want to allocate on the heap and that's possible go ahead and finish up here and meet me there in this lecture we're going to explore what happens when new fails in the last lecture we saw that we could use the new operator to allocate for new memory on the heap and use that to do stuff and in most cases the new operator is going to succeed but in some rare cases it is going to fail and when you don't do anything about that failure your program is just going to crash and you might want to do something about that i have to say that it is very rare for new to fail in practice so you're going to see a lot of code out there", "41095.755999999994 - 41396.799999999996": "doesn't really care about checking if the operation actually failed or succeeded so this is a very rare case but if you need to handle it we're going to see how you can do that in this lecture here is a simple example that is going to try and force the new operator to fail in the first segment here we are using the new operator but we are using a syntax that is going to try and allocate a lot of integers in one go you see that it is an array but we haven't really seen how we can use an array like this so just think of this code as a piece of code that is going to allocate a lot of integers in one go and we're going to try and make this fail i have to say that this may give you an error on some compilers saying that you are exceeding the array size if that's the case no problem we're going to find another way to get this new operator to fail we are going to put a thing like this in a loop and we're going to loop a lot of times enough to exhaust the heap that is allocated to our program here and when that happens you're going to see that the program is going to crash and it is bad so new can fail and if you need to play on the server side you're going to handle that problem and we have two ways we can handle this problem we can go through the exception mechanism this is a built-in way we have in c plus plus to check for arrows and handle them we can also use the std no throw setting in our new operator and force it not to throw an exception and it's going to give us no pointer if the allocation fails i know this might sound cryptic right now but we're going to see an example shortly and you're going to understand this let's look at how we can use the exception mechanism the exception mechanism is there in c plus plus to let you handle problems when they arise and the way you use that you wrap code that is potentially going to give you problems and try and catch blocks you see here inside the loop we are saying try and inside the tri blocks we have the code that could fail we have our new operator and in the catch block you see we have a catch block here we're going to say that we have a problem and we have a way of catching the problem and if you look at this thing we have in this parenthesis after catch we have an ex variable and we can ask it what kind of problem happened leading to this exception happening in our code you can think of this like this i realize we haven't really talked about exceptions we are going to talk about them later in the course when we have enough tools to really understand what is happening but now think of them as a tool to handle when the new operator fails and you're not going to crash your program your program will keep running it will go through the end but the new operation that you wanted to do here will fail and you will be able to catch that and this is a good thing if you don't want to use exceptions you can use the std no throw option and this is a new version of the new operator you can use to tell the c plus plus system to not throw an exception when the operation fails it is just going to return no pointer and you can check for that and know that memory allocation actually failed this is what we're going to talk about in this lecture i hope you have an idea about this we're going to head over to visual studio code and actually try this in action okay here we are in our working directory the current project is when new fails we are going to grab our template files like we always do and we're going to put them in place so when new fails that's the lecture so we're going to do that and open this in visual studio code pretty quick and we are going to try and allocate a large piece of memory in one go so the way you do that we can do say end pointer let's call this data it really doesn't matter and we're going to say new and and we're going to say that we want a huge amount of events let's try and do that and we're going to go down and say program ending well to make sure we know when we are ending this program properly so let's try and compile this we're going to bring up the terminal and we are going to weld with gcc as we always do and the build is going to be good let's try and increase this number and push it to a really big number and you see that we have made visual studio code mad here array is too large so they can't really allow us to do a really large array in here okay so let's bring this down a little bit and if we're trying to compile the bullet is going to be good and if we run", "41396.799999999996 - 41696.16": "is going to not end well okay so this is really a case where new fails we can't really allocate this much on the heap storage that is allocated to this program here remember when we revisited the memory map idea we saw that each program is going to have its own memory map the memory map is going to have a lot of sections inside we have the stack we have the heap our hip is not infinite so we can run out and we just ran out with this allocation that we did here and our program is going to terminate immediately you see that it is not ending well if this is not working for whatever compiler you are using we can go and do this through a loop so what we can do we can comment this out and we can really loop many many times enough to exhaust the memory that is allocated for this process here rooster.exe in the memory map in the hip section that's what i mean and if we do this at some point the program is going to fail and we're going to get the same problem here so let's build again we're going to build with gcc and we are going to clear and run rooster and we're going to see it's going to loop loop loop and it's going to fail we're going to see the failure in a minute and we need to find a way to solve this problem we have seen that we have two options let's comment this out and uh look at those solutions here the first option is to go through the exception mechanism we can also use the std no throw option we're going to try the exception mechanism first and uh what we do is wrap possibly offending code in try and catch blocks and we're going to say try here and put a block and we're going to say catch and we're going to say std exception and we're going to put an ampersand symbol here just use this like this and we're going to get a chance to really explain these things when we have enough tools to understand this for now think of this as if i have code that is potentially going to fail like the new operator here i am going to put that in the try block and if something goes wrong we're going to get the error in the catch block this is the way we do these things here so for example i can take my loop here and copy it and put that down below here okay and i know that this line of code could fail okay so i am going to wrap that inside try and catch blocks so i am going to grab that and put that in my loop let's do that and align this a little bit and we are going to take the potentially offensive code and put that in the try block and when the operator here fails something goes wrong and we're going to catch the problem in the catch block this is what we mean here again we don't have enough tools to understand why we are doing this thing here what is the meaning of this ampersand symbol we're going to learn about that later in the course but for now we want to put together something good enough for this program not to crash like it was doing right here okay we're going to catch the arrow and say something went wrong and we're going to print out what actually went wrong we're going to say ex and we can call a function called what on this and we can say sdd endl let's hide this pen here because we want to see clearly what is happening here this is how you can prevent your program from crashing and it is going to end well because now we have handled the problem and that we haven't caused a crash like we were doing down here now we're going to try and build this code let's bring it up a little bit so that it is not messy here and we're going to weld with gcc the bolt is going to be good and we're going to clear and run rooster and it is going to do its thing it's going to keep looping around and it's going to say something went bad it's going to hit a point where all these allocations are going to fail and if we really wait for it it is going to end and we're going to see that it's going to end well let's try and hit ctrl c and terminate it because we don't want to wait for this amount of time and let's bring that down to 100 and increase this number here let's see if that actually works so we're going to boil for now we just want to see that the program is not really crushing so we're going to run rooster and you see that it's going to keep running and at some point it's going to fail to allocate memory and it's going to say something went wrong but if you keep going down you're going to see that the program is ending well", "41696.16 - 41995.68": "the new operator actually failed but we code the problem and could handle it in here so what is called handling the problem you're going to handle it in whatever makes sense in your program if we were for example trying to set up a color in some widgets in your application and the color fails and you fail to set up the color you may show your user interface in black and white and keep running your program instead of getting it crashed this is just a way to show you that you can handle stuff when new fails this is one way we can solve the problem so we're going to look at the second way the exception mechanism is the first so we're going to comment this out because we're going to see another way and let's do that we can also use the std no throw setting on our new operator when we are allocating for new memory so we're going to do that and we're going to bring up our loop here we're going to reuse that for this here we're not going to be using the exception mechanism so we're going to do something like this get rid of the try and catch block but we're going to still be in a loop here so what we can do is pass the new operator a parameter and say std no throw and when we do this if new fails we are going to get no pointer stored in data here so we can check this against the null pointer we can say f data is different from null pointer and we can do whatever we want to do we can do that and say sddc out get it allocated and we can try and compile this program so what we're going to do is run this through our compiler through gcc and you're going to see that the world is going to be good and you see that visual studio code was giving us a squiggly line because it can't really understand this but this is going to go through the compiler and it is going to work exactly how we expect so let's try and run this program we're going to ignore visual studio code for now because the world was good we could build with gcc and we saw that this was welding successfully so we can clear let's clear properly and run rooster and it's going to say data allocated a few other times and the program is going to end you see that the program is not crashing because we are also handling the problem but we are going through a new mechanism to do that and that's using the std no throw option with our new operator here this is really all we set out to do in this lecture i hope it is very clear that the new operator can fail and you have a couple of options at your hands to handle things when new fails you can either go through the exception mechanism by using try and catch blocks like we did here or you can use the std no throw option we are going to stop here in this lecture and the next one we are going to learn about no pointer safety go ahead and finish up here and meet me there in this lecture we're going to explore the concept called null pointer safety and this is a series of measures you take to make sure that when you are using a pointer it contains a valid address if you don't have a valid address inside you don't use that pointer and we do that through a series of checks we can do against the null pointer for example here we have a pointer that is initialized to null pointer implicitly through braced initializers and what we can do is check if p number doesn't contain null pointer and this is how we say it in c plus and if it contains no pointer we're not going to use it we're going to say it points to an invalid address this is something you can do it is simple in nature but it is going to save you lots of trouble this is one version we can do this on but we can also directly plug in p number and use it like this if it contains no pointer we're going to get the message printed out that we have an invalid address if we have something other than no pointer we're going to have a valid address and we can do something with that this is going to work because a pointer can also be implicitly converted into a boolean expression that our if statement expects here and it is going to work exactly how we want here so we're going to see this in a minute when we hit visual studio code before we do that though i want you to be aware that you can call delete on a pointer containing no pointer without doing the check here it is going to be okay we have seen many rules about pointers and many students will develop an intuition that you have to check for no pointer before you do anything on your pointer and they even do that before they call delete i have to break it to you that it is safe to call delete on a pointer that contains", "41995.68 - 42296.4": "something like we have here say and check if p number one and then delete p number one and reset that to low pointer this is really overkill you can call delete on the pointer and it is going to be fine even if it contains no pointer now we're going to go to visual studio code and see these things in action here we are in our working directory the current project is no pointer safety we're going to grab our template project and we're going to put that in the current project that we are interested in and we are going to open this in visual studio code open folder and we are going to put in a verbose no pointer check what we are doing here is nothing new we have a pointer called p number it is a pointer to ant and it is initialized to null pointer through implicit initialization here using braced initialization and we are checking to see if it contains null pointer if it does we're going to say it contains an invalid address if it doesn't we're going to say that it has a valid address and you see that we are using a negation here you can do this however you want if we try to build this with gcc let's see what we get the vote is going to go through and if we run rooster we're going to see that p number points to an invalid address because it contains null pointer but if we try and set up a new variable for example and say p number and let's use dynamic memory we have learnt about that and initialize that with a 7 for example and when it points to a valid address we're going to print whatever is in there we know how to do that so we can say p number and we're going to print whatever is inside and say p number through the reference end and we're going to say stdndl now the pointer is not going to contain no pointer because it contains the address of the memory that was allocated on the hip here but once we do that we have to remember to release this memory so please remember to release your memory after you are done using it so we're going to say delete p number after that and we need to reset it to no pointer in this case it really is useless because nobody is going to be using this pointer anymore the program is about to end but it is a good practice to do this even in this case because once this way of doing events is burnt into your memory it has become your habit you're going to be writing cipher c plus plus code now we're going to try and run this so we're going to build again the bold is going to go through and it is going to say that we have a valid address in memory which is this guy and what is inside is a seven and now we are writing cipher c plus plus code through null pointer safety here we can also do a direct check using p number without checking if it is equal to null pointer because this is verbose but it is something you will see in practice you can also do something like this and say if p number and you're going to get exactly the same thing so if we have some valid address inside we're going to print that let's print the same thing as in the previous code here and if we build and run we're going to get exactly the same thing okay so that's clear because the world is good let's clear and run rooster you see that we get exactly the same thing and if we didn't initialize this guy with the new dynamic piece of memory we're going to get that the memory is invalid the address we have in the pointer is going to be invalid and we're going to print that out through our code here run rooster invalid address okay the last thing i want you to see is that it is okay to call delete on a null pointer and we're going to say that here so we're going to go down here and put in a piece of code we are setting up a new pointer p number one initialized with no pointer if we call delete on it this is going to work really well and you're not going to get a crush or anything this is valid c plus plus code so if we're trying to compile this it is going to work fine and you don't really have to do a no pointer check before you delete like this because that's overkill you see that the program both successfully and we can clear and run it and we're going to get exactly the same things we had before so some people are going to do something like they're going to check for no pointer and they're going to say if p number one for example is not equal to no pointer and they're going to say something like delete here and they're going to do something like this and this is going to work but it is really overkill you don't need to do this test because it is safe to call delete on a pointer even if it contains no pointer in the first place so you", "42296.4 - 42595.200000000004": "is going to work just fine don't be afraid to call delete on a pointer because it might contain null pointer this is really all we mean by null pointer safety and i hope i gave you a few examples to make this pretty clear we are going to stop here in this lecture the next one we're going to learn about memory licks go ahead and finish up here and meet me there in this lecture we're going to learn about memory leaks and a memory leak is when you have lost access to a piece of memory that was dynamically allocated to your program you basically lose the pointer that was pointing to that dynamically allocated piece of memory here we have a few examples of that for example here we have p number which contains a dynamically allocated piece of memory which is going to contain an integer it's going to be 4 byte the value inside is going to be a 67. this p number is our only key to manipulate that memory and it is the key through which we even go to release that memory and return that to the operating system but notice what we do down here we are setting up a new number variable it is an integer and it is allocated on the stack because this is a local variable it's not a pointer it's not dynamically allocated and we take the address of number and assign that to our pointer the moment we do that we have no way to release the memory that was allocated to p number in the first place and if we do that the operating system is going to think that this memory is ours but we don't have a way to release this memory anymore because the pointer that was helping us access this memory has been repurposed to point to this number variable here i hope you see that and the memory leak is something like this when you lose the pointer that would otherwise be used to release the memory and your program is basically going to keep using this memory and the operating system is not going to have a way to reclaim this memory so it is useless so you are no longer using this memory because you can't access it and do things with it and the operating system can't use it either because it fences your memory hopefully you can see that this is a really bad situation and you should avoid these things in your application so do avoid memory leaks like a plague this is one situation in which we can have a memory leak here is another example where we have double allocation we have a pointer p number one it is pointing to dynamically allocated memory again and the value inside is a 55. if we use this pointer to allocate new memory the first memory that we were pointing to is going to be leaked again it is the same thing we have lost access to the first memory now we are pointing to the second dynamic memory that was allocated to contain the 44 here and again this is a memory leak your program has lost access to the memory containing 55 here and the operating system also thinks that you are using this memory because you didn't explicitly return it to the operating system through the delete operator again memory leaks are bad do avoid them in your programs here is another simple example of a case where you might have a memory leak you go in a nested scope like this and allocate a new piece of memory dynamically of course and point to that through p number two here but p number two itself is a pointer and it is a local variable nested in this scope when this scope ends p number two is going to die but the dynamic memory itself is not going to die you just lost access to it and you can't access it again this is a memory leak and you should avoid this in your programs memory leaks are really bad and in extreme cases they might even lead to your program crashing if your program keeps running for an extended period of time think of programs like those running in servers for example they can even run for three months without stopping and if your program is increasingly leaking memory the operating system is going to think that you are taking too much hip memory it's going to terminate your program like we saw in the lecture where we learned on conditions where the new operator failed so if you allocate too much memory then your program can really take the next operations you're going to do with new are going to fail and your program is going to terminate the message here is memory leaks are bad you should avoid them in your programs and whenever you think that you're no longer using a piece of memory make sure you delete it and return it to the operating system", "42595.200000000004 - 42896.48": "plus plus code we're going to head over to visual studio code and actually try this here we are in our working directory the current project is memory leaks we're going to bring in our template files and we're going to put them in place in the lecture on memory leaks and we are going to open this in visual studio code we are going to clean this up a little bit bring this up here we have a variable called p number it is a pointer to end and we initialize that with the address of a piece of memory that is allocated dynamically on the heap we store a 67 inside and here down you see we set up another variable on the stack again this says a stack variable it lives on the stack it's not on the heap and we text the address of this thing and assign that to our pointer here the moment we do that we have no more way we can access this dynamic memory and we have leaked it and this is really bad the thing is this program is going to compile i don't think compilers have a way to stop you from making mistakes like this so you really have to be careful and make sure that you are not leaking memory in your program so if we run this program it's going to run it's going to run and finish let's say that it is ending well okay so we're going to build and see this run the build is good so we can clear and run rooster and we're going to see that the program is ending well but we are leaking memory here because the dynamically piece of memory that we allocated here wasn't released to the system and when we did this assignment here we just lost access to it so the operating system is going to thank this memory belongs to this program that is ours here but your program is either not going to be using this piece of memory because we have just lost the key that would allow us to go and do something useful with this memory here so this is something bad and you should avoid it the second example of memory leaks is when you do double allocation on a pointer for example here we have pin number one again and we are going to make this point to an address of a piece of memory that was allocated dynamically on the heap the value inside is going to be 55 but we are using this pointer again to make it point to a new piece of memory containing the address of the newly allocated piece of memory on the stack on the heap i mean and this is really bad because again once we do this we lose access to this memory here and it is linked the program here is not going to have access to it and the operating system is going to thank we own this memory and it is going to be bad and uh down here maybe you can go and say delete number one p number one but this is not going to release the memory here it is going to release the memory here with the 44 and the memory containing 55 here is going to be leaked let's be good c plus plus citizens and reset our pointers after we delete so we're going to say p number one equals no pointer and we are going to be playing it safe here and again we just lift memory here and it is something you should avoid in your programs if you run this program it is going to run just fine so let's see that because i don't want to leave you with programs containing errors if i run rooster again it's going to end well but it is going to be leaking memory here so we don't want to leak memory avoid this like a plague we're going to comment this out and show you that you can also leak memory when you have some nested scopes in your programs okay let's go down here and put that in and here is a simple example we have a nested scope nested inside the main function and inside the scope here we are setting up a new pointer and it is going to be pointing to dynamically allocated memory and that memory is going to contain a 57. the only key we have to this dynamic memory is this p number two pointer here but this p number two pointer lives on the stack itself so when the scope here is going to end p number two is no longer going to be accessible and the memory is going to be linked if you really want to play it safe you can go do whatever you want with the dynamic memory and when you are done with that you can delete that piece of memory here while you still have access to p number two but if you don't delete here in the scope where this thing was declared if you hit the end of this scope you're going to lose access to this pointer and you will be losing access to this dynamic piece of memory and you're going to be leaking memory because you're not deleting it even if you want to delete it you won't be able to do that because you don't have a key", "42896.48 - 43196.24": "dynamic memory so if we try and do delete p number two here this is not going to compile because we don't have access to p number two p number two is scoped inside this nested scope here this is what i mean so be sure you are aware of this memory leak problem the cases we have seen here are really extensive enough to give you an intuition on how this is bad and you're going to be avoiding this new programs and you're going to be on your way to become a better c plus plus developer this is really all we set out to do in this lecture to learn about memory leads show you a few examples of them i hope now you understand them we are going to stop here in this lecture and the next one we're going to learn about dynamically allocated arrays go ahead and finish up here and meet me there in this lecture we're going to look at dynamic arrays and these are arrays you can allocate on the heap and they're not going to be stored on the stack like we have seen before the arrays we have learned about so far have been living on the stack we want to see how we can allocate arrays on the heap if we happen to need that in our applications arrays are allocated on the hip with the new operator we can also use the sdd no throw version of the new operator if we don't want exceptions in our c plus plus programs here is a simple example of how you can do that we have a pointer called p salaries it's going to be a pointer to double and it is going to contain the address to the dynamic memory that we allocate on the heap which is going to contain an array of doubles of this size here okay this is an array that is going to be initialized with junk values because we are not initializing that explicitly so this is something you need to be aware of okay p students is also going to be containing the address of an array that is going to be allocated on the heap we are using the sdd nothro version of the new operator because in this case for example we might not want exceptions and we're going to say that it is an array of events it's going to be this size but we are using breast initializer so this is going to be initialized to zero all the values inside are going to be initialized to zero this is what we mean here we also have a p scores array we are using the std no throw version of new and it is going to be this size and initialized with one two three four five okay if the array is bigger than five the remaining slots are going to be initialized with zeros just like we saw with the arrays we have learned about previously that we're stored on the stack this is really how you work with these things and i hope it is super clear again we are calling the new operator this is going to allocate however memory space is needed to store these things on the heap so if this array is going to contain 10 elements we're going to allocate enough space to contain 10 double elements on the heap and we're going to be pointing to that with the p salaries pointer that's what we mean here once you have your dynamic array allocated on the hip you can try to do things with it for example we can try and loop through the squirrels and print them out here you see that we are using the angle bracket syntax and the pointer arithmetic syntax it is going to work equally well you can choose whatever you want but i just wanted you to see that you can use both versions here the next logical thing to think about when you talk about dynamic memory allocation is how you release the memory to the operating system when you're no longer using it and this is the syntax to do it with arrays you say delete you put angle brackets and you say the pointer that was used to allocate that memory in the first place and after you do that you have to remember to reset the pointer to null pointer because you are a good c plus plus citizen and this is really all we had to say in this lecture this is how you dynamically allocate a raise on the hip before we head over to visual studio code and play with this though i want you to keep in your mind that arrays you allocate dynamically on the heap are very different from the arrays that we have learned about before and that's because they don't work with std size and they don't work for range based for loops and that the reason for all these limitations is that when you do something like this the array really decays into a pointer and it loses information that would otherwise be used to deduce the size that is used by sdd size and there are other things that are used by the range base for loop that they lose when you store and refer to them using a pointer like this that's why we have this limitation keep this in", "43196.24 - 43496.08": "allocated array on the heap you're going to be using other techniques to deduce its size and it is not going to work with a range base for loop so we will have to use other kinds of loops that we have learned about in this course and it is going to work pretty well this is really all i had to share in this lecture now i think it's time we went to visual studio code and actually tried this out here we are in our working folder the current project is dynamically allocated arrays we are going to grab our template files and put them in place and we're going to put that in the current project and open this in visual studio code like we always do and we are going to go down and put in some starter code we can play with here we're going to click on this file icon to remove this pane and we're going to try and show the code here and again you see that visual studio code is freaking out when it sees the std no throw version of the new operator here but it is going to work when we hit the compiler okay so we are allocating three arrays on the heap dynamically and we are going to be storing the addresses to these arrays and these pointers for example p salaries is going to store the address to this dynamic array which is going to be leaving on the heap and it is going to be the same case for p students here and p scores i don't think there is much to explain here because we have already learned about arrays we know about the size of an array we know that it is a piece of contiguous memory location that is going to be storing variables of the same type this is really what we're going to have so let's try and compile this and see that it actually goes through our gcc compiler and it is going to work fine and another thing you should notice is that this is really compiling even if what we are using to store the size of the array is not const remember for stack arrays or static arrays that we had on the stack we had to make sure this guy here is const okay that was a requirement and if you didn't fulfill that your code wouldn't compile now you see that with dynamic arrays the code is actually compiling even if it's not cost and this is something you should be aware of let's build this again i just messed up my things here and the world is good if we go down and run it we're not going to see anything really because we're not having any output in this program but this is how you can allocate space for a dynamic array on the heap now let's try and print some of the data in this course here let's go down here and actually do that we are going to do a no pointer check because we want to make sure that memory was actually allocated for the p scores array and after we do that we're going to loop for size times and we're going to be printing whatever element is at each iteration the index at each iteration and you see that we can either use the angle brackets notation or the pointer arithmetic notation it is going to work equally well if we built this let's bring up our terminal we haven't opened one and let's go down and clear and run rooster you're going to see that successfully allocated memory for scores and we're going to be printing the data first using the angle brackets notation second using pointer arithmetic and you see that it is working pretty well one thing you should have noticed now is that we haven't actually released the memory that we have allocated here and this is something really bad so we're going to see how we can do that we have allocated space for salaries p students and scores so let's go down and do that and we're going to say delete and we're going to have angular brackets because this is an array we are releasing memory for or to be exact a dynamic array which was allocated on the heap so we're going to say p salaries and we're going to reset that pointer to no pointer because we are good c plus plus citizens so we're going to do that no pointer and we're going to do the same thing delete we are deleting space for a dynamic array so the angle brackets here the square brackets i should say and we are going to delete p students i think yes so we're going to say p student and we're going to say p students and we're going to reset this to no pointer and we're going to do the same for p scores let's grab this here that's what we want no that's not what we want we're going to say delete and say square brackets ourselves and we're going to say p scores and we're going to release that", "43496.08 - 43797.36": "and reset this to null pointer now we are really playing it safe and our program is going to release the memory that we allocated in these three statements here if we build the program it is going to go through well so we're going to build with gcc and we are going to clear and run rooster and it is going to run pretty well you see that for peace corpse we initialized the first five elements and the remaining elements were initialized implicitly by the compiler to zero and you can see that here i don't think i explained this but this is my chance to explain this i hope you understand the next thing i wanted to explore before we close this video is the difference between static arrays and dynamic arrays a static array is an array you allocate on the stack like we have been doing before and you do it using a syntax like let's say scores why not and it is going to be an array that says it is going to contain 10 elements and we are going to put in our values in the format that we know and we're going to go all the way to 10 let's put in a 10 here and we're going to end this with a semicolon this array is cool and you can loop through it you can do all kinds of crazy things with it but i am going to emphasize two differences we have with dynamic arrays one is that this guy is going to work with sdd size so we're going to say the out okay this is going to work if we compile this we're going to get a good world at least i hope yes the world is good and if we run rooster we're going to get scores the size is 10. the other thing is that you can use a range based for loop to loop through this guy here so for example we can say for auto score s for score in scores and it is going to work so let's go down and say what we are doing here or we can even say a single line to separate fence here i don't want to be confused so i am going to do something like this so that i know where my output here is going to start so i am going to build this with gcc of course the world is going to go through and if i clear and run rooster i am going to see that the size is 10 and i am going to print my elements here with a range based for loop okay let's see how these things behave when we use a dynamic array we are going to set up a similar array but on the hip which is going to leave on the hip this array here is the static array in that it is going to live on the stack you have to be aware of these differences okay we're going to do another one which is going to leave on the heap and the way we do that we say end pointer let's say p scores one to make sure this is different from p squares that we have on top here and we're going to have 10 elements inside and we can even initialize this guy exactly like we are doing here but the data is not going to leave on the stack the data is going to leave on the heap if we do something like this first let's make sure that the code compiles we're going to try and run this through gcc and watch the compiler output here the bolt is good so this is valid c plus plus code we can try and use hdd size on that and we're going to go down and do that and if we do that we're going to say p scores size one size and say p scores if we try to pass this pointer here you're going to see that visual studio code is going to freak out because this won't work the array here has decayed into a pointer when we refer to it using a row pointer like this so we can't really use it inside std size so if we look at this we're going to get a weird compiler error but this is going to be the problem here okay so you can't do this with dynamic arrays this is one limitation the other is that you can't use dynamic arrays like we are using a range based for loop here so if we grab this loop and try to work with it on p scores for example this is something somebody might want to do let's say pscores1 okay and try to print something inside you're going to see that this is not going to work the compiler visuals video code is not going to like it first and if we try and run this through gcc we're also going to get a weird compiler arrow and the problem is going to be that p scores is really not an array it is just a pointer that is pointing to some location in memory that's all it is and it doesn't have information that could be used otherwise to loop through elements like we can do for a real static array", "43797.36 - 44096.64": "be super clear here and say that this array is going to leave on the heap you have to understand these things but this is really not a big limitation because you can store the size of this guy in some variable and refer to it if you need that and you can loop through the array exactly like we did here using size and it is going to work pretty well so don't be afraid to store your arrays on the heap if that's what you need in your application it is going to work pretty well you just have to be aware of some limitations that come with doing things this way here this is really all we set out to do in this lecture i hope you have a better idea about dynamic arrays you set them up like this the size here doesn't have to be cost like we have with static arrays and they have a few differences compared to static arrays that were stored on the stack and that std size doesn't work for them and they don't work with range based for loops other than that dynamic arrays are ridiculed and you should use them when that helps whatever it is you are designing welcome to this new chapter where we are going to be talking about references references are a way you can set up alliances for your variables and have other variable names you can go through to modify that same variable for example here we have a variable called var it is an integer it leaves at this address here and the value inside is 33. if we set up another alliance to it as var elias we can go through this var elias variable and use it in pretty much the same way we use the original valuable and this is going to come in handy in many situations as we are about to see in this chapter we are going to start in the next lecture and see how we can declare initialize and use references in our c plus plus applications go ahead and finish up here and meet me there in this lecture we're going to see how we can declare and use references in our c plus application again a reference is an elias variable that you can use to reference an original variable and use that reference in pretty much the same way you use the original variable let's see how that can work in c plus plus here is a simple example we have two variables one is an integer we have 45 n the other is a double we have 33.65 n we want to set up references to this variable and the syntax is ridiculously easy for the edge value its reference is going to be something like ant ampersand you put the ampersand symbol you say the name of the reference and you initialize this with the value in the variable that you want this to reference so reference to h value is going to be referencing our integer here and we can use this name to reference this variable here and it is going to be like we are using the original variable which is interval here we're going to see how this works in a minute we can do the same using assignment initialization and down here you see that we have an example for the double value and we have a reference to it once we have these references we can use them like we use the original variables for example if you come here you see we are printing stuff out if we print any value we're going to get the value printed out if we print double value we're going to get the value printed out we can also print through references you're going to see that they are going to print exactly the same value as we have in the original variables but the interesting thing is going to be that if you print the addresses through the original values and print the addresses through the references you're going to get the same addresses printed out which is really going to say this to variable names are almost exactly the same thing in c plus plus and this is really cool you can use the reference as if you are using the original variable name in your c plus plus code we're even going to try and go through the sizes and print them out and you're going to see that they are going to be exactly the same thing and we are going to see how important this can become in c plus plus code as we go through this chapter okay now that we have the reference declared we can go through that and modify the value and if we do that the changes are going to be reflected in the original variables and if we print stuff like this again we're going to see that the changes are going to be reflected in the original variables okay if you modify the original variable the changes are also going to be reflected in our references and this is exactly what we would expect from our references okay so this is really all there is about references they are alliances to your variables and you can use them pretty much the same", "44096.64 - 44396.32": "over to visual studio code and see some of these things in action here we are in our working directory the chapter is references and the lecture is declaring and using references we are going to grab our template files here and we're going to put them in place and we are going to open this in visual studio code we are going to set up a new variable let's call this data or it's data this is going to be much more descriptive and we're going to initialize this with a 33 why not and we're going to do a double and say double data and we're going to put in a 55 in and we're going to set up references to these variables and again a reference is an elias that you can use in pretty much the same way you use the original variable so we're going to set up a reference to int data we're going to say and reference mean reference by putting the ampersand symbol here and we're going to say rough and yeah and you initialize that with the variable name you want this reference to reference and uh here we want to reference into data so we're going to pass in into data and this is going to be it our reference is declared we can do the same for double data so let's do that double and we're going to say it's a reference we're going to say rough double data and we're going to reference devo data here so let's do that okay let's bring up our terminal and see if we can compile this code here we're going to compile with gcc like we always do and let's close this then on the left because it takes up some of the space here the world is good so this syntax is valid c plus plus syntax so what we can do is read values from all these things and show you that they really are the same things so we're going to print stuff out and i am going to put here some code and i am going to come back when i have typed this i don't want you to suffer watching me type these things okay here i have the code type down and you see that i am just going to print dana through the original variables i am going to print the actual data and print the address of the variable and do the same for the debo data which is of type double how convenient and we're going to print references we're going to print the reference and the address of the reference and we're going to do the same thing for our ref devil data here let's try and build this with gcc so we're going to run the task to do that and we are going to clear the book is good and run rooster if we run rooster you see that let's put a separate end line here so that we see the entire thing so i really like to see my fans easily so let's do that and build again okay the build is good we can clear and run rooster now and we're going to see the original data and data is 33 the address is this guy here we have demo data the value is 55 and this is the address if we look at our references we have exactly the same thing the addresses are even the same it really is like we are using the original variable and this is really cool it can allow you to pass data around much easily using references and whatever you are using when you have sent this data for example to some other file or some other function you're going to be affecting the same data okay so you're not going to be making copies and we're going to see how cold this can be especially when we get to working with functions this is going to be super cool okay now we have seen that the references are really referencing the original values let's try and modify the data through the original values and see that the references are going to pick up the changes let's do that we're going to take 80 data and change that to 111 and we're going to take the apple data and change that to 67.2 why not and after we do this we're going to print data again so we're going to grab the code here and use that again here and we should see the same changes applied so we're going to weld with dcc the bolt is going to be good as you see here and if we clear and run rooster we are going to see that the value is 55 let's put a separation line in here this is cramped and it is really hard to see what is happening here so i am going to put an std endl in here and weld again so let's do that and the book is good so we can clear and run rooster again and now we see things separated out and it is easier on the", "44396.32 - 44695.116": "the depot data is 55 and we are going to print our references which are going to pick up the same things because a reference is really analyzed to the original variables but if you go down you're going to see that the data has actually changed and together has changed to 111 and nabodana has changed to 67.2 and the interesting thing is that the references have also picked up those changes because they really are referencing the same things in memory it's like we are using the original variable to read these things like we are doing with references here and this is really cool here we have used the original variables to modify data but we can also modify the data through references and the original variables are going to pick up those changes so let's do that we're going to say ref data and we're going to change this to 12 for example and let's use 1014 or 12. this is going to do we're going to do ref double data and put in another large number let's say 1000.45 why not and we're going to print the data again so we're going to grab this and print stuff out again so we're going to go down and put in the code to print stuff and you see it's going to use the original variables and the references and we should see the changes reflected in our terminal here so let's do that and we're going to weld with gcc as we always do the bullet is going to be cool we're going to clear and run rooster we're going to see that we have 33 and 55 the references are going to pick that up that's what we have here we're going to put in 111 and 67 through the original variables and the references are going to be picking that up and we're going to use references and modify data you see that the original variables are also picking that up because we are really modifying data in the same memory location that's why these changes are being shared between references and the original variables and this is really all we set out to do in this lecture to show you how you can set up a reference and prove that the changes we do either through original data or references are reflected between these two guys meaning references and the original variables we are going to stop here in this lecture in the next one we're going to do a comparison between pointers and references because they seem to be doing quite the same thing go ahead and finish up here and meet me there and this lecture we're going to be looking at the similarities and the differences between references and pointers okay we know that a pointer is really something that is going to store the address of the variable and we can go through that pointer and modify the original variable or really do things with that but in the last lecture we saw that we could also do the same thing with references so why have these two mechanisms in place and what are the differences between them here is a simple slide that i put together to put the important points about references and pointers together the first thing is that if you use references you are not going to go through the star symbol to the reference and get to the value you are manipulating so that's going to really feel like you are using the original variable but with pointers you are going to go through the referencing so that's the first difference another thing about references is that you can't change them to reference something else later but with pointers we saw that we could do that we can change a pointer to point somewhere else if it happens to be a non-const pointer the other thing is that for references you have to initialize them at declaration you can't declare a reference and not initialize that if you do that you're going to get a compiler error and we're going to see that in a minute but for pointers you can declare a pointer and not initialize it and it is going to just contain a junk address and if you try to use that uninitialized you are going to be setting yourself up for trouble so we saw that so these are the main differences between pointers and references and now we are just going to be looking at how these translate in code here is a simple example we have a variable called double value which happens to be double and we have a reference to it and a pointer to it so you already know these concepts now if we want to read the value in here through our pointer and references we're going to be using two different syntaxes if we go through the reference we can use this reference variable name directly and read the value or change it and we can do something like ref double value to print that out this is going to work but if we want to go through the pointer we will have to go through the referencing and this is really bad", "44695.116 - 44996.560000000005": "this syntax they think that it is not direct enough so they prefer to use references to do these kinds of things but pointers are still important as we will see later as we progress in the course so this is one difference with references you don't have to go through the dereferencing mechanism to use this star here to print stuff or even manipulate the data inside you just use the variable name and it is going to work with pointers you have to reference because if you don't the reference you're going to be referring to the address stored in this pointer this is the first difference and we see that the same applies if we are trying to write data into our variable if we go through the pointer we will have to dereference and use this dollar symbol in front here if we are using a reference we can do that directly as if we are modifying the original variable so this syntax is much more readable the other difference is that we can't make a reference reference something else but we can change a pointer to point to something else let's look at an example here we have ref double value which is a reference to double value and here we are doing an assignment to this thing here we are saying either double value and assigning that to our reference but what we are doing here is not making ref double value reference this other variable we are just grabbing the value in other double value and assigning that to our reference and the value in either double value is going to be reflected in the original value here so this is what we are doing we are not reassigning to our reference to make it reference something else we are assigning the value to the reference as it is now and it is going to be still referencing the same variable in memory if you print out the address in memory you're going to see that the address of the reference here hasn't changed so this is something you should keep in mind but we know that a pointer can point somewhere else if we have a pointer here for example p double value we can reassign it another address and make it point to that new address so in this regard we can think of references as cost pointers because cost pointers can't also be made to point somewhere else and if you're trying to do that for example here we have a cost pointer it is called cost p double value and if we try and make it point somewhere else through this assignment here we're going to get a compiler error okay so this is really all in terms of the comparisons that we had to make between references and pointers now we're going to head over to visual studio code and see how these things work in real code so here we are in our working folder the current project is comparing pointers and references we are going to grab our template files and put them in place and we are going to open this project in visual studio code like we always do we are going to go down and put in some starter code and let's align this a little better so and we can close this pane so that we have some breathing room here we have a variable of double type and we set up a reference to it and a pointer to it this is how we do this thanks you already know this and we can try and read through the original variable through the reference and through the pointer and see how these syntaxes differ and how one might be better than the other for example if we look at how we are using the reference it's really like we are using the original value here we don't have to do reference if we try to print the pointer directly like this without the referencing this is going to print the actual address stored in this pointer it's not going to print the actual value stored in the address pointed to by this pointer i really want this to be clear so this is the syntax we can use for reading stuff either through references or pointers we can also use these syntaxes to write stuff into our variables for example here we can go through the pointer and we have to the reference and we can go through the reference to really do the same thing and we're going to see that our syntaxes here are going to pick up the changes regardless of whether we write through pointer or a reference because all these things really are going to be referencing the same location in memory let's try and bring up a terminal here and we are going to world with gcc let's do that the build is going to be good and we're going to clear and run rooster and you're going to see that at first we're going to have a 12 point 34 in that's going to be the value we can get it through original value the reference or the pointer through the referencing and the address is this one here if we change the value through the pointer we're going to see the changes reflected here and if we change the value through the reference we're going", "44996.560000000005 - 45296.0": "this is how you can use pointers and references to do these things here and you can really choose what makes sense for your application they mostly do the same things but some people say that the syntax to the reference the pointer here is really ugly that's why most people prefer to use references like this but references have other benefits as well as we're going to see as we progress in the course another thing i want you to see is that you can't change a reference to reference something else in memory for example here we have our reference which is ref double value if we try and make it reference something else we're not going to get that result let's go down and try to do that so we're going to set up another double variable so if we try to make our ref double value reference this guy the syntax that comes to mind is saying ref double value and assign that the some other double value here now let's see what happens if we do that we're going to try and print whatever we have in memory using the ref double value here let's grab this and go down here and say that we are changing the reference making the reference reference something else let's say that so if we try to build this let's see what we get we're going to run and build with gcc and we're going to try and run this clear not clear and we're going to run rooster we're going to see that the last line of output here say 78.45 but the address is still the same so we are still referencing the same memory with our reference and what we just did here was just grab the value in some other double value and assign that in here but the reference is referencing the same memory location it's been referencing so in c plus plus you don't have a way you can go through to make a reference reference something else the only chance you have to make it reference something is through declaration here and that's the reason you can't declare a reference and not initialize it if you do that you're going to get a compiler error so let's try and do something like this we're going to take out this double value and the moment we do this you're going to see that visual studio code is going to be unhappy you see the squiggly line and it is going to say initial value of reference to non-cos must be an l value so what is that okay if we take out the initialization altogether it's going to give us a better error i think reference variable requires an initializer so every time you declare a reference you have to initialize it and we should do like we just did before here and we're going to be fine again you can't declare a reference and not initialize it if you do that you're going to get a compiler error and the reason is that this is the only shot you get to make your reference reference something else okay if there was a way for you to bypass this and let the compiler compile this you would never get another chance to make this guy actually reference something and it would really be a useless reference so make sure you understand this you can't make a reference reference something else and if you try to do something through a syntax like this you're going to be assigning the value of whatever variable you have to the reference you're not going to be making the reference referencing something else the reference is going to keep referencing the same variable in memory as we have seen here so let's say what we were trying to do here but we know that we can make pointers reference something else so here we have a pointer again this pointer called the p double value and it has the address of double value inside but we can set up another variable okay so we can make that reference this other variable here and let's do that you're going to see that our pointer now is going to be containing another address so what we can do is say p double value which is our new pointer and we're going to assign it the address of some other double value and if we print the data now and go down we are going to say make the pointer point to something else that's what we are doing here and we're going to say the same thing here through a comma and if we print this try to guess what we're going to get the pointer is going to contain a completely new address because we can do that we can make it point to somewhere else let's run rooster and we're going to see our data here let's make sure we see the entire fan okay i think this is the data we have", "45296.0 - 45595.916000000005": "there's no harm in that so we have our fence that we have seen before but what is going to be important here is that pw value now contains a new address okay so this is really important and you have to understand that so we made the pointer successfully point to something else and if we change the data in the pointer now we're not going to be affecting the data we have in here in double value we're going to be affecting the data we have and some other double value here let's do that we're going to change the data through the pointer so we're going to say p double value and we're going to change this to 555 and now we can print the data and see that things have changed in memory and we can print this to see the differences here but before we do that let's also print the address of the original variable and the address because for now we are just printing only the address through the pointer so what we can do here is grab htdc out and say address of double volume and we're going to put that out through htdc out here we're going to do that and we're going to print the address of the reference why not ref double value and we're going to put that out as well i'm going to say address of ref double value and we're going to say std endn and after that we are going to grab the entire thing here and print it out after we modify the value in the pointer i hope this is going to show thanks in a much more clear way so we're going to weld this with gcc let's do that the build is good so let's clear and run rooster and what you're going to see is that now the original variable is living at address here which we can see in our reference but the pointer now is pointing to something else no wonder that the changes we did through the pointer are not being reflected in our double value because these two variables now are living in different memory locations i really hope you see that and this is really all we had to share in terms of the differences between pointers and references i hope you have a clear picture of what these two things are and we are going to stop here in this lecture this one we're going to see how the const key world works with references go ahead and finish up here and meet me there in this lecture we're going to see how the const key world can be used with references and again the idea is to set up an alias to a variable and make it const so that we can't go through it to modify the original variable this is the syntax we used to set up a non-const reference that we have seen so far so for example we can say int age put in a value 27 in this case and set up a reference to age and initialize that with the age variable once we do this riff edge can be used to modify this edge variable here and whatever is inside for example we can go through ref age to increment the age and if we print the edge now we should get a 28 printed out because this reference is going to change these two things at the same time or another way to say this these two things age and ref age are referencing the same memory in your computer so if you change one the other is going to pick up the change we can also set up accounts reference and the syntax is ridiculously easy you say constant reference like this and your reference is suddenly caused and you can't go through it to modify the original variable if you need something like this in your application this is how you do it you can also duplicate the behavior with count references with pointers and for that we can use a construct like const end pointer cost this is going to set up a cost pointer to cost which we can't use to modify the value that we are pointing to but it can't also be used to point to something else so this is going to simulate the behavior we have with references and you can do that if you want and please know that we have no such thing as constant reference cost this is going to give you a compiler error because we have no such concept in c plus plus and my head is hurting right now trying to think about what this would even mean and another thing i want to make clear before we head over to vg's video code and play with us is that the const key world is going to apply to the variable name that you apply it to for example here we have cost reference age which is going to be a const reference but this doesn't mean that the edge variable here has to be cost okay it can be cost or it may not be cost but the cost here applies to this", "45595.916000000005 - 45895.115999999995": "can't go through this variable name and modify the age if you're trying to do that we're going to get a compiler error now we can head over to visual studio code and play with us here we are in our working directory the current project is reference and cost we're going to grab our template files pretty quick let's do that and we're going to put them in place and we are going to open this in visual studio code we are going to review the references we have seen so far in this little example here we have the edge variable it has a 27 inside and it is a net and we have a reference to it and this reference is not const so we can go through this reference modify the age and if we do that this is going to work and if we print the edge here we're going to see that it has turned into a 28 and we can try and print this through the terminal so that you can see this for yourself so let's run the task to build with gcc we are going to clear and run rooster and if we do that you're going to see edge is 27 now it is 28 and we have successfully modified data through our reference here but if we change this reference to be const we won't be able to do that anymore so let's try and make it a const reference if we do that we're going to get a compiler error if we try to do something like this because this is now a const reference we can't go through it to modify our data here and we're going to get a compiler error here we have visual studio called complaining here but if we ignore that and go through the compiler we're going to see that we get the same compiler error we can't implement a read only reference which is this ref age here so this is what a cost reference really is you can't go through it to modify the data that is being referenced and another thing i want you to really understand is that this const keyword here has nothing to do with the original variable this is a constant reference we can't go through it to modify the edge variable but this doesn't matter if age is either const or not const the constants here applies to this variable name here so this cost h may be cost if it's cost it's going to work equally well and we're going to still get a compiler error here if it's not cost it's going to be the same the cost we have on our reference applies to this reference variable name here this is what i want you to understand okay this is what a cost reference really is another thing we want you to see is that we can simulate the same behavior with pointers so let's set up a const pointer to const on this edge here and we're going to see that we can have the same behavior but for that we're going to have to comment this out because we don't want noise output and we're going to go on top here and comment this out and say what we are intending to do we can say that we are simulating reference behavior with pointers and the way we're going to do that we're going to say const and pointer cost and we're going to say ph and we're going to initialize this with our age variable or the address of our age to be super clear okay so we have our pointer set up let's try and go through it and modify the age let's see what happens we the reference because this is a pointer and we're going to say ph and say plus plus or even change this to another age let's say 45 and if we do this we're going to get the same compiler error so if we build this let's clear here clear not clear and above again we're going to get another compiler error saying that we can't modify something that is read only assignment of read only location this pointer can't be used to modify the data in this age location here so this is the same behavior with references because the reference by default can't be made to point somewhere else we had to make this pointer also a const pointer preventing us from making it point to other locations so this is how you can simulate references with pointers and this is really all we set out to do in this lecture i hope you found it interesting the main idea was to let you know how you can work with cost references and once you have your const reference you can't go through it to modify the original data if you do that you're going to get a compiler error welcome to this new chapter where we will be doing cool stuff with text data we have seen that we can model a character array and store in a bunch of characters and we could for example call this character array message and manipulate it in memory in this structure we will see that this is actually the way text data is stored in", "45895.115999999995 - 46197.200000000004": "facilities built on top of this character already construct to make it easy to work with text data we will see that we can use character arrays to model c strings which are a facility we use in c plus plus to handle text data and we will see that there are a few built-in facilities we can use to manipulate that we can get the length of a string we can concatenate strings and put them together we can copy strings we can search for data inside strings we can do all kinds of crazy things but we will see that c strings are not that easy or convenient to work with for example you need to keep track of how big the string is in memory you need to also remember to make sure it ends correctly and we will see the details about that in this chapter long story short c strings are not safe or convenient to work with in c plus plus and c plus plus provide another type that really builds on top of character arrays but it gives us an easier interface to work with and we can just focus on storing in the data and doing stuff with it in our c plus programs and the big idea about what we're going to be doing in this chapter is learn about the facilities we have in c plus plus to handle text data in our c plus plus programs in the next lecture we're going to start and show you how you can manipulate individual characters in a character array go ahead and finish up here and meet me there in this lecture we're going to be learning about some facilities in the c plus plus standard library that can help us manipulate characters and here are a few things you might want to do with those facilities for example you might want to know if a character is alphanumeric or if it's a number or a character you might want to know if it is alphabetic you might want to know if it's a blank character you might want to know if it's a lowercase or uppercase character depending on what you want to do in your application of course there are facilities to check if characters are digits there are even those that help us you know transform characters make them lowercase or uppercase and we're going to see these examples here all of these are documented at cppreference.com so you can go there and find the documentation here is the same link opened in my browser you see that they leave in the cc type library so you need this included if you want to use them and you see that there is quite a bunch of them we are going to cover just a section of them and i will leave you to use the documentation if you need to use any more of these guys our first example here is going to help us check if a character is alpha numeric and the function we're going to use from the c plus plus standard library is std is l num and you just pass it a parameter of a character and it's going to tell you if a character is either alphanumeric or if it's not if it is alphanumeric you're going to get a value that is different from zero which can be treated like a true if it's not you're going to get a value that you can treat like a zero and how do i know this well we can check the documentation so if i come back to our link here and there is a function here is i'll num i can open it in another tab and it is going to tell me what this function does checks if the given character that you pass as a parameter here is an alphanumeric character as classified by the current siluca so it's going to tell us if the character is alphanumeric or not you give it a character and what you get from it is the return value here it's going to return a non-zero value if the character is alpha numeric so this non-zero value which is an integer because that's what we get out of this function is going to be treated like a true and if this character here is not alpha numeric we're going to get zero that we can treat like a false this is really cool and if you go down here you're going to find a few examples i don't want you to worry about this c local thing it is a setting that allows you to say more about the meaning of the characters that you are storing in memory but for now we're just going to be happy with the defaults and use this function as is it is going to work enough well okay here is our function again so here c is alphanumeric we expect to get a value different from zero because c is alphanumeric and the second example here is not alphanumeric so we expect to get a value that is equal to zero and we can use the return of this function in a test for example we can say a character we put in a star here it is called input car and we say f is al num and we pass this character we're going to print out this character is alpha", "46197.200000000004 - 46495.200000000004": "is not alpha numeric you can do that and you can do all kinds of crazy tests in your c plus plus applications here is another example that we can use to know if the character is alphabetic so it's going to return a value different from zero if the character is a an alphabet character a through z that's going to return something different from zero and if we pass something that is not for example this second line here or the seven at the third line here we're going to get a value equal to zero because that's not alphabetic we have another facility to help check if a character is a black character and we see an example that here we have a character array called message we have a couple of blanks inside and we can hunt for them using the ease blank facility from the c plus plus standard library here we have a variable that is going to keep track of how many black characters are in here it is initialized to zero and we're going to loop around okay and we're going to look by the amount equal to the size of the message array here we can use std size again because this is a row array it is a static array and we can use sdd size it is going to give us how many characters we have in this array you already know this and if we get inside we are going to try and check and see if the current character is a blank if it is we're going to print that out and we're going to increment our blank account by the time this loop is done we will have printed out a lot of blank characters if we happen to have them in our message and at the end we're going to say in total we found however many blank characters this is what we're going to see if we run this program and hopefully you can see how useful this can be in text processing applications if that happens to be what you are working on we're going to run this example in visual studio code in a minute here is another example that we can use to check if a character is uppercase or lowercase we have an array of characters here inside we have some text and we have a few variables to keep track of how many characters are lowercase or uppercase we're going to set up a loop which is going to be a range based for loop and we know that through std is lower we're going to increment the lowercase count if it is uppercase we're going to increment the uppercase count this is how we can do this and we are going to print that information when the loop here is done okay we still have a few examples ahead the current one is going to check if a character is a digit if you want to do that you can use this and we have a character array here and we're going to have for digits inside this message here so we're going to do basically the same thing we're going to set up a variable that is going to keep track of how many digits we have in this message we are going to loop around using a range based for loop we're going to check if the current character is a digit and we're going to increment our variable here if it happens to be the case and at the end we're going to say how many digits we found in our message here it is this simple the last example we're going to look at is to help us turn a character into lowercase or uppercase and here is an example that is going to help us play with us we're going to have a character array called home the feeling of belonging and we will set up a destination character array that we're going to store whatever we want to set up in here you see a loop that is going to turn our message here into uppercase and you see we're going to loop around by this amount the size of original strength and we're going to be grabbing each character at each iteration and turning that to uppercase this is what std to upper function does the result of that is going to be stored in our destination string and by the time we are done here original string is going to be however it was but uppercase string is going to be stored in our destination array and if we print it out we should see this thing printed in uppercase we can basically do the same thing and turn the string into lowercase and our destination string is going to be now lowercase and you're going to see that this works out pretty well now that you have a basic understanding about how these things work we're going to head over to vg studio code and play with us okay here we are in our working directory the current project is character manipulation we are going to grab our template files", "46495.200000000004 - 46795.2": "this in place and we're going to open this in visual studio code pretty quick and we are going to go down and put in our first example this example is going to be using the std is al num facility and this is going to be checking if the character is alpha numeric we're going to see what we get from this if we print this out we're going to check if c the character c is alphanumeric we're going to see what we get and we're going to check if this character here i don't know how to pronounce it i'm sorry we're going to check if it is alpha numeric we're going to see that and we're going to use this in at condition we're going to check and see if our star character here is alphanumeric and we're going to print that out we're going to say it is alpha numeric or it is not from the documentation we know that this thing lives in the cctype library so we may want to include that but it is possible that it is coming from iostream here that's why we don't see visual studio code complaining here as an example if we try and comment out this include here you're going to see that this is not going to make sense anymore okay so the include needed to use these guys here is coming from io stream okay so we're not going to include that here we are going to open up a terminal and build this with gcc and you're going to see that the block is good if we go down and clear let's clear properly and run rooster we're going to see that c is alphanumeric because we have a one the one can be treated like a true and the character here is not alphanumeric because the result is zero and you see that the star here is also not alpha numeric and we know this through our test here and you see that we can do things like this with this facility here if you want to get true or false from this function you can turn this into booleans using static cast but we're not going to do that here you already know that we can comment this out for now and look at another facility from the cctype library there are many of these we're going to look at quite a few of them we're going to comment this out and go down and put in a code here and this is going to check if a character is alphabetic so if it is an alphabet character a from z lowercase and uppercase c is alphabetic the character here is not alphabetic and seven here is not alphabetic so for the first one here we're going to get something not equal to zero we should get a one that's what they use in most cases for this we're going to get a zero the second one and for the third one we're going to also get a zero this is what we expect we are going to build with gcc of course and we are going to clear and run rooster and we're going to get that c is alphabetic this guy is not alphabetic and seven is not alphabetic if we change this c to uh e for example lowercase and both again you're going to see that the results are going to be what we expect e is alphabetic let's clear and run rooster this is going to be exactly what we expect but you see that it is not a one and this is not guaranteed to always give you a one it is guaranteed to give you something different from zero if the character is alphabetic and zero if not and we can use this guy here in a test for example we can say f sdd is alpha and if we're boiled the both is going to be good and we're going to clear and run rooster and you see e is alphabetic i should put a space here i do encourage you to change these characters up and see what you get here and see how you can use this that's in tests that's the best way to learn okay before we continue i do encourage you to try and run these methods through different compilers for example here we also have an msvc compiler from microsoft setup so we can use that and try to build this thing here but before we do that let's bring up our pen here and remove rooster.exe here because we don't want to override it we're going to select it and do delete and i am going to remove this and move that to the recycle bin and i am going to clear whatever i have here on the terminal and i am going to go there i am going to choose run task and i am going to choose world with msvc here i am going to use that it is going to build my thang you see the output here and we have rooster.exe here and it should say that the world is good in a minute world finished successfully microsoft is going to give us a lot of", "46795.2 - 47095.116": "good if we go in we can actually check and see what we have in our folder here you're going to see that we have these files one of them is rooster.exe if we run it we are going to get the outputs that we expect and you see that it is exactly the same thing we got with gcc i am telling you to try and use different compilers because some compilers are going to flat some of the facilities from cctype or those that start with c as unsafe because there are some tanks that can really throw you off about them and we're going to learn about them in this chapter as we move forward just know that it is a good idea to try these things on different compilers and see the errors you get and make yourself familiar with those things for now we're going to move on and we are going to keep using gcc because that's my favorite compiler you can use whatever compiler you want the next example is going to check if the character is blank let's close this thing and clear and give ourselves some breathing room we're going to bring this down a little bit and we're going to check if the character is blank the facility for that is std is blank and if it's a blank character we're going to get something different than zero and we can use that in a test like this and if it's not a black we're going to get something equal to zero and this test here is going to fail so what this example here is going to do it's going to count how many blank characters we have in this message here and we're going to print the counter of that on the console using this line here so let's go through this loop and see what it does the first thing we do is initialize blank count to 0 and we are using an integer and because this is a count i think blank count is of wrong type because it can be negative so to really be safe in our program here we should make this unsigned or even use size t this is better okay so let's use size t because this is a size and size t is a good type to keep track of sizes in your c plus plus programs so make sure you size t here and what we're going to do is go in the loop at each iteration we're going to check if each character at each iteration is a blank if it is we're going to fall in here and say that we found a blank character at this index in our array here and we're going to increment our blank account and by the time this loop is done we're going to have the blank account stored in this blank account variable and we're going to print that out it is this simple now we can build with gcc let's do that we're going to world with our gcc compiler and the world is going to be good can clear and run rooster and you're going to see that it's going to say we found a blank character at index 5 12 20 24 31 35 39 and 42 and in total we have found nine blank characters do we have that many let's count so one one blank character we have two here we have three we have four we have five here we have six seven eight and nine if you count you're going to find that we have them and the first one is at index five so index zero is h one two three four the first one is at index five and this is doing exactly what we want we can go down and check if a character is uppercase or lowercase we can do that through an example like this and the facility is going to be std lower and std is upper we have a message here we're going to loop around using a range based for loop and we're going to check if each character is either lowercase or uppercase and if the test is good we're going to jump in the loop and we're going to increment lowercase count which are a few variables to keep track of how many uppercase and lowercase characters we have in here and again these variables are going to store counts so it is better to use a size t or some unsigned integer type but now we're going to use size t because it is good so we're going to keep this stored in here and we're going to build this and see what we get before we run we want to clear and we are going to build with gcc the bolt is going to be good we're going to clear and run rooster and you see that the original strand is this guy here what we're going to do we're going to print whatever character we are at i'm going to put a space in front of that and we're going to see increment this is the output why do we have this method here because we are", "47095.116 - 47396.560000000005": "each character and we are not printing the upper case ones we are printing lowercase ones that's why you see this guy here this is really interesting you can keep this in if you want i am going to keep this on the important message is that we found lowercase characters and uppercase characters and we have five uppercase characters if we go in and count we're going to find that we have t here one two and three and four and five five uppercase characters and if you count the lowercase characters one by one i am sure that you're going to get a 47 like we did here we're going to comment this out because this was just an example i am leaving this in here so that you can use this as a reference if you want we can also check if a character is a digit and we're going to use std is digit to check that the return type is going to be different from zero if the test succeeds if it fails we're going to get a zero and we can use that like this so we have a message here stored in the character array called statement and we're going to loop around checking if each character we are at is actually a digit or not if it's a digit we're going to say found a digit i'm going to say whatever digit we found and we're going to increment the digits count and we're going to store that information in this digit count variable here we don't want to make it an end so we're going to make it a size t and we're going to build and run this program and see how many digits we found you know it is this number here i'm not going to say it we're going to let our program figure this out so rooster and we're going to find two two and one so we found three digits and it is exactly what we expect here we're going to comment this out and show you another example and in the last example we're going to be showing you that you can change the case of a character if it's lowercase make it uppercase if it's uppercase make it lowercase and you can do things like that we have a message here stored in our character array called original str we set up another array which is going to store our message that is transformed and we're going to loop around turning everything we come across uppercase the way we do that we're going to say std to upper and we're going to pass in the character that we want to turn to uppercase if we do that we're going to get an uppercase character out of that and we're going to store that in our destination array at this index here it is this simple after that we're going to print the original strand and the uppercase string we should get that printed out because it is stored in destination string here and we're going to do the reverse and turn that back into lowercase we're going to grab the original strength loop over it and at each iteration we're going to get whatever we have and turn that to uppercase to lowercase i should say and the result of that is going to be stored back in our destination strand so we're going to overwrite whatever we have in our destination string here and after that we're going to branch the lowercase string and we should get that printed out this is how the example works and if you have any problem understanding this i am always around please do ask i will do the best i can to help you out for now we are going to build this with gcc the builder is going to be good we're going to clear and we're going to run booster and we're going to see that the message is here it is turned uppercase it is turned lower case and this is how you can do these things here so we have looked at a few of this facilities from cctime i don't really want to look at all of them because that would be really boring i hope you have an idea about how they work and if you want to look at all of them all you have to do is come to the documentation here choose one open it up and look at the documentation and in most cases they are going to have examples down here that you can look at and play with for now we are going to stop here in this lecture this is really all we set out to do to play with many of these facilities from the cctype library in the next lecture we're going to look at how we can manipulate c strings and by that we mean concatenating them or putting them together copying them out and doing all kinds of crazy things go ahead and finish up here and meet me there in this lecture we're going to look at the facilities from the c plus plus standard library to play with c strings all of these are going to be leaving in the c string library you can go and check it out at cpp reference and we're going to start and look at a few examples of some of the things we can do with this library i mean c string the first thing we're going to look at is an", "47396.560000000005 - 47695.36": "of a strength here we have a character array called message one it is a character array and you see that we made it const we also have another array that is pointed to by pointer you know that if we do things like this this array is going to decay into a pointer and there are a few things we can do with that for example we can't use it with std size and we can't use a range based for loop to loop through this message to thank you but sdr then is going to help us check the length of this thing here so we can use it for example if we do hdd sdr lam message one we're going to get the number of characters in this string here this is not going to count the null character though so the null character that is implicitly added in by the compiler is not going to be counted in here you're going to see this in a minute when we hit visual studio code to play with this thanks but this facility can work regardless of whether you are using a row array like this or even for pointers like this and it is really cool so we can use it like this we're going to get it printed out please note that we can also use the size of operator to get the same thing so it is going to work almost the same way but the size of operator is going to include the null character you need to be aware of this the good thing about str lan here is that it still works for a decade arrays so if we use it on message 2 we're going to get the correct output we're going to get the number of characters in here which is really cool and we can also try and print out the size of message two but here we're going to get the size of a pointer printed out okay that's how hdr lan works it lets you evaluate the length of a strand here is another example and it is str cmp or string compare it is used to compare strings what you're going to do with this facility is give it two strands c strands we should be exact and one is this guy here l h ace or left hand string i think that's what this stands for and we're going to give it a right hand strand and by the way these signatures are copied straight from the documentation so that we can look at this in one slide to make it really easy to follow this is going to return a negative value if the first guy happens to come before the second guy in lexicographical order so it is something like a comes in front of b c comes in front of d or something like that if the two strands are equal it is going to return zero and it's going to return a positive value if the first guy appears after the second guy okay and we're going to try it out we have two strings alabama and la bama here and they are stored in character arrays that are pointed to by these two pointers string data one and string data two and we can do something like this below here so we're going to print something out and we're going to say std string compare and we're going to pass in the first string and the second string for now i want you to pause a little bit and try to guess what we're going to get printed out here the first string is alabama the second one is blah blah so the first one comes in front of the second and we see that we're going to get a negative value if the first guy comes in front of the second guy so alabama comes in front of blabama and we would expect to get something negative from this thing we are doing here and again if we try and change them up a little bit you see that alabama still comes before a la bomb so we're going to get a negative value pointed out and we can change these things up to see what we get it is really simple if you know how to use them we can also use another version of string compare which is going to let us specify the number of characters that we want to compare we can specify that we want to compare n characters in this case it is three characters and it is going to compare a section of the strings that you specify as a first and second parameter here so for example if we change string that i want to be a a i a and string data two to b a a a n c a and we are comparing three characters in here so we are comparing aaa to aaa we're going to see that they are equal and we're going to get a 0 printed out here you're going to see that this is exactly the case when we get to play with us in visual studio code in a minute we have a facility that we can use to search in a string and search for a character the facility for that is sdr chr and it is going to find the first occurrence of a character in a string and the documentation for this is right here and please note that this example is actually copied", "47695.36 - 47995.115999999995": "okay so we have a message here it is a character array and it is pointed to by a const car pointer called hdr and we have a target character that we are looking for and the result is going to be stored in the result character array here and we have a variable called iterations that is going to keep track of how many iterations we did to find our target here the way this guy works it is going to return a pointer to what you find if it is found for example in here if we find this first t this function here or this facility is going to return a pointer to this first t here if it doesn't find what we want it is going to return a null pointer that's how it works and you can see that in the documentation here we are going to take advantage of how it works in this while loop here and the way you use this facility you give it the strength you want to search in and you give it the character that you are looking for so if we look at how it works in the while loop here we are going to call the function and we are going to store the result in our character pointer here and if we go inside we're going to hit the first character here at the first iteration so we're going to find this t here and when we find it the result of this is going to be stored back in result here i hope this makes sense so we're going to find it we're going to print it and we're going to increment result to make it point to the next character this is pointer arithmetic in action here and after we do that we're going to increment the iterations so we should have one iteration by now and we're going to jump into the loop again so the string we search in is going to be starting from r here so we're going to try and find an uppercase tn and it is going to find this uppercase t here so it is going to point to it and the pointer to this t is going to be stored in this result here okay and we're going to jump into our body here we're going to say that we found this t we're going to print it out and we're going to increment results if we increment reserved now research is going to be pointing to the h here okay and we're going to say how many iterations we did to find our thing we will have printed out the t that we have found and we're going to jump to the next iteration which is going to be searching for t in the reminder of the string here it's not going to find it of course it's going to return no pointer and the test here is going to fail and we're going to fall down here and say how many iterations we found i realize this example can be really confusing i am going to try and explain it again when we hit visual studio code for now note that this facility can help you find characters in a string that's the message here there is also another function that helps you find the last occurrence of a character in a string for example here we have a character input it is a path to a file on some limit system or mac system and we have an output character pointer which is going to store the pointer to the character that we found okay if we find the character we're going to store in the pointer to that character if we don't find it we're going to return no pointer i think that's how this thing works so what we really want here is to hunt for the file name in this path here and this is really interesting so we're going to search for the backslash the last one and this string here and it is going to find this guy here because that's the last occurrence of the backslash in our input string here once we find it we're going to get a pointer to this guy stored in the output character pointer here and we're going to print it out what we're going to do we're going to use pointer arithmetic to move this pointer to the next guy because that's what we really want we want to print starting from the edge here and that's what we're going to get when we print this out now that we have looked at all these examples i think it is time we headed to visual studio code and actually played with them okay here we are in our working folder the current project is c string manipulation that's what we're going to work on we're going to copy our template files and we're going to put that in place and we're going to open this in visual studio code pretty quick let's include c string because that's what we're going to be using many of the things we're going to be playing with in this lecture are documented in this piece of documentation here so you can come here and get more details than we could even cover in a course like this let's bring this up a little bit and we're going to go in our main function and put in the first piece of code we can play with the str land facility is going to find the length of the strength and it's going to work regardless of whether you are using a row array like this or even if you are", "47995.115999999995 - 48296.956": "your array and this is pretty cool so here we have strlen message one we're going to print that out we're going to print how many characters we have in this guy here we're going to also use the size of operator to try and compare these things but please know that the null character is going to be included if you use sizeof here on a row array this is very important to know but one interesting thing about hdr lan is that it is also going to work if you are storing your array and something that is pointed to by pointer so even decayed pointers are going to be usable here and this is pretty cool so we can also try and print the size of message 2 which is pointed to by a row pointer and we're going to see what we get but we know that we're going to get the size of a pointer because that's what it really is message two here is just a pointer okay let's close this on the left and we are going to bring up our terminal and i try and build this with gcc we're going to do that so we're going to use gcc to build this the world is going to go through and we're going to clear and run rooster again and this is going to give us what we want sqr lan message 1 is 16 size of message 1 is 17 because sizeof is also going to count the null character htrlen message2 you see that it works even if we have a decayed array that is pointed to by a pointer and this is really useful if you happen to need the size of an array like this you can use hdr then and you're going to get the size of data in there but know that the null terminating character is not counted if you use hdr ln here and size of message 2 is going to be 8 because that's the size of a pointer on our system here so know that this guy is just a pointer okay that's the message here we are going to comment this out the next thing we're going to look at is strcmp which can be used to compare strengths so it works exactly like we say it's going to return something negative if the first string happens to come in front of the second string in lexicographical order for example here we have a few variables we have alabama and blabama there are strengths pointed to by pointers so they are c strings and we have a couple of other strings stored in row arrays like this and by doing this i want to prove that this facility is going to work regardless of how your array or your c string is stored so we're going to use that here for our c string pointer 2 by pointers we're going to try and compare whatever is in a string data one with string data two string data one has alabama string data two has blah blah so if we compare these guys we expect to get a negative value out of this thing here strcmp because alabama comes in front of blabama in our alphabet so a is in front of b so we're going to get a negative value out of this and we expect to get the same thing in the second example here which is going to be using what we store in our row array so make sure you understand this and we're going to try and build this to see that it passes through our gcc compiler the buzz is good so we're going to clear and run rooster and you're going to see that we get a negative one i want you to play with this thanks and try and change for example the 8 with c and see what you get okay we're going to try and build but before we do try to expect to see what you get c comes after blah blah so if we look at this description here we should get a positive value because the first guy comes after the second guy in lexicographical order so we should get a positive value for the first thing that we print here okay let's weld and see if that's the case we're going to build successfully we're going to clear and run rooster and you see that the first guy prints a one because cla gamma comes before blah blah and the second one is going to still be a negative one because we still have whatever we had before in there okay this is how you work with this thanks let's turn this back to alabama so that we are not confused and we're going to keep working on this and the next piece of code we are going to try and modify", "48296.956 - 48595.276": "string data 2 and print the comparisons out for example we have alabama and album and by the way we are able to modify that because it is a pointer to a strength and notice that this is not the conspirator so we can really change where this guy is pointing and that's what we are doing here but we can't do that with string data 3 and string data 4 because these are arrays and remember you can't change where an array points so this is going to compile nice but if we try and do the same thing with string data 3 and string data four let's do that you're going to get a compiler error so we're going to put this guy here and say three and four and we should see visual studio code complaining here because this is not allowed you're not allowed to make an array point to another location and this is just another character array or cost character array in memory that we want this pointers to point to or this array to point to and this is not possible so we're going to get a compiler error if we do this this is something i wanted you to know that's why i set up this example here so if we run this we're going to see the first line of output here or i think i should comment that out or let's not comment it out now if we run this program we're going to get the output for obama and alabama printed out and alabama comes after alabama so we expect to get a negative one because the first guy here comes in front of the second guy so we're going to get a negative one out of the thing we are doing here let's try in world with gcc the builder is going to be good so we're going to clear and run rooster and we're going to see that we have a negative one here alabama comes in front of a lab so this is cool so we can try and put in many other examples for you to play with i am going to do that because i don't want to type all this thanks and we're going to print the results out for example we put in india and france we put in kigali and kigali and we're going to get things printed out here so let's build this so that we don't waste time we're going to clear and we're going to run rooster and we're going to see that we get these things here alakama comes after alabama so we get a one india comes after france we get a one shigari comes together with kigali and we get a zero you can try and put in whatever you want these are just a few examples for you to play with and by now i hope you really understand how this function works or this facility works so we're going to comment it out whatever we did here so we're going to comment all this out so that we don't have noise output in whatever we want to do next and what we want to look at next is this function here which is going to compare strings in the same ways but we're going to tell it to compare however many characters in the string and you see that my string here has been commented up i can quickly take it and bring it down here let's do that i can't find that let's find that and copy it down and we're going to find them here so i'm going to find this and bring that down here so that i can compare these things so let's come down here and print and put in our declarations for this strengths and you see that visual studio code is happy now so what we're going to do is compare a set of characters in these strings here okay so we're going to compare any characters in our strengths so we're going to compare allah to blah here and allah is going to come in front of black so we're going to have a negative one printed out here but if we change the strengths to aaa and aaa here and compare the first three characters we're going to get a zero printed out because the first three characters are equal and again the special thing about this function is that it allows you to specify a number of characters you want compared in these two strings so you can say i want to compare three strands you can say i want to compare four strings or five just make sure that you don't go over the size of the string and if you do that it's not going to make sense what you are trying to do here if we go down here we're going to change n to 5 and we're going to be comparing all these things in here and we're going to get that the first one comes in front of the second one because i comes in front of n in our alphabet if we change the data to o here and n o is going to come after n and we're going to get a positive number printed out here we're going to try and run this so let's run the task to build with jcc the bullet is going to be good and we're going to clear and run rooster", "48595.276 - 48896.16": "comes in front of blabama because we are comparing the first three characters if we have aaa in here and we compare the three characters you're going to see that they are equal we get a zero if we change i and n here we're going to get a negative one because i comes in front of n if we use o here and n we're going to get a one because o comes after n this is really simple to understand now that we know how to use the first version of string compare this version is just going to allow us to specify how many characters in the string we want compared so we're going to comment this out and we are going to go down and do another example that allows us to search for a character in a string and the method we use to do that is std str chr so this guy is going to find whatever target you want to find and if it finds that it's going to return you a pointer to dot's target if it doesn't find it it's going to return you no pointer so we set up an array here and we store that in a location that is pointed to by the pointer to character here and we say whatever target we are looking for in this case we want to find this t here we are going to set up another character array that is going to store our results the result is really going to be a pointer which is going to be pointing to something valid if we find the target and it's going to be no equator if we didn't find the target and we set up another variable which is going to store how many iterations we did we should really make this an unsigned integer or size t so let's make that here and we're going to loop here so the first time we'll open here we're going to call this guy we're going to say i want to find a t and result here and the result is going to be pointing to this line here because we did the assignment here so it's going to go and try to find the t it's going to find the guy here at the first index and the test here is going to succeed when it succeeds it's not going to be equal to no pointer it's going to be pointing to a valid pointer and it's going to succeed and return the pointer to be stored in resort after this guide returns the pointer is going to be stored in the result here and that's going to be a pointer to this team and we're going to jump in the body here i really want you to understand how this thing is going to work once we get to the body we're going to say uh-huh we found our target that's going to be our t print it out and it's going to start at this location okay and we're going to print starting from the t here because that's what our result here is pointing to after we do that we're going to increment the result to make it point to the next character if we do that with pointer arithmetic now we're going to be pointing to the r in here i hope this makes sense and we're going to increment our iterations so we're going to say we have done one iteration and we're going to try and run this again and by the time we get in here we're going to have this string here in which we are searching for a t and it is going to be found starting at this second t here there here and it's going to find it it's going to store the pointer to it to resort here or i should say the search is going to be successful so we're going to find the pointer to this t and return it from this function here and the pointer is going to be stored in our result pointer here we're going to jump in the body and we're going to print we found the target starting at this t we're going to print that out and stdc out is going to print until it meets an old character so we're going to print this thing through the end and we're going to put a slash n which is going to move us to the next line after we do that we're going to increment result and uh result now is going to point to the h here and we're going to increment iterations now we're going to have done two iterations by now and we're going to run the loop again this time the loop is going to fail because starting from here we don't have a t and that this function is going to return no pointer and this test here is going to fail okay we are going to return no pointer no pointer is not going to be different from no pointer so this is going to fail and we're going to fall down here and say how many iterations we're going to find so in total we're going to do two iterations and we are going to find two t's and we're going to print whatever we find here make sure you really understand this and i put in this example on purpose because it is a little complicated but it is going to really bring your game up in how you use these functions from the c plus plus standard library and you really need to know this if you have any problem with this be sure to ask me i will do the best i can to help you out so we're going to build this and run this we're going to", "48896.16 - 49195.520000000004": "going to clear and run rooster and you're going to see that we are looking for t we are going to say we found t starting at the t here so we're going to say try okay we're going to print all the message out and the second iteration is going to find t starting at this location here and we're going to do two iterations in total we're going to comment this out and again if you don't understand this please go through it again and if you still don't understand be sure to ask me i am going to do the best i can to help you out and some of you might be asking why did we go through the trouble to store this guy in a result why don't we use htr in the first place in here and the explanation i can come up with is that you don't really want to modify this guy here because somebody is going to look at this thing and say this is the message i have in sdr here but if you try and modify this in the loop it's going to be messed up because you're going to be incrementing it and doing all kinds of crazy things on it so you don't really want to modify this so a better way to even do this is to mark this as a const pointer and we know how to do that so we can say cost here and if you even try to increment htr somewhere you're going to get a compiler error so let's make sure we see that for example we try and do plus plus sdr we're going to get a compiler error because this is a const pointer by now and this is much safer okay we're going to comment this out and show you something that might throw off many of you guys so we're going to comment this out and i am going to bring that in okay let's go down here and we are going to do basically the same thing but we will try and use str in the first place here okay this is how we're going to do this we're going to have our string we're going to have our target we're going to have our result here which is equal to null pointer and we have our iterations which is an integer let's make this a size t and what we're going to do in here we're going to use htr to search okay and we're going to basically do the same checks we're going to jump in here and say we found the target starting at result and we're going to increment hdr here because it is not a constrainer now try to go through this thing here and see how many times you're going to loop okay go through it and when you are done we're going to try and run this we're going to build with gcc the build is going to be good we are going to clear and run rooster and you see that this guy is going to look 25 times and this is crazy why is this happening why is this happening what we really are doing here we are not assigning the result in this trend that we are searching at okay let's try and go through this a couple of times so the first time we're going to do our search okay so we're going to search in sdr and if we find our target we're going to return the pointer to the target if we don't find it we're going to return a null pointer the first time we're going to find this t here okay and we're going to return a pointer to it and store that in result okay so after we do this we're going to fall in our body here and we're going to say we found t starting at this location here that's going to work and we're going to implement str okay notice that we're not incrementing result here if we increment sdr it's going to point to the next character which is r here okay and we're going to increment our iterations and we're going to start in loop again we're going to search in here and we're going to be searching from this location here and we're going to find the t starting at this location we are going to find this t here and we're going to return that and store that in reserved but the problem is that what we are incrementing here but the problem here is that we are incrementing one by one we are not jumping to this t here and we had a way to jump to this t by assigning the result into the same variable that we are searching in okay so this is going to loop 25 times and it is not really good and some of you might try to set up something like this and it is really not going to be good try to go through this and you're going to see the reason why it is looping 25 times okay i wanted you to see this don't do something like this and we are going to comment this out the next thing we're going to see is how we can find the last occurrence of the character and this is a really cool example i like it it is going to do something very practical we are going to take a path which is going to be an array basically stored in this input array and we're going to strip off all the things we don't need and we're going to hunt down for the file name", "49195.520000000004 - 49495.04": "in whatever application you are doing so we are going to hunt for the last occurrence of a backslash character using the str or chr facility in the ziploc squad standard library and you can find the documentation on this guy here i'm not going to go there you should really practice to go there and read what these things do that's why i am living in the lens to the documentation you should go there and read and if you have a problem you can ask me i will do the best i can to help you out so this line here is going to hunt for the last backslash it's going to find this guy here and we're going to store a pointer to that in our output character pointer here after we do that we're going to say if we found something useful if this is not no pointer we're going to print that out but we don't want to print starting from the backslash we are going to use pointer arithmetic and move to the next character which is going to be this h here so if we print this out we're going to have hello cpp printed out because sddc out is going to print until it meets the last now character and that's going to be after the last p here because this is a c string let's roll here okay we're going to build this the build is going to be good we're going to clear and run rooster and you're going to see that we have hello cpp printed out here okay this is really all we set out to do in this lecture i apologize that it turned out to be lengthy these things can take long to explain and i really wanted you guys to have as many explanations as i could come up with we are going to stop here in this lecture the next one we're going to see how we can copy and concatenate c strings using the facilities from c string here go ahead and finish up here and meet me there in this lecture we're going to look at a few more facilities from the c string library and those are going to allow us to concatenate and copy strings over the documentation for what we're going to be talking about can be found here if you go there you're going to fall on this link here and you're going to find that c string was originally in the c standard library as string dot h but in c plus plus we can use it like this we have a couple of functions we can copy stuff we can concatenate we can get the string length we have seen this but now we're going to look at things that allow us to copy and concatenate stuff because that's something you may want to do a lot the first example we're going to look at is stdstr cat which is going to allow you to join strengths again you can browse to the documentation here and see more about this facility here and you're going to see all about it for now we're just going to play with it we're going to set up two arrays one is going to be called dest it's going to contain hello the other is going to be source here and it's going to contain worlds notice that these are row static arrays that are stored on the snap and uh that's how we set them up here okay so we can concatenate strengths using the syntax like this we're going to say hdd hdr cache we're going to say the destination string and we're going to say the source string we want to copy from okay so after we do this the destination is going to contain these two strings joined together and before you do this you have to be sure that your destination strength is big enough and this is a problem because you have to really keep track of your destination strength and it is easy to put in many more characters that can really fit in the destinations rank that's the reason many of these functions here are considered unsafe by many compilers i don't think you can compile this on visual studio it's going to stop you from doing this because of this way you have to keep track of things yourself but i am just showing you so that you know how to avoid these problems if you happen to be on a compiler that doesn't protect you from this so we're going to append goodbye world to whatever is in dust and down here if we print this we're going to have hello world goodbye world printed out we are going to play with this in a visual studio code in a minute don't worry if any of this doesn't make sense yet here is another example of how we can join strengths through strcat we have two strengths and we set them up with a simple characters like this you can do this and put in your own now terminating character this is a legal c plus plus could and notice that this array is a dynamic array it's going to leave on the hip because of this new operator here we also have a source array which is also going to leave on the hip it is 30 characters long so it is really long and we're going to try and concatenate stance here but before we do that we're going to check their length we're going to print them out and", "49495.04 - 49797.755999999994": "is the same you are going to say hdr cat you're going to specify your destination and your source you're going to be copying stuff from and you are going to store the result in destination here what this is going to do it's going to grab whatever is in source and copy it so it's going to copy the entire thing here from source and it's going to append that to whatever we have in destination starting from the last null character here so it's going to overwrite from this null character and it's going to basically copy everything and the destination here and if we print whatever we have in destination here we're going to have firelord the phoenix kind of printed out and you're going to see that this is going to be the case when we hit visual studio code in a minute you can also use a version of the sdr cat version that is going to allow you to specify how many characters you want to concatenate from the source string in this case we have destination which is hello and we have source which is there is a bird on my window and down here you see that we do hdr and cat we save the destination we save the source and we say how many characters we want copied from the source here and we say six characters so we are going to count from the source we're going to say one two three four five six we're going to grab this their string with this space here and we're going to append that to the source and that's what we're going to get in here we're going to say hello space and there and that's what we're going to have printed out here if we print dust we can also copy stuff and the str cpy function here is going to do that and here we have an example that is going to try and drive this home for you we have a source strength which is c plus plus is a multi-purpose programming language okay guest three here is going to be the same length as the source we made sure of that in here because we're going to grab the length of the source strength please remember that sdrlam is not going to count the null character that's why we are adding a one here to account for the noun terminating character here okay after that we're going to jump down here and say htr cpy dest 3 and source 3 we are basically going to be copying from source and pasting in destination here that's what we are doing if we print destination we're going to see that now it's going to contain whatever we had in source and this is how you can use these methods here we also have a version with which we can specify how many characters we want copied from the source here we have a source string which is hello we have a destination string which is zest 4 and we are going to copy stuff we're going to copy from the source we're going to paste in the destination and we are just going to copy five characters what this is going to do is copy everything from the source and paste in our destination and it is going to override whatever we have in the starting indexes in destination here so we're going to have a b c d e here replaced by hello and if we print this here we're going to have hello f printed out this is how these things work and if you wonder how i know how these things work i just come and read the documentation here for example htr and cpy here if we click on it we are going to get the documentation this is going to say copies at most count characters of the byte string source including the null terminating character to the character array pointed to by desk that's what it does we have the destination we have the source and we have how many characters we want copied and they say a few things you need to be careful about this guy here one thing that you usually care about is the return value you see that the return value is going to be the destination strength so if you want this pointer you can use it and you can go down and look at a few examples here and play with them to really drive the point home okay now that you have an idea about how these guys work we are going to head over to visual studio code and play with them right away okay here we are in our working folder the current project is c string concatenation and copy that's what we are doing here we're going to copy our template files and uh jump to our current project and put them in place we're going to open this in visual studio code pretty quick we are going to include c string because that's what we're going to be using here we are going to bring this up a little bit and we are going to put in our first example here we have two strengths destination and source and you see that we tried and made sure that they are large enough to contain however many characters we want to put in and they are row arrays stored on the stack because they are set up like this and again you can check out the documentation here if you want to know", "49797.755999999994 - 50097.596": "to call strcat here to concatenate the source to our destination here so if we do this we're going to have world here concatenated to what we have in hello here and we're going to have hello world in place for example if we try and print this out i'm going to try and do that after we do the first concatenation here let's do that that's going to be better to show you how these things work okay after the first function here runs we're going to have source concatenated to destination here so what we're going to have is hello world stored in destination here the second concatenation here is going to append goodbye world to whatever we have in destination here so what we're going to have printed down is if we print that of course is hello world and goodbye world okay we're going to have this written down let's try and run this and actually make sure that that's the case and then we're going to see how this function can be unsafe for some compilers we're going to build this with gcc you see that it's going to go through and if we run this we're going to have hello world hello world goodbye world printed out this is what we expect and again this function here sdr cat is going to have whatever you have in source and it is going to append that to whatever you have in destination and for this to work you have to be sure that the destination is modifiable for example if it was an array of cost core let's do that and show you the compiler error we should get a compiler error because now destination is not modifiable it is an array of cost characters and we can't modify it so be sure the destination array is modifiable and in this case it is okay please note that some of these functions can be treated as unsafe by some compilers but i tried this out on both on gcc and the compiler from microsoft and they work pretty well so you can try them out here to prove that let's go and try and build with the compiler from microsoft we have it set up here so we're going to run the task to build with msvc here and you're going to see that the world is going to be good the world finished successfully and if we go and we're going to clear and run rooster you're going to see that it is going to do exactly the same thing but some compilers might give you warnings or errors if you try to do something like this and the reason is you really have to be careful using these functions because if for example destination array is not large enough you may do some crazy things running over the balance of your array and it can be really bad for example if we try and make destination array here for example a size of three it is possible to do that and you see that we get a warning from visual studio code and if we try and build this with gcc let's try and remove the garbage we have from visual studio first now that this is clean we can uh try and build with gcc let's do that our compiler we're going to choose gcc and you're going to see that it's going to give you an error it's going to actually protect us from doing something like this but in some cases some compilers are not going to stop you from doing this but any compiler that really respects itself it's going to have these safety checks in and it's going to protect you from doing something crazy like this okay this is how you can do concatenation using hdr cat like we did here let's try and weld and see that now we are building fine because i don't like these red lines here the world is good and we are all fine now i am going to comment this out and we're going to see another example of how we can concatenate stuff we are going to go down here let's bring this down and hide this and we are going to put in our simple example exactly the same thing we saw in the slides we have two character arrays they are dynamic arrays but we initialize them with characters like this and we make sure to put in our null terminator we have our source strength which is going to say the femix king and it's going to have a terminator here and what we're going to do we're going to take soros and concatenate that to our destination so what is really going to happen we are going to overwrite the null terminator here and we're going to start pasting in things from source here so after the concatenation is done what we are doing here we are concatenating source one to test one we are going to have fire lord the phoenix kang stored in our destination string here and notice that we made sure that large enough to contain our characters here and if we print it out we're going to have the thing printed out we can try and weld with gcc that's going to go through let's bring this up the bulb is good", "50097.596 - 50397.276": "we're going to clear and run rooster okay this is the output here you see that the destination is eight characters long if we count one two three four five six seven eight remember sdrl lan doesn't count the null character so this is what we expect eight characters the source is going to be 17 characters if you count all this that's what you're going to get and if we concatenate them now this donation is going to be 25 characters long in the eyes of hdr land and you see that we print the destination and it is exactly what we expect fire lord the phoenix gang okay we're going to comment this out i just wanted you to see an example of this and the one thing i really want to stress in this example is that strcat is going to start overriding whatever is in dust starting at the last null character okay so this guy is going to be overridden by the comma here and we're going to start and putting stuff and that's what we're going to see here let's comment this out because we want to move on and show you a few other examples okay the next thing we're going to look at is a new version of str cat that allows you to specify how many characters you want concatenated from source for example here we have two strengths destination and source and here we are basically saying i want to concatenate six characters from source and put them at the end of the destination here and what it's going to do it's going to grab one two three four five six it's going to grab this entire thing and it's going to append that to hello and we're going to have hello there stored in the destination and the return value is going to be a pointer to destination 2. and how do i know the return value well i know that from the documentation if you go in your favorite search engine and do stdstr and cat and you're going to see a link here if you click on it from cpp reference it's going to give you everything you need to know about this function here it's going to append source to destination and and count characters are going to be copied so the third parameter here is going to be how many characters you want copied and pasted into our destination and the return value is going to be dest okay if we try this out we're going to see hello there printed out we're going to print it out directly and we're going to print that out using the destination pointer that is going to be returned from this guy here so if we try and build this we're going to build with gcc the bullet is going to be good we're going to clear and run rooster and you're going to see that we have hello there twice here and this is exactly what we expect we are going to comment this out and we are going to go down and look at sdr cpi i should say sdr cpy which is going to copy stuff from the source and paste those in the destination and one thing you should know is that the copy is going to happen starting from the start of the destination array here we have two arrays one is called source three the other is called destination three destination 3 is set up on the heap using the new operator so it is a dynamic array and you see that we make sure that it is the same size as the source we are using sdr lan to figure out how many characters we have in here and remember that sdr land doesn't account for the null character so we are adding one to account for the null character that's what we are doing here and after that we are going to do std str cpy and what that is going to do is copy stuff from source to destination character by character so we are basically going to have this guy pasted into destination here and if we print things out we're going to see that destination contains the same thing as source here if we built this with gcc let's do that the build is going to be good we can clear and run rooster and you're going to see that the destination has exactly the same thing we had in the source and if you need to copy stuff from arrays sdr cpui is going to be very helpful we are going to comment this out because we still have a few things we want to see so let's comment this out we are going to go down and see that we can also use a another version that allows us to specify how many characters we want copied from the source okay in this example here we are using std str and cpy and this n here means that we can specify the count of characters we do whatever the current function is doing here okay so we are specifying i want five characters copied from source and i want those pasted into destination here that's what we are saying here and the source is going to contain hello", "50397.276 - 50695.36": "world and the copy is going to happen starting at the first index here so we're going to have hello override whatever we have in a b c d e because that's five characters here and the dust is going to contain hello f if we print it out let's build this and see if that's what we're going to get we're going to build with gcc the build is going to go through we are going to clear and run rooster and you see that that's exactly what we have here okay this is how these methods work there are many more functions you can use from the c string library and again if you want to see a list of them all you can go through your favorite search engine and search for c string and we can specify cpp reference here let's try and do that okay we can find a link to that we can click on that and it's going to open up and show us many more functions we can use and if you need to know about a special function you can click on it and see what it does and if you go down you're going to find even an example of how you can use it for now we are going to stop here in this lecture and this is actually going to be the last lecture we see on c strings the next one we're going to start and look at std strength which is a compound type that makes working with strengths very easy in c plus plus go ahead and finish up here and meet me there in this lecture we're going to start and learn about hdd strength which is a type that is going to make it super easy to work with string data we have seen many ways we can work with character arrays by now we can use row rays we can point to them with pointers we can even allocate arrays on the hip but all these character arrays had a few problems that are really a pain in the neck to deal with on a daily basis one of those problems was that you had to keep the size in check you have to know how many elements you have in the character array and that was defining the bounds that you can work in if you go over bounds we have seen that that can cause crashes of your program and you don't want that another problem was that we had 3d to remember to keep track of the null character if we don't have it in place we're going to have problems when our string is printed out and it's really annoying to always have to think about these little details when all you really want is to store a strand so c plus plus offers a high level type that we can use and it is going to hide all these little details underground and all we have to do is put in our string and use it and we can be on our merry way and do whatever we want to do with string data in our c plus plus application so that's what we're going to do we're going to have a type that is going to wrap on top of the ugly array computations we have been doing on character arrays we're going to call that std string and we're going to be able to do many of the things we were doing with c strings but in a much better way we can concatenate we can search we can copy we can do all kinds of crazy things really but it's going to be in a way that you don't have to worry about these little details about array bounds the null character you're going to just use it for what you want which is storing character or text data okay so that's what we're going to be doing in the next few lectures we're going to be learning about std string and how you can use it in your c plus plus applications and it's going to make your life a whole lot easier we are going to stop here in this lecture the next one we're going to see how you can declare initialize and use std strength in your c plus plus application go ahead and finish up here and meet me there and this lecture we're going to see how you can declare and use hdd strength in your c plus plus applications std strength is a type that is going to wrap on top of arrays and give us a really nice interface that we can use to store string data without having to deal with the ugly little details like keeping track of array bound remembering to keep in check the null character and things like that to use std strength you will need to include the string library and after you do this you can declare and use your strings just like this here we have a series of examples just to get you started on this you declare your strengths just like you declare any other time you specify the type on the left the type is going to be std strength by the way you'll have to remember to use std column column like this and we will have a chance to explain why in a few chapters ahead but for now we're just going to think of std strength as a type so we declare a string type we call it full name and we can leave it like this uninitialized and it is going to be an empty strand we can also put in our string and initialize that with a string literal and it is going to work another way of doing this", "50695.36 - 50997.2": "string which we are doing down here you can also set up another string and initialize it with part of another string literal so for example message here is going to be hello and it's only going to grab five characters from this string literal this is something you might want to do if it makes sense for whatever application you are doing here we can also initialize our strength with multiple copies of one character and this is the syntax to do it you say the name of your variable you say however many times you want the character repeated and you say which character it is just like this we can also initialize a string with part of another existing string so for example here we have saying hello and it is initialized with part of what we have in greeting here so we're going to start at index 6 which is going to be 0 1 2 3 4 5 6 on the w here and we're going to grab five characters so one two three four five and that's what we're going to use to initialize this saying hello here and if we print it out we're going to see that this is going to be exactly the case so hopefully you can see that it is easier you don't have to use pointers you don't have to use arrays and the best part is std strength can grow automatically if you happen to store in more characters than you initialized it with in the first place and that's pretty cool so now we're going to head over to visual studio code and play with us so that you can see for yourself okay here we are in our working folder the current project is declaring and using std strength which is what we are doing here we're going to grab our template files pretty quick and we're going to go and store in the files and we're going to open the folder and we're going to include the strength library let's do that okay this is how we do it and now that we have it included in our project we can start declaring and using std string types in our c plus plus program we are going to go down and put in the code to play with this a little bit so you can declare an empty string like this and it's not going to have anything inside you can declare a string and put in a string literal like we are doing here and std string knows how to handle this so it's going to store it inside using a character array but we don't have to really worry about that character array is going to work we're just going to use std string here we can set up a string using another string in our initializer like this we can also use part of a literal to initialize the string so for example this string literal here we're going to grab part of it and we're going to grab five characters and use those to initialize our message std string here and this is pretty cool we can also use multiple characters to initialize a string like this we say however many copies we want of this character in this string here and it is going to be exactly what we want so it's going to be four e's in this weird message string and we can initialize the string with part of another string and this is really cool and it may come in handy in many applications so for example here saying hello is going to contain world here and we are saying that this is what we want by saying we want to start at index six in this string here so if we go zero one two three four five six this is going to be our character at index six and from this index we're going to grab five characters so we're going to count one two three four five and that's going to be what's stored in this string here and if you don't believe me we can print all these things out and they are going to be exactly what we expect and by this you can even see that we can print std strengths using sddc out very conveniently like this and this is very cool okay so we can try and weld this with gcc the build is going to go through so we're going to bring up a terminal so that we can run this and we're going to clear and let's see what we see when we run rooster here so we're going to print the full name the full name is empty okay so we're not going to see anything because it is empty we're going to see planet planet is this thing we have in here planet where the sky is blue so this is what we expect we can say preferred planet and put in the text for the planet here so we're going to get the same thing here and if we have a message and say hello there and grab the first characters in this string literal message is going to say hello which is what we are saying here let's go down and look at where the message is going to be for ease which is what we have here and we can initialize saying hello with part of what we have in greeting and we have targeted this word string here and it is what we see here and this is pretty cool the good thing about hdd string however is that you can", "50997.2 - 51297.04": "initialize this guy with so for example here we have this message here but we can say planet let's go down here and say it we're going to change std string at run time so we're going to say planet and we're going to assign something to it we're going to put in whatever was in there first and we're going to paste that in multiple times let's do three times i think that's going to be enough or we can even bring this back so that we see the entire thing here doesn't really matter all we want is for this thing to be larger than it was initially declared in a planet here so we're going to remove these quotes because they are making things ugly for us and now it's going to be a valid strength let's wait for visual studio code to realize that and it's going to remove these squiggly lines now we are good std string is automatically going to take care of the logic to make this string grow we don't have to worry about that and if we print planet now we're going to see the same details and taken care of okay this is really cool and it makes it super easy to work with text and string data like you see here so let's build again so that our changes are reflected in our output we're going to clear and run rooster and we're going to see that planet is now really large okay we can change this thing the size of this thing at runtime and this is something we couldn't do with arrays so for example if we go down here and use a row array to do something like this this code is going to run but try to think about what is really happening here we have an array which contains this text here and it is pointed to by this cost card pointer that we have if we try and do an assignment like this this is really going to be to make it point to another character array in memory and this piece of memory here is basically going to be wasted because we think we have our planet strength in here this is not the case with std strength because std strength when we do something like this the initial memory that was allocated to store planet here is going to be returned to the operand system and a new memory is going to be allocated to contain this new thing so the waste we're doing here by just leaving this in memory and not using it is not being done here so if we try to print we're going to get the same output but inside and how our memory is managed hdd string is better in that the memory that was used to initialize this guy is not wasted out here with array what we really are doing is just make this planet pointer point to another string and leaving this to be wasted in memory this is what we are doing here and we can avoid that with std strength in this lecture we're going to learn about the one definition rule and this is a rule that says definitions can't show up more than once in your entire c plus plus program or in some cases a definition can show up more than once in a translation unit we are going to look at the one definition rule in the context of freestanding variables functions classes member functions and static members in our classes in most cases a definition can't really show up more than once in your entire c-plus plus program but we have exceptions to this rule and the exception is for classes a definition for a class can show up in multiple translation unit and the reason is we need to create objects of those classes so each translation unit really needs to see the definition for the class and we are going to try and make this super clear with examples once we hit visual studio code okay so it is time to head over to visual studio code and shed some more light on the one definition rule here we are in our working folder the current project is one definition rule we're going to grab our template files like we always do we're going to put them in place and we're going to open this little guy in visual studio code let's do that i'm going to drag and drop and we're going to have our main cpp file here we're going to clean it up that's what we always do and now we want to explore the one definition rule in the context of variables so we have a freestanding variable here and that's going to be the same variable we had in the last lecture we're going to initialize this and this is really good we can use it we can go in main and use it however we want we can print the way and if we won't run this program it is going to work but the one definition rule says we can't have more than one definition for anything and for this variable here we have seen that this is", "51297.04 - 51596.16": "and a definition so we can't have more than one definition for the weight name here for example if we try and grab it and copy and paste it here so we're going to try and build this program we're going to use gcc we're going to see that we have a problem and the problem is going to say redefinition of double weight and it is not going to help even if you take this and put that in another file so let's create another file to really show you that we're going to call it some other file that cpp and we're going to grab our redefinition and move that there and you're going to see that if we try and build this program we're going to get the same problem we're going to have redefinition so we're going to see what is the problem here the compiler error is a little bit different but it is going to say multiple definitions of weight and it's going to say one is defined in the main cpp file so this is a linker error this was caught by the laker because the redefinition is showing up in multiple files so the linker was linking this program and it needed to see a definition for weight and it had seen one definition in the main cpp file and it has seen another definition and some other file and this is a problem the linker doesn't know which one to choose so it's going to throw an error and you can't really have multiple definitions for a variable in your c plus plus program and this is the one definition rule and the context of freestanding variables like the weight here but this is the same in the context of functions if we go down and put up our add function here we're going to say double a and double b here and we're going to put the definition below the main cpp file let's grab this we can copy this and put this in the code here i'm going to remove this little thing we don't want it we're going to put in our body and we're going to return a plus b here okay so this is our function it is working we can take out what we had here because it has served its purpose you can say double result and we're going to add up 10 and 20 like we did in the last lecture no problem and we can try and print out our results here if we build and run this program it is going to work without a problem because we only have one definition for the add function what is the problem here we have weight defined multiple times we're going to comment out one the definition for weight and we're going to build again now the build is good and we can run this program we can kill our terminal here and bring up another one and run rooster you're going to see that the result is 30 and the program is working just fine but if we set up another definition for add even if we put this in the same file we're going to get a problem because we are violating the one definition rule let's run again you're going to see the problem here we're going to see redefinition redefinition of the add function this is not allowed your program is not going to compile we see the compiler error here even if you put the definition in another file that's not going to help we're going to take this and put this in our some other file and try to compile the program we're going to get a linker error and it is going to say multiple definition of the add function and this is not allowed this is a linker error in this time if we comment out one definition let's do that we're going to comment out the one in the main function this is going to work and we want to be violating the one definition rule so this is good the world is good we can clear and run rooster we're going to see our result here so the one definition rule says you can't have multiple definitions for freestanding variables or even functions and reserve that if you do that you're going to get a compiler error let's look at this in the context of classes we're going to do a class we're going to say struct and we're going to call this point like we always do mostly we're going to call this point and we're going to put in a few member variables one is going to be mx the other is going to be m y and this is going to be our definition here but what you're going to see is that it is possible to have multiple definitions for classes for example if we take this and have a copy of this in another file we're going to do that we're going to declare this structure here and we're going to try and build this program you're going to see that it is working we have multiple definitions of these guys we can go in main for example and say point p1 and we can up weld and see that the program is going to work okay so if you", "51596.16 - 51896.32000000001": "sdd cl p1 and the print x we're going to do that we're going to say p1 mx we're going to be able to use this because this is a struct the member variables are public by default we can do this and we can say p1 y is p1y my let's do that and we can say stdndl what is the problem here we need to put our output stream operator i think now the compiler is going to be happy and therefore world we're going to use gcc we're going to see that if we run the program we're going to see our things here and we have some junk values inside because these things are not initialized but if we initialize them to zero using the braced initialization here we're going to build again and we should see zero inside so let's clear and run rooster now we have 0 in x and y for our object here this is working fine and we have multiple definitions for our class but the definitions can't show up in a single translation unit for example if we took this definition here and brought that back in main and put that just below our structure here if we try to weld the compiler is going to complain because now we have multiple definitions for the same class in the same translation unit for classes we can have multiple definitions but the definitions have to show up in different translation units and that's what i want you to see here so we have a redefinition of our point struct and it is not good it is going to violate the one definition rule okay now that you have seen this we also want to see this in the context of a class that also has some static member variables we're going to take this out because we have already seen this and we're going to bring in our person class like we used in the last lecture we're going to add in a new header file it's going to be called person dot h and we're going to jump into what did we do is this folder let's remove this we didn't want a folder we're going to delete this folder we don't want it and we're going to just add a file called person.h that's all file here and we're going to put in the content the content is going to be our personal class let's close this so that you can see more of this class here okay so we have our person class here we have our include card we have our person class definition we have a constructor and we have a printer phone function we have our member variables and down below here you see that we have a static variable which is person account we need to put in the definition for these guys so let's go down and do that we're going to put in the definition for the person constructor we're going to go on top here and include our person header file and we're going to put in place our constructor we can go down and do that we can say person and say person that's going to be our constructor we're going to go back to the class and grab the parameters because i don't want to type all these lengths so let's do that we're going to put them in we are going to put in our initializer list i think we should also delete a parenthesis here we're going to go down and put in our initializer list we're going to say full name we're going to initialize this with name param and we're going to also put in our age and we're going to initialize this with edge param the parameter we have from the function and this is going to be all inside the body we're going to implement the static variable we're going to say increment person count okay now select that here and this is going to be good we also need to initialize our static variables so we're going to say ends person person account let's do person account and we're going to initialize this to maybe eight like we did in the last lecture and this should be all we need here so if we build and run this program i think it's going to run let's select the main function here and what problem do we have here let's build and see we're going to let the compiler figure this out we're going to see that the world is good and we can create person objects and really use them in our program so let's come down here and delete whatever we had we're going to include the person and we're going to go down here and create a person object we're going to say person p1 and we're going to specify the name to be jon snow why not and we're going to say that they are 35 why not and we can preach information about this person we can say person principle and if we try to build this program let's use gcc to do that the world is going to be good as you see", "51896.32000000001 - 52195.04": "and run rooster we're going to see jon snow he is 35 years old so this is working just fine but we can't have multiple definitions for the same class in the same translation unit here for example if we come in the main function notice we are including a person so this is bringing in the definition for a person we have in our person.h here if we also try to declare another class called person even if we don't put anything in the compiler is going to complain because we have two definitions for the same name which is person here if we try to build i think we are going to get a compiler error saying that we have a definition you see we have a redefinition of person so this is not allowed we can't really do this but notice that this person class is included both in some other file which is a separate translation unit and main we have it included here so it is really in a separate translation unit we have the definition for the class in separate translation units and that's not a problem but if you try and put the same definition multiple times in a single translation unit you're going to get a problem and you need to be aware of that what i want you to see right here is that you can't also have multiple definitions for your static variables and the member functions of your class for example if we grab what we have here and also put that in our main function we can do that why not we're going to come in our main function here and we're going to put the same definitions here now we're going to have a problem because the linker is going to see two definitions for the static variable and the constructor for a person here and this is going to be a problem you can't really do that if we build we're going to see a problem we're going to see that the problem is we have multiple definitions for the constructor and we have multiple definitions for person account and this is not allowed you can't really do that you can either remove the one from some other file.cpp for example if we comment this out let's do that we can come on top here and comment this out and try to build the program now the program is going to work because we have one definition for these guys you see the world is good we can even run the program to show you that it works or we can remove the one in the main cpp file and we can leave this alive so let's go back in the cpp file the main cpp file i should say and remove this and if we work we're going to see that this is going to work and that we are compliant with what the c plus plus standard expects us to do in our c plus plus programs if we're around we're going to see that this is going to work and this is really cool this is really all i wanted you to see in this lecture the one definition rule which says that you can't have multiple definitions for the same name in your entire c plus plus program but for classes we can violate this rule a little bit and make the same definition show up in multiple translation units we are going to stop here in this lecture in the next one we're going to learn about linkage go ahead and finish up here and make me there in this lecture we're going to learn about functions a function is a reusable piece of code that you can use multiple times to do different things it can take input and once it has input it can do some processing and when the processing is done the function can optionally give you a result you can think of a function as a machine which can take input and give you some output when you give input to the machine the machine is going to do some processing and then it's going to give you the output and the output is going to be dependent on the input that you gave to the machine this is really how a function works in c plus plus and once you have the machine set up you can really reuse it however many times you want let's look at how a function looks in c plus plus the syntax is this you first specify the return type which may be and double or whatever after that you're going to specify the function name and after that you're going to have a pair of parentheses inside this parenthesis you're going to have your parameters which is going to be a comma separated list of things you pass to the function and after all these parameters you're going to have a pair of curly braces and inside those curly braces we're going to have the body of the function we're going to be doing our processing in the body and when the processing is done we can get the result", "52195.04 - 52495.916": "mechanism here so if we want to get something out of the function we have to return that thing and it is going to be visible to whoever used this function here is a simple example of a function with no input and output the syntax is going to be this void means that this function is not going to return anything and you notice that our pair of parentheses is empty because we have no input in this function we have our curly braces and inside these curly braces is going to be the body of this function it's going to do some processing and when processing is done we return out of this function now remember that i said that this function doesn't return anything because it is of void type here but we can return and i'm going to show you the exact syntax of how you can do that okay so we can have many functions in c plus plus but each function has to be unique otherwise you're going to have problems in your c plus plus programs a function is going to be unique based on its signature and the signature is really a function name plus the function parameters if we go back to our example here and try to figure out the signature of this function it's going to be function name and plus the parameters and you see that we have no parameters in here so this signature is going to uniquely identify this function in our c plus plus program if we set up another function that has this same function name and doesn't take any parameter we're going to have problems even if we happen to have a different return value for the function and don't worry if this is not making sense yet we will see a lot of examples and i am sure by the time we are done with this lecture you will be a master at using functions okay now that we have seen how we can declare or define a function in c plus plus let's see how we can use the function and when you call a function in most cases you will want to get something out of that function so suppose here result var is a variable that is going to catch the result of the function and we're going to call the function with the syntax like this we're going to say the function name we're going to put our pair of parentheses here and we are going to pass in the arguments or of the values of our parameters this is the syntax it is going to call the function and the result of the function is going to be assigned to this result var variable of hours here is how you can call a function that doesn't take any parameter the parameter list is basically going to be empty and now we're going to look at a few examples of how you can really declare functions in your c plus plus program for example here we have a function called into bar it doesn't return anything so we can't catch the result of this function and it's going to have one input in the form of an integer so the parameter is called h here it's an integer and inside the function we are going to test if somebody is old enough to enter a bar so we do a test to see if the age is greater than 18 if it is we're going to tell them please proceed f the h is not greater than 18 we're going to tell them you cannot enter this is an example of a function you can set up in your c plus plus programs here is another function that is going to compute the maximum between two numbers it is going to give us a result so the return value is an integer here the function name is max and we're going to put in our list of parameters and again these are the parameters when you are defining your function this comma separated list of things we have in this parenthesis are called parameters and when you call the function the values that you pass in the places of these parameters are called arguments so these are a few terms that can really throw you off and i just want you to be super clear about these things once we have the signature of the function set up we jump in the body and we do whatever we want this function to do so we're going to say if a is greater than b then a must be the maximum we're going to send it that back to whoever called this function or in other words we're going to return a and if a is not greater than b then b must be the maximum and we're going to return it that's what we're saying here here is another example of a function that doesn't have any output and doesn't take any input it doesn't return anything because the return type is void and it doesn't take any input because the parameter list here is empty and the body of the function we're just going to greet somebody and tell them hello there and we're going to return out of the function notice that for avoid function we can either omit the return statement", "52495.916 - 52795.276000000005": "say return and the semicolon and whatever c plus plus compiler you are using is going to accept this as valid c plus plus syntax here is another example of a function that returns something but doesn't take any input the return value is going to be an integer but we don't need to pass something to this function when we call it it's just going to give us output we can call it and get our lucky number and use that however we want in our c plus plus application i think we have seen a lot of examples of how we can set up functions now let's see how we can call these functions here is a simple c plus plus program in the main function we just set up a few variables a value b value a and b here and we use those variables to call functions remember we set up an inter bar function the function looked like this and it was testing to see if somebody's age was greater than 18. if the age is greater than 18 they are going to enter the bar if the edge is not greater than 18 we won't let them end the function takes input but it doesn't return anything so we can call this function like we do here and say into bar and you notice that we're not catching something out of this function we're just going to call it and we're going to give it input which is 22 here and the function is going to do its thing so it's going to let us in because our age is greater than 18. down here you see we are calling the max function here we are giving it two inputs a value and b value and it's going to return something and the return value of this function is going to be used to initialize this maximum number variable here this is what we are doing if we go down we see that we can call the maximum function directly and use its return value in an sddc out statement here and this is going to print out the maximum between a and b and down here you see we have the function say hello which is going to just greet somebody and not return anything here is another example of how you can call the lucky number you say lucky number you pass a pair of parentheses and this is going to return the lucky number and print it out in this htdc out statement here down here we set up a few variables a and b and we are going to use them to call the maximum functions you see we call max a b or we can even pass in number literals like we are doing down here one thing i want you to be careful about is implicit conversions that might happen when you are calling you functions suppose we have a minimum function like we see here which is going to be taking in integer parameters but here we are calling the function with f and g which happen to be of double type like we see on top here so what is going to happen is the compiler is going to notice that what you are passing in is not really what the function takes but the compiler knows that it can insert a transformation from double to integer and it is going to do that without your involvement so be really careful about implicit conversions and make sure they are working to your advantage otherwise you're going to have really hard to debug problems in your c plus plus programs one other thing i want you to be aware of is that if we have a function set up like this this function is going to be taking parameters as copies so if you have two variables for example c and d and you call this function with those two variables you're not going to be manipulating those two variables what you will be working with inside the body of this function are going to be copies of the parameters that you passed in here so if for example you happen to increment either of the parameters for example here we increment a and we increment b the changes we make here inside the body of the function are just going to be affecting copies we have inside the function here and these copies are going to die the moment we hit the end of this function here this is something i want you to be aware of and we will play with that in more detail when we hit visual studio code in a minute here is a simple example of how you can call that function we have two variables h and i and we are going to print them out after that we're going to call the function we're going to store the result back in mult results but the important thing is that we call the function here with h and i remember in the body of the function we are incrementing h and i as arguments but the changes we do inside of the body of the function are not going to be visible when the function returns if we", "52795.276000000005 - 53095.36": "see the same thing we saw before we call the function i realize this is a lot of information to take in now we are going to head over to visual studio code and actually play with us step by step okay here we are in our working directory the chapter is on functions the current lecture is first hand on functions we are going to grab our template files like we always do we're going to put this on and we are going to open this in visual studio code let's open the folder and we are going to go in the correct chapter and choose first hand on functions here this is what we want to open and we are going to open our main cpp file and clean it up a little bit and the first thing we want to do is to set up a function that takes a single parameter and doesn't give back any result so the function is going to be interbore we have seen that the function is not going to return anything so it's going to be void its return type is going to be void the name of the function is going to be interbar and what we want to pass in here is a variable to represent the age of somebody and we know that the age can really not be negative so it is advised to at least use an unsigned integer type so we're going to use unsigned end and the parameter name is going to be called age once we have our parameter list we're going to put in the function body and remember the function body is going to leave within these two curly braces now this is a valid c plus plus function it's not going to return anything it's going to take a single parameter whose type is unsigned and its name is interbar we can get inside the function and actually do whatever it is we want to do so once we go in we're going to test and see if the age is greater than 18 do something if the age is not greater than 18 we're going to do something else let's do that we're going to say if age is greater than 18 we're going to tell them the age and tell them that they can actually go in this is logical and we're going to say else and in the body of this else block we're going to say something else we're going to tell them sorry you are too young for this and we are going to get out of this block here and this is really our function again let's try to analyze the syntax here we have the return type this is required in c plus plus if you don't put it in you're going to get a compiler error because you can't have a function without a return type in c plus plus you notice that we have our squiggly lines here visual studio code is not happy so we're going to tell it the return type we're going to save the function name after that and after the function name we're going to pass the parameters we can have any number of parameters or inputs to the function but in this case we just have one because it is enough for our purposes after that we have the body and inside the body we do whatever it is we want to do in this function here because this function returns void we don't really need to explicitly return from this function here but this is an exception only for functions that return void for other return types you will have to put in the return statement but even for void functions you can put the return statement if you want and you can do that like this say return and you're going to put a semicolon after this this is also valid c plus plus syntax okay now we have declared the function it is a valid c plus plus functions let's try and call it we're going to go down in main because that's where we want to be calling our functions for now and we are going to say interbar we're going to call the function and you use the function name to call it and you're going to put in a pair of parentheses and pass an argument to the function again what you pass to the function when you call it it's called an argument but what you pass through the function when you are defining it like we did here that's a parameter okay so function parameters when declaring functions and when you are calling the function what you pass are function arguments and now we need to pass in some age to this function and let's say 22 and if we do that this is going to be a valid c plus plus program notice that we have this squiggly line it is because we forgot a semicolon here because c plus plus requires to have a semicolon after each statement and now we have a valid c plus program that is declaring a function and calling a function down here in main we can try to build it let's use gcc to do that the world is going to be good you see world finished successfully and we can bring up a terminal and actually try to run this", "53095.36 - 53395.04": "rooster because our program is going to be called rooster like we have been doing all along and at the output is going to be you are 22 please proceed notice that we have this function defined once but we can call it multiple times so for example if you go down here and say into bar and we give it 15 as the age and we try and build again let's build with gcc the builder is going to be good we can clear and run rooster now it's going to say you are 15 please proceed why is that what are we really doing here uh if age is greater than 10 we say 10 here we should say 18. sorry for this we're going to weld again and now it should behave accordingly so let's say rooster here you are 22 please proceed you are too young for this no offense because the age is 15 here you can keep calling this function and you're going to see things printing out you can even call this function in the loop i can't really resist so let's do that we're going to say for size t i and say start from 0 for example or 1 why not and we are going to say while i is less than 10 or 20. we're going to increment uh you already know how to use loops so we're going to be using this as an example and we can comment out all these guys in front because we don't want them to print stuff by now and what we're going to do is call the function with whatever iteration we are at notice that we have a size t here and the function is going to be taken an unsigned integer so we're going to have implicit conversions from size t to end or if we really want this to not cause any problems we can change the type of our parameter to be size t this is also valid c plus plus code let's say size t properly and if we go down here we're going to say enter bar and we're going to pass an i watch what is going to happen this is going to loop from 1 all the way to 19 and it's going to be calling this function with whatever iteration we might be at so it's going to look from 1 all the way to 18 and it's going to tell us we are too young for this but for 19 it's going to let us in because we will be old enough to enter a bar let's try this i think it's going to be fun we're going to weld with gcc and we're going to clear and run rooster ah sorry you're too young for this you too young with us and that once we hit 19 it's going to tell us we are young enough to enter a bar and we're going to go and and have as much fun as we want so this is really how you can declare a function remember a function is uniquely identified by its signature and the signature is really the name of the function and the parameters that you have in here okay once you have the function declared you're going to do whatever you want in the body you are going to optionally return something from the function and once the function is declared or set up you can go in main and call it and do whatever it is you want with it okay now i think we are mature enough to try out a few other functions let's go down and put in another function which is going to compute the maximum of two numbers the signature of this function is going to be its name here and the parameters notice that we are taking two parameters because we want to be computing the maximum between two numbers and this function is going to return something we want to get the maximum out of the function and use it to do something else when we call it so this is the declaration of the function once we hit the body of the function we are going to compute the maximum we're going to say if a is greater than b then a must be our maximum so we're going to return that and if a is not greater than b then b must be the maximum we're going to return b as our maximum here this is what the function is doing we can go in main and call it let's go down and comment this out because we don't want noise output from these guys so calling interbore that's what we were doing now we are calling max so we're going to go down and set up a variable call it result why not and we're going to compute the maximum between 10 and 20 why not okay so let's see what we get and we're going to print the maximum this time we're going to say max as resort okay now if we build this program and run it try to guess what we're going to get we're going to call the maximum function and what we pass in here are arguments again we are not passing parameters here we are going to pass in 10 and 20 as our", "53395.04 - 53696.64": "control is going to jump to the body of the function and we are going to fall inside here the arguments we're going to pass in are just going to be copied in the function and we will have them through these names a and b so we're going to test and see if the first parameter is greater than the second in this case the first parameter is not greater than the second because the first one is 10 the second is a 20. let's go down and see that and the test here is going to fail and we're going to run whatever is in the else block here and we are going to return b as our maximum when we return b b is going to basically be the result of this expression here and that result is going to be assigned to our research variable and we're going to print it out with this sddc out statement here so let's try and build this we're going to build with gcc again the world is going to be good we're going to clear and run rooster you see that maximum is 20. if we try and change this for example make the first parameter 100 and both again let's see what maximum we get going to clear and run rooster we're going to say that maximum is 100 and again you can call this function however many times you want for example we can call it again and say result equals max using two variables that we have let's say x and y and go on top and declare these two variables why not we're going to say and x and we're going to put in it 22 and we're going to say end y and put in a 44 right now and now if we print the result we're going to get 44 because that's the maximum that was assigned back to our research variable here let's weld again we're going to run the task to build with gcc you can clear and run rooster you see max is 44 and this is really how you can declare and use a maximum function like this we're going to comment this out because we have a few more functions we want to try out let's go on top and put in another function and again notice that we are declaring functions before the main function here this is a requirement of a c plus plus compiler because before you use the function the function must be declared somewhere so we need to go before the main function and declare our functions here the function we're going to do now is say hello here it's not going to take any input and it's not going to give us any output it's just going to say hello and die off we can go down and call it this is going to be super easy calling hello and we're going to call it say hello see that even visual studio code knows about this function we can call it like this it's going to be activated so we're going to hit the body of the function we're going to say hello there and the function is going to return or die off please know that you could omit this return statement for functions that return void so if we comment this guy out the function is going to work equally well you can use this however you want now we're just going to build with gcc and see this function run the build is good we're going to run rooster and it is saying hello there let's go down and look at another example here the next function is going to be lucky number it's not going to take any input but it is going to give us an output in the form of an integer so we can call it let's go down and comment out saying hello here and say that we want to call lucky number and we can go down and set up a variable let's do that we're going to say int result and we are going to brace initialize this guy so it's going to be initialized to zero and we're going to say result equals lucky number and we're going to take the result returned by our lucky number function and assign that to the result variable and we can print it out if we want so we can say sddc out and say result and we're going to put that out here say result and if we build and run this program we're going to get this guy printed out we should see a 99 because that's what we are returning from our function here and resort is 99 as you see in the output here so this is really how you can declare your functions a function has a unique signature so for example into bar here has this particular name and these parameters here if you go down mats has its own name and the parameters that it takes in if you go down say hello and lucky number are different in their own ways if you try and set up another function that has the same signature as max here your compiler is going to freak out let's try and do that we're going to set up another function it's going to have a void", "53696.64 - 53995.04": "because we want to match this signature here and we're going to give it two parameters into a and it b and we can do whatever we want in this function notice that we have a squiggly line if we open our problems tab here you're going to see that visual studio code has a few problems with this because we are setting up a function with the same signature twice let's try and different make this a net and see what we get right now we don't seem to have a problem but if we get to run this program we're going to have problems let's go down and actually activate the code to call the max function to really show you this because you need to know so we're going to comment out calling lucky number and we want to call max we're going to activate the code to call max and we are going to build this with gcc notice what we're going to see uh-huh we have problems here we have a compiler error saying re definition of int max and ant and one might think what if i name my parameters differently here for example i call this guy c and this other guy d let's do that using different names like this is not going to solve your troubles because if we try and uh bold again we're going to get the same compiler error this is not going to change your thing we don't have enough tools to really understand this problem but know that you can't have two functions with the exact same signature in a single c plus plus program and we're going to learn more about this later but note that the signature of a function must be unique to it throughout your entire c-plus program if you remember this simple rule you're not going to have many problems so let's try and weld again to make sure we have no more problems in here the bolt is good and we can run the program to see our maximum printed out so let's do that clear rooster and max is 44 it is exactly what we expect the last thing i want to do in this lecture is make it super clear in your mind that what we pass to functions we have been setting up so far are copies so let's go on top and set up a simple function the function is going to increment and multiply it returns a double type the name of the function is increment and multiply and it is going to take two parameters and a double a and a double b once we hit the body of the function we're going to increment a and b the arguments that were passed to the function and we're going to multiply them and we're going to store the result of that in a reserved variable the result variable is what we're going to return to the function and whoever called this function is going to use that to do whatever they want what we really want to see is that the changes we do inside the function are not going to be visible to the arguments that we pass to this function here to really make this super clear let's go down in main and set up a few variables we're going to have a double h and the double i the values are going to be three and four we're going to print them out and we're going to call our increment multiply function notice that we pass h and the i to the function and the result of the function is going to be stored in uh the anc mult resort variable here but the return value is really not important what we want to see is if the changes we do to the arguments are going to be visible on the outside of the function here so remember we have h and i here we pass them to the function once we hit the inside of the function we're going to increment a and b and we are going to return from the function so let's see if a which was a 3 and b which was a 4 have been incremented to 4 and 5. that's what we want to see so we're going to boil this and run this so let's use gcc to do that the bulk is going to be good we're going to clear and run rooster and notice what we have here let's go down and look at the variables again we set up h to contain a 3 so before we increment h and i are four okay so that's what we're going to print here once we hit the inside of the function we are going to say what we have inside the function before we do the operation before the increment again a and b are four so these are copies we have inside we're going to do the increment and after we have the increment a and b are going to be four but once we hit the outside of the function and a print with this guy here we're going to see", "53995.04 - 54296.796": "are still three and four so we didn't really affect h and i when we did this increment here what we affected are copies that were passed to a and b here and this is something you need to know because some people will think that because i pass h and i in my argument list here i can manipulate h and i what you are manipulating are copies that were made by the compiler to pass the arguments to the function here this is something you need to keep in mind and we will learn more about this but i wanted you to learn this firsthand and this is really all we set out to do in this lecture i hope you have a better understanding of what a function is and what you can do with it in c plus plus we are going to stop here in this lecture in the next one we're going to learn a little more about function declarations and function definitions go ahead and finish up here and meet me there in this lecture we're going to learn about function declarations and function definitions the motivation for the topic we're going to be talking about here is that sometimes you really want to separate a function header from its implementation because you don't want to expose all the details about how you do stuff let's look at the simple example in the last lecture we declared a max function which was computing the maximum between two numbers the output was an integer so that's what we returned the name of the function was max and we had two parameters into a and and b but what we did in the last lecture was crop the entire function body in front of main but sometimes people don't want to really see the details of how you do stuff they just want to know a summary of what your function does what we can get out of the function and what we need to give to the function for it to do its job and that's what we're going to see in this lecture if you look here we have the function header in front of the main function and the function header is made up of its return type the name of the function and the list of the parameters and after that we're going to put a semicolon this is called a function header or a prototype and when we do that the compiler is going to be happy and it's going to work with us to compile our program but when we get to link our program to really put it together and make one binary the definition of the function is going to be needed and if you look after main here what we have is a function definition if you look closely you see that it is exactly the same thing we had in the last lecture we have our header information we don't have a semicolon after our parameter list but we have a pair of curly braces and inside these curly braces we have the body of our function now it is really easy to look at this program because we don't have to look at all these details about how this function works we can get first-hand information on how we can use this function and that is what most people are going to be interested in about your function they want to really want to go in and see how you do stuff they will want to use your function to get the output and use it to do whatever it is they want to do if you look here in the body of the main function we have two variables a and b and we use them to call the maximum function we can also set up a minimum function which works in the similar way and we call another function called increment which is going to increment and multiply whatever arguments we pass to this function so the main idea here is that we can split our function in two parts one is going to be the function header which is really going to be the function declaration and the other is going to be the function body with all the details about how the function works and that's going to be our function definition and once we have these two things in place we can call the function in our main function and do whatever we want with that okay now it should be super clear that we can separate our function in two parts declaration and definition and sometimes the declaration part is also called a prototype that's a prototype of a function and it is made up of the return type together with the function name together with the parameters and after that you're going to add a semicolon to make it valid c plus syntax and another thing you should know is that the prototype needs to come before wherever it is called if you're trying to call a function before its prototype is seen in your c plus plus program you're going to get a compiler error and now you might be asking but why did our programs in the last lecture work we didn't split things up and our program was working fine well if you put a function definition in front of the main function that function definition is also going to double as a", "54296.796 - 54595.04": "in the last lecture worked okay now that you have an idea about what a function declaration and the function definition is let's head over to visual studio code and play with us okay here we are in our working folder the current project is function declarations and definitions we are going to grab our templates files like we always do we're going to put them in place and we are going to open this guy in visual studio code let's do that we open this up and we are going to open our main cpp file clean it up a little bit and let's close this pane so that we have some breathing space the first thing we're going to do is set up a maximum function you already know how to do that we're going to specify the return type we are going to specify the function name and the parameters we're going to take in it a and into b and we're going to go in and do whatever we need to compute the maximum between these two guys we're going to say if a is greater than b then a must be the maximum so we're going to return that else we are going to return b okay this is the function and it is really simple we can go down in main and use it so let's say ant x and i put in a five for example and let's say y and put in a two or a three put in whatever you want and then we're going to set up the research variable which is going to catch the maximum i think we can do that and what we're going to assign to this is whatever is returned from our function call so we're going to call this function with x and y so we're going to be computing the maximum between 5 and 2 here the maximum is going to be stored in this result variable and we're going to print it out so we're going to say std see out and i'm going to say max as result this is going to do okay let's try and build this and make sure it actually works this is nothing new so far it is everything we have done in the last lecture now the world is good we can clear and run rooster we're going to get the maximum as a five here and if we try to change this things for example make y 12 and world again we're going to use gcc and we are going to clear these thanks and run rooster we should get max equals 12. this is all fine and dandy but sometimes we don't really want to have the details about how our function works shown in front of the main function here and we can split our function in two parts a declaration and a definition the declaration is really going to be the header part of the function and that's going to be the return value the name of the function and the parameter list but to make it a valid declaration we have to put a semicolon after this so this is our function declaration sometimes it is also called a prototype and please make sure you understand the difference between a prototype and a signature in the last lecture we saw that the signature was only made of the name of the function and the parameter list but the return value was not part of the function signature but the prototype includes all these guys so signature doesn't include return type okay so now that we have our function declaration setup we need to put in a function definition because if you try to compile this program and link it you are going to get problems let's try and do that before we put in the definition we can weld with gcc we are learning so we don't have to fear breaking things a little bit let's clear and try to build with gcc and you're going to see ah we have a problem here and what kind of problem we have the c plus plus compiler is going to compile this program but when we hit the link stage i realize i haven't really talked about this in more detail but we will do in this lecture but the main problem here is that we don't have the definition of this function in place and the compiler is going to search for it and not find it and you see that it is saying undefined reference to max okay so it has seen the declaration of the function but it doesn't know how the function does its job because we don't have a function body in here so to really make this code work exactly as we want we need to put in a definition and the definition can show up anywhere in your c plus plus program in this case we're going to put that", "54595.04 - 54895.04": "definition is really what we have been using so far as our function definition in the last lecture but notice that it has the body information and now when the compiler tries to compile this program it will know how the maximum function is computing its maximum because we have all that information in here so let's say that this is our function definition and shows up after main in this case and we can try and build this and see if the work is good now you see the world is good and if we try to run it we're going to get our maximum exactly like we did when we had the declaration and the definition cramped up before main here but hopefully now you can see that our program is much cleaner because when you look at this you know that we have a function called max it's going to take two parameters it's going to return something and it is called mats so it must be computing the maximum of these two guys but we don't really care how this function does its job how it computes the maximum here and this is the main message here we can split a function in two parts a declaration and a definition okay just to play around we can also set up a minimum function before we do that let's set up its definition down here we're just going to copy the maximum and adapt it we're going to put a copy of that guy here we're going to call it men it's going to take two parameters it's going to return an end but what we test for is if a is less than b if a is less than b then a is a minimum if a is not less than b then b must be our minimum and we can put the declaration of this function on top here so let's go there and say men and say end a and end b and now we can change the call here to say mean and it is going to compute the minimum why not let's do that we're going to say min here and we're going to grab whatever is the minimum between x and y here and that's what we're going to have in this result variable here let's do that we're going to try and use this the build is good so we're going to clear and run rooster now the minimum is five we are calling our minimum function in the last lecture we also set up a function to increment and multiply let's try and do the same thing but split that into a declaration and the definition just to practice a little more we're going to call this and malt and it's going to take a and b in and inside and we're not going to put the body on top here we're going to put the body down with the other definitions that we have for all these other functions for max and mean here so we're going to put in our body it's really simple so we're going to put a body inside this curly braces and we are going to return plus a we're going to increment a and we're going to multiply that with an increment of b and we're going to return that i think this is going to be valid c plus plus syntax and if we try to call this function in main let's do that say in mult and we're going to pass an x and y the program is going to just work fine we're going to grab the result and store that in our variable let's do that and we can print the result and we're going to say result here this is going to do and if we build and run this program we're going to see the output here let's see what we get the results is going to be 78 because if we increment a 5 it becomes a 6. if we increment y we're going to get 13 13 times 6 should be 78 let's be sure we're going to bring up the calculator let's do that so that you know that i am not making these things up 78. so our program is really working like it should and this is the main message here we can really split up functions into a declaration and a definition and that's going to make our programs much easier to work with and read one thing you should know is that the names of the variables aren't really important in function declarations like this so for example we can take out the a and b here or we can take out all the variable names in our function declarations let's do that and you might think is this program going to compile well i hate to break it to you but it is going to compile so let's weld with gcc you're going to see that the both is good so the function header or declaration doesn't really care about the variable names in the definitions we care about these variable names because we are going to", "54895.04 - 55196.48": "want you can leave them out in your function declarations but i like to keep them in place because i like my functions to be self-documented if somebody looks at this they will know the variable name here but if you really want you can leave the variable names out and it is going to work pretty well this is really always enough to do in this lecture i hope you found it interesting we are going to stop here in this lecture in the next one we are going to see how we can split our programs in multiple files now that we know how to split into declaration and definition go ahead and finish up here and meet me there in this lecture we're going to revisit our c plus plus program compilation model along the way we are also going to see how we can work with functions across multiple files if you remember our compilation model looked something like this you have seen this slide a lot of times by now what it describes is what happens when we compile our program the moment we run the compilation command our c plus program which lives in the main cpp file by now is going to be passed through the compiler the compiler is going to process it and it is going to come up with a binary executable that is mostly called rooster in this course and when we execute this rooster file or binary file we're going to get the program to run the program is going to be executed instruction by instruction when it is loaded by the operating system and we are mostly going to see the output of that program on the terminal in this course this is the compilation model we know but now what we want to do is zoom in on this compilation part here and see what really happens under the hood we are going to suppose that we have a program which is made of a lot of source files as we have here on the left suppose we have two three or five source files unlike what we have so far which is one file the main cpp file when you compile such a program you're going to go through a stage called pre-processing and what this is going to do it's going to look for your include statement and it is going to take whatever file you are including and it is going to paste that in place so for example here you see we have an include io stream statement when the pre-processing stage is run this includes statement is going to be replaced with whatever we have in this io stream file here so this is going to be wiped out and we're going to put in the content that we have in io stream in this exact place where we have the include statement i hope this is clear so when we go through preprocessing we're going to have a version of our source files with the included parts put in our source files we're basically going to go copy everything in that file that we include and we're going to paste inside our new files here that we're going to be referring to as translation units by now these are translation units in a c plus plus program once you have this translation unit then you're going to compile them they are going to go through the compiler the compiler is going to generate what we call an object file and this is a binary representation of the content you have in your translation unit so each translation unit is going to generate one object file and for example if you had 20 translation units in your program you're going to have 20 object files once we have object files they are going to be processed by what we call the linker and the linker is going to stitch them together and have one single binary file out of all these object files so we're going to have something like this and this is basically going to be our binary that we can run on our target operating system so by now you see that our compilation model has expanded to contain three phases we have pre-processing compilation and linking now you might be asking why am i showing you this now well it is going to matter because we're going to split to a program across multiple files some of those files are going to matter on the compilation phase and some of those files are going to matter on the linking stage so we really need to make a clear distinction between the compilation and linking here okay this should be a more complete compilation model to go by for now now that we know about this compilation model we can look at how we can split our program across multiple files suppose we have three functions one we can use to get the maximum of two numbers called max a function called men we can use to get the minimum between", "55196.48 - 55495.68": "increment and multiply like we have seen in the last lecture now the two functions maths and men are going to live in their own file and that file is going to be split in two files we're going to have a header file and a cpp file which is going to contain the implementation in the header what we're going to have is just a prototype and we are going to set up our code in a way that our anchor mult function here is going to live in zone file we're going to split that in two files so we're going to have a header file called operations.h and we're going to have an implementation file called operations.cpp which is going to contain the implementation of this function here when we hit the main file what we're going to do is nothing special we're just going to include the headers and we are going to use these functions like we have been using them all along if you look on the first line here we are calling max on the second line we are calling men and on the third line here we are calling incur mult to do whatever it does okay when you start splitting your functions between the definitions and the declarations remember the one definition rule and this says that you can't have a function defined multiple times in your entire c-plus class application if you do that the lincoln stage is going to find those two functions and it's going to not know which one you really want to use and you're going to get a linker error we're going to see that when we hit visual studio code in a minute another thing is that you know that your definition can really leave anywhere in your code the linker is smart enough to parse your entire project looking for the definition for whatever function it's found in your source code and it's going to keep looking until it finishes looking in all translation units and when it doesn't find the definition it's going to give you a link error which is probably going to say undefined reference to something and we're going to see an example of this in a minute okay now that you know about this updated compilation model and you have an idea that we can split our functions across multiple files we're going to head over to visual studio code and play with us okay here we are in our working folder the current project is multiple files here we're going to grab our template files let's copy that and put that in the project of interest and we're going to open this in visual studio code let's do that we're going to open the folder i'm going to choose the project and open it and we are going to open up the main cpp file here and clean it up a little bit we are going to set up a max function and remember the function has to show up before it is used somewhere and uh we are going to split this into a definition and a declaration i think we already know how to do that so let's do that we're going to put a definition down here and we're going to change what we have on top here into a declaration let's say that to be super clear and what we have down here is a definition and we can call this function we're going to set up the variable which is going to store our max for example and we're going to assign whatever we get from the function to max here so we want to find the maximum between 34 and 56 for example and we're going to print this out i'm going to say max is the maximum and if we boil and run this program let's use gcc to do that we have a compiler error here what is that we need a semicolon not a column here i think the squiggly line is now going to go away and our things are named the same way the compiler is not going to like it let's bring up a terminal so that we see our problems tab expression preceding parentheses or parallel must have ah okay the problem here is that these two guys max and max are called the same and this is going to confuse the compiler a little bit so what we're going to do is call this maximum no big deal here and we're going to do maximum here and the compiler is going to be happy now we can compile and i've built this program world is good and if we run it we should get our maximum printed out let's see that the maximum is 56 and if we change 34 here to be 134 and both again we should grab that as the maximum let's see if that's the case here run the program the maximum is 134. so this is working exactly as we want the next thing we want to do is to split this function across multiple files so we're going to set up two different files one is going to be a header file", "55495.68 - 55795.68": "you have to follow this structure in c plus so we're going to go on the left here and add a new file in visual studio code you can click on this little icon that says new file to create a new file once you do that you're going to be given this little window in which we can type the name of the file we're going to call this compare dot h it's going to be our header file and we're going to add another one which is going to say compare that cpp okay our two files are going to be compare that h and compare that cpp and they are going to contain our functions to compare stuff so we're going to have in a function called max and another function called men for computing the minimum let's go there and actually do that we're going to move our declaration in the header file so your declarations are going to be leaving in header files and we're going to grab our definition and move that in another file called compare.cpp so i'm just going to cut it out and paste that and compare cpp here once we do that we're going to go back in main and see that we have a problem now the main function doesn't know what this max function is because it's not declared anymore and if we're trying to compile our program we're basically going to get the same error we see here and visual studio code identifier max is undefined because it doesn't know what this function is if we ignore this and try to weld let's do that we are learning so no big deal here we're going to get an even much weirder error but the message is going to be the same maths was not declared in the scope so the compiler doesn't know what to do with whatever we typed here but there is a way in c plus plus we can solve this problem by including the header that contains our declaration for the function that we are using here we can go back in main and do that and we're going to say include and we're going to say compare that h that's going to bring in our header and if you wait a minute you're going to see that the squiggly line is going to go away so what happened the preprocessor is going to come in and copy whatever we have inside compare.h it's basically going to go and compare that age copy everything we have in here and come back in main and paste all that in the place where we have the include directive here this is called an include directive or an include preprocessor directive this is what the preprocessor is going to do here and now if we try to build this program let's try to do that we should be fine world finished successfully and we can run our program to see the maximum printed out let's run rooster maximum is 134 now everything is working let's add another function here because just having one function is really boring so we're going to put in a main function it's going to type into a and into b and we're going to go in the cpp file and put in another definition for the minimum function here we're going to call this man let's do that let's call this man and we're going to test for a is less than b this is going to give us a minimum and now if we go back in main cpp we will be able to use our minimum function because it is protein also by this preprocessor directive we have here so we can go down and say end minimum and we're going to say man and let's grab 146 and 23 why not and we're going to print the minimum here and we're going to build this with gcc the bullet is going to be good if we run this we should see both the maximum and the minimum from these calls we make here okay by now you should have an idea about how to split your functions across multiple files you should also know that you will have to include whatever header contains the declarations for the functions that you want to use another thing i want you to see is that the definitions for your functions don't have to live in a file that is named the same as the header file for example here our header file is called compare and the comparison tpp contains our definitions but the definitions don't have to live here they can really live in any translation unit that you have in your c plus plus program and our c plus plus programs the translation unit is mostly equivalent to a cpp file so let's set up another file and show you that we can move this definition there and the program is going to keep working we're going to add", "55795.68 - 56095.36": "other file that cpp it has to be a cpp file because it's going to contain the implementations and let's take the implementations for example let's take them all put them in another file why not we're going to grab all these guys here let's catch them out and put them in some other file and i'm going to build this and see that it works it should because the linker is smart enough to go find these definitions and whatever translation units that we have set up in our project here and you see the world is good we can upload this we can run this i should say and we're going to have our output here we can even take one of these guys let it leave in our compare.cpp file for example let's take the minimum function here and we're going to bring that back and we're going to work notice that now our maximum function is living in some other file and that the minimum function definition is leaving and compare that cpp but if we will this is going to work again the linker is going to parse all the translation units looking for whatever definition it needs to find and in this case it will be looking for the maximum here and it's going to find that in some other file and for the minimum function here it's going to be looking and compare and it is going to find it and the world is going to be good and we can run the program again and see our output here one thing i really need to point out is that if the definition is not available let's say the minimum function here is not there we can comment it out to hide it to the compiler or hide it from the compiler and if we try to vote now we will get a linker error let's try to build with gcc uh-huh world finished with errol's the terminal process terminated with execute code -1 but the main message here is that we have an undefined reference to min and and so when we compile the compiler is going to be happy with the declarations that it has found in our compare.h file if we go there we see that we have a declaration for max and the declaration for man the compiler is going to be happy it's going to compile our code and when the compiler compiles it's going to generate object files and it will hand the job over to the linker to stitch all those little object files together to have one single binary file once the linker tries to do that it's going to look at main because that's where it's mostly going to start from and it's going to see uh-huh main is calling minimum here where is the definition for the minimum function it's going to parse every single translation unit in the project it's going to come here and compare that cpp it's not going to find it it's going to look in main.cpp it's not going to find it it's going to look in some other file it's not going to find the definition and the linker is going to say i didn't find my definition for the minimum function so i'm going to throw a linker error and you the developer you're going to fix this problem and you're going to see this error here and again this is a linker error gcc doesn't give you more visible stuff to show you that this is a linker error but what you should look for is ld returned 1 here because ld is the linker that gcc uses so this is a linker error i think i should show you how a linker error looks if you are using a microsoft compiler so we're going to build again but now we're going to build with msvc if you don't have visual studio that's not a problem you can keep using gcc but i just want you to see how different compilers handle these arrows i have the luxury to do that because i am developing this course on a windows machine and i have a microsoft compiler handy that we can use directly from visual studio code here so i am going to choose this compiler and you're going to see that it is going to start welding it is building and it is going to fail and throw a link arrow also so you see here some other object file okay when this object file was being taken and stitched together with other object files to put together a binary it didn't find the definition for the minimum function and it is going to throw a linker error and in visual studio you're going to have a problem like this l and k and it's going to give whatever version of the compiler you are using but down here you see unresolved external symbol this is how visual studio says it and", "56095.36 - 56395.52": "an undefined reference to something this is just visual studio's compiler's way to say this and again it's going to say this is a linker error here it is basically the same error we saw when we were using gcc in a minute video studio the compiler from microsoft is also going to put a lot of junk in our folder here so let's remove all these things i'm going to select them all and i hate to delete here and they are going to go to my recycle bin and we have another one here we should remove let's remove it and now we should go back in some other file.cpp or compare.cpp that's where we have a minimum function we can activate it and if we're both now the world should be good because the linker is going to find this definition here okay let's build with gcc because that's my favorite compiler now you see that the world is good we can clear and run rooster and our program is going to work as it should this is really how you can split your functions across multiple files the headers are going to contain the declarations the cpp files are going to contain the definitions your definitions can really leave anywhere it's going to be a matter of what works better for your project but for organizational purposes your cpp files are going to be basically like this you're going to have some declarations in the header like compare.h and in a corresponding cpp file you're going to have and the definitions for whatever declarations you have in the header but you don't have to do it this way if it makes sense for your definition to show up somewhere else please go ahead and do that c plus plus is going to accept that this is really all we set out to do in this lecture but before we go i'm going to give you a chance to set up another function suppose we have a function called anchor malt and we're going to have the function set up in here we're going to return a plus plus we already know how to do these things we've used this example a couple of times by now plus plus b and that's what we're going to return now your job is to split this function into a declaration and a definition and put those in two separate files one is going to be called operations.h and the other is going to be called operations.cpp pause the video go ahead set up your project like that and call that function in main cpp and see if you can pull that together okay post the video do that and once you are done come back again and see how i do this so we're going to set up a new file called operations here it's going to be a header file dot h and we're going to add another file called operations.cpp that's going to be our cpp file which is going to contain our definitions we're going to go back in main and grab the entire function here we don't want it in main so we're going to go in the header here we should go in the operations header that's where we want this and we're going to put in our definition and we're going to put in our declaration the declaration doesn't have a body so we're just going to put a semicolon at the end here you already know this we're going to go in the cpp file and put in our definition this is going to work and to be able to use this function we will need to include the corresponding header here why is this file called uh it's called ccp it's cpp we're going to rename it and we're going to change this to cpp now we should be fine we should have our thanks colored properly and uh to use this function we will need to include the corresponding header which is operations.h let's do that we're going to go in main and go down and include operations dot h this is going to work and notice that the way we include our own headers is different from the way we include the libraries or headers that come with the c plus plus standard library this is a conversion that is used by many compilers this is how we will have to do things please remember this if you are including your own header please put that in the quotes like we do here if you are including a standard library header please use angle brackets like this now that we have this included we can go down here and say result we're going to set up two variables x and y why not we're going to have a 4 here", "56395.52 - 56696.08": "five let's do that and we're going to have an integer to store our results it's going to say anchor mount and it's going to do the operations on x and y let's do that and we're going to print the results here so we're going to say result and it's going to be whatever we have in that variable okay if we build this program it is going to work we're going to use gcc to world the world is good if we run it we should see our output here going to run rooster and the result is 24 because okay if we increment x we're going to get a 5 and if we increment a 5 we're going to get a 6. if we multiply these guys we should get a 30 and that's not what we have here so what is happening let's look at our definition here ah we said a plus plus we should say plus plus a because we want to increment immediately okay let's build again we are going to well successfully and we are going to clear and run rooster now we have the result that we expect let's go back in main and look at our program this is what we are using here and this is the output we expect this is really all we set out to do in this lecture showing you how you can set up your project to split functions across multiple files this is really good if you want to organize your project for example somebody who comes to the header here is not going to be bothered by looking at all the definitions and the details of how we compute this maximum and minimum and we have the flexibility now to move our headers in some other file because we really want to keep the main function or the main file here really clean we don't want all those definitions to show up here because it is possible for your project to contain hundreds or even thousands of definitions if you make all those declarations show up in the main cpp file here that's going to be really hard to follow and work with now we have the flexibility to split those guys across multiple files and we can even use lots of headers if that is what is going to work for our project this is really all we set out to do in this lecture i hope you found it interesting we are going to stop here in this one in the next one we're going to see how we can pass parameters to functions by value go ahead and finish up here and meet me there in this lecture we're going to see what is meant by passing parameters to a function by value and we're going to look at an example of that here we have a simple function called say age it's going to take one parameter which is an integer called age and in the body of the function we are printing out the age after incrementing it suppose this is something useful for your program the function is split into declaration and definition we have a declaration on top here and we have our definition below the main function in the main function we will attempt to use this function we're going to call it down here and we're going to pass a local variable which is called age as our age when we do that we expect this to print you are 24 years old because we're going to increment the age and we're going to say hello you are 24 years old this is what this program is going to do but we want to keep track of how the outside variable here is going to change and the age we have passed as a parameter here because this edge we pass as a parameter is not going to be the same as the age we have on top here what we pass here as a parameter is going to be a copy of the actual variable that we passed here and this mechanism is called passing a parameter by value and what you really pass is going to be copy and what you work on inside the body of the function is not going to be the original stuff you passed as an argument to the function so we're going to try and prove that here we're going to print the age before we call the function we're going to print the age after we call the function and what we print here is going to be the outside variable because here we are in the scope of the main function inside the say edge function what we're going to be modifying is a locker copy so we expect the edge here to stay the same before and after the function call so the way this is going to work when control has this function here it's like we're going to have a situation like we have here on the left we're going to set up local copies in the function that are going to contain whatever was passed as an argument to this function and this edge here was passed as an argument to a", "56696.08 - 56996.24": "copy of this h and we're going to store it and it is what we're going to be manipulating in our program when the function goes out of scope the local copy is going to die and the outside variable we have here is basically going to be unaffected let's head over to visual studio code and show you this in action okay here we are in our working folder the current project is passed by value we're going to grab our template files and we're going to put them in place in the correct project and we're going to open this up in visual studio code let's do that we're going to open the folder that contains the project pass by value let's do that we are going to open it up and i'm going to go in the file and clean it up a little bit and we are going to set up a function it's going to not return anything and it's going to say age and it's going to take an integer which is going to be our age and inside we're going to increment our h i think this is what we saw in the slides and we're going to say however many years you are old we're going to say hello you are age old and we can set up a variable and the main function we're going to call it h and it is going to contain 23 as our age we're going to say age and we're going to pass in our age here we can do that if we're trying to run this program let's try to do that we're going to build with gcc and we are going to bring in a terminal we can use to run this program easily from visual studio code here let's run booster we're going to say hello you are 24 years old and this is what we expect because when this function is called we're going to increment the age then we're going to say the age but we want to see what happens to the outside edge ear if we modify the inside edge that we have on this function here that was passed as an argument and again what you pass when you are declaring your function is the parameter and what you pass when you are calling the function is called an argument in c plus plus please remember this okay what we pass as an argument is our anti-age variable which is local to the main function and we're going to see what happens to it let's print the age and say age before call i think this is descriptive enough and we're going to print that and we're going to go after the function is called we're going to say the same thing but we're going to say after call and by after we mean after we call the function say h here i think this is descriptive enough and we're going to see that if incrementing the local variable to the function here affects the variable that we have and the scope of the main function okay so let's see that we're going to build with gcc as always and the wealth is good so let's clear and run rooster you're going to see that before the call we have 23 and after the call we have 23 we didn't change the second call this is a classical copy paste error we're going to change that for our program to really be descriptive enough okay the world is good we can clear and run rooster and now we have before call 23 after call age is 23 it wasn't changed by what we have inside here and we can even go further and look at the memory addresses of these guys here we can try and print the address of the age variable let's let's do that we're going to say address of age and put that out here we're going to say address of age no big deal here we can close the pane on the left here because it is taking up valuable space and we're going to go to the second statement and put in the address of age and we're going to print that out we can do that now we know the address of operator okay we can do that and when we hit the body of our function here we can also print the address of age no big deal so we can say address of age let's do that here and we're going to print the address of the local edge variable here which was passed as a parameter here okay now we can build our program and watch those addresses we're going to build with gcc the world is good we can clear and run a rooster now you see that the outside variable is going to leave at an address that ends in dec and the local variable is going to leave at an address that ends in dc0 so this is a completely new memory location that we are using and it is just going to contain a copy of what we passed as a", "56996.24 - 57296.4": "to take care of setting up this copy variable and have it available for use in the local function here we don't have to worry about that but we have to be aware that what we are working on and the same age function here is a copy it's not the original value this is really all we set out to do in this lecture making you aware of the call by value mechanism and the main message is that what you are working on in the body of your function when it is called is going to be a copy of what you have passed as an argument when your function was called here in this lecture we're going to see how we can pass parameters to functions by pointer this is going to allow us to avoid the copies that we were experiencing when we were passing parameters by value like we have seen in the last few lectures here is a simple example showing the syntax we can use to pass parameters by pointer on top here we have our function declaration and down here we have our function definition and you see that the syntax is the same we are passing by pointer and by pointer and the definition here and another thing you should be careful about is that when you call a function that passes by pointer you have to give it an address and that's what we are doing here so we are passing the address of our age variable which is going to be passed by pointer when we pass by pointer we want to be modifying a copy inside the body of our function if you look here we are incrementing the edge variable but we are doing this through the referencing so when we pass a pointer here the pointer is going to contain the address of this guy and in the body of the function the pointer we will have this edge pointer is going to be pointing to the original variable here okay so this edge pointer is going to be pointing to the original edge variable when we dereference it and modify the variable we're going to be affecting the original variable i really hope this makes sense and this is really what passing by pointer is all about you declare your functions by passing in pointers like this and in the definition you do the same and when you call the function you need to pass in an address of the variable because that's what we store in a pointer here and this is going to work if we try to run this example here we're going to print 23 because that's the original value we are going to call the say age we are going to increment and this is going to change the original value if we print here we're going to get 24 and when this function terminates we're going to hit this statement here and we're going to print 24 this is what we're going to see when we get to run this program here and this is really all there is about passing by pointer we are going to head over to visual studio code and play with us a little more okay here we are in our working folder the current project is passed by pointer we are going to grab our template files here and we're going to put them in the current project which is pass by pointer we are going to open this in visual studio code pretty quick we're going to choose that pass by pointer we open this and our main cpp file should show up here we're going to clean it up a little bit we are actually going to grab the code from the last lecture and put that in here and that's going to be our starting point let's close the left pane here so that we have some breathing space the function here say h is going to pass by pointer so we should take out this cost here and uh have a pointer here like we had in the slides we're going to do the same in our definition here if we go down we're going to do that we're going to pass by pointer and we are going to uncomment the line that increments our age here okay after we do that you see that we have a squiggly line at this line that calls the say age function what we need to do is to pass it the address of the edge variable here like we saw in the slide so this is the syntax we have to follow once we do this this program is going to be valid and if we run it here we're going to print 23 because that's the value we have in here we're going to call the say age function we are going to increment age and here we forgot to do our dereferencing so what we need to do here is to dereference the age and increment it this is going to increment the original variable here and we're going to be accessing this through the the referencing operator of our pointer here if we hit this line and the function here we're going to print 24", "57296.4 - 57595.520000000004": "incremented through this statement here and after the function call we're going to hit this statement here on line 10 and it is going to print 24. this is what we expect take a moment to make sure you really understand this the things you need to be careful about is the syntax we use to declare the function here we say that we are passing by pointer because of this little star here and we have the same thing when we hit the definition of the function we have this little star so we are passing by pointer another thing you should remember is to pass the address of a variable when you call the function like we do here and please remember to use the the reference operator whenever you want to modify whatever variable is leaving at the address that you passed in here so that's why we are the reference in here through the star operator like we are doing here this is really all you need to be careful about so we are going to try and run this program let's do that we're going to build with gcc the boiler is going to go through we need to bring in a terminal so that we can run this program and again we expect to see a 23 24 and 24 here print it out so let's run rooster okay here is our output before we call the say age function the age is 23 the address is dec when we hit the function we are saying hello you are uh years old so here we should have the reference to access something inside the variable here so we should say you are age old we need to dereference this guy because now it is a pointer i forgot that i really am sorry but we are learning so this is a good learning chance for you not to make the same mistake as i am making here so let's try and build again we should see the correct output we are going to clear and run rooster now we see that before the call ages 23 when we call the function h becomes 24 because we just incremented through our reference operator and after the function call the edge is going to be 24 because we have modified the original variable here through our the referencing of the pointer here this is really all there is about passing by pointer this is the syntax you have to pass a pointer in the declaration you have to pass a pointer in the function definition and when you call the function you have to use the address of the variable and pass that as an argument to the function and whenever you need to use the past parameter you're going to go through the the reference operator like we did here and here in the body of our function here in this lecture we're going to see how we can pass parameters to a function by reference and this is another technique we can use to avoid passing by value which is going to create a copy and the syntax is really simple if you look at the declaration here you're going to see that we say and reference and again if we hit the definition we're going to say into reference as you see here when we call the function we don't have to pass the address of operator we just passed the variable because this is going to be treated as a reference by the compiler and in the body of the function we don't have to go through ugly the referencing like we did with pointers and hopefully you can see that if you want to avoid copies passing by references is much cleaner you don't have to use the address of operator when you call the function like we do here and you don't have to go through the reference and to access and modify your variables and the modification we do here by incrementing age is going to be seen on the outside because we are going through a reference and the reference is a true alliance to the variable that the reference is referencing so by incrementing the edge here and the body of the function the change is going to be seen after the function call before the function here we're going to get 23 in the body of the function we're going to get 24 because we just incremented the function and after the function call we're going to get a 24 because the change was propagated to the original variable and the reason is because we are going through a reference here let's head to visual studio code and actually play with us a little more okay here we are in visual studio code the current project is passed by reference 1710 here so we're going to grab our template files and put them in place 1710 let's do that and we are going to open this in visual studio code pretty quick", "57595.520000000004 - 57895.596": "to show up here again we are going to grab the code from the last lecture and use that as a starting point and we're going to be modifying the signature of our function here so what we want to do is to pass by reference we're going to say enter reference here you already know references from a previous chapter and we are going to hit the definition here and do the same thing so let's say and reference age and when we call the function we don't need to pass the address of operator because this is a reference we can use it right away the compiler is going to know that this is going to be a reference to the original variable that we passed here and in the body of the function let's take out this last line here we don't need it and in the body when we want to modify the reference we can do that right away without the referencing so we can just say plus plus h here and the changes are going to be propagated to the original variable here because we are going through a reference let's go down and modify this because this is a reference we can use it right away and we can close this left pane here so that we have some more breathing space and you see that visual studio code is no longer giving us any squiggly lines so this must be valid c plus plus code again notice the syntaxes we are using here we are passing a reference in our declaration we are passing a reference in our function definition here when we call the function we don't need to do any address of operator we pass the variable as is and in the body of the function we don't have to do any dereferencing we can increment right away or modify the variable however we want the changes are going to be propagated to the original variable because we are passing a reference so the incrementation here is also going to affect the original variable that was declared in the main function here let's take this out and down here if we need to use our variable we're going to just use it right away we don't need any referencing and if we print the address of age here we're going to see the same address we see on the outside because this is a true alias it's going to be referencing the same variable that we have in main here okay now that you have a better idea about this we are going to try and build this we're going to use gcc as always you can see that the build is good if we bring up a terminal to try and run this program we can clear and run rooster we're going to see that before we call the function the h is 23 but the address ends in dec when we hit the function the edge is 24 because we just incremented that here but notice that the address of the variable is the same as on the outside so we are modifying the same variable and when the function is done the edge is still going to be 24 because we just modified the original variable through a reference here okay this is the effect of passing by reference you can use a claim syntax to modify the original variable in your functions and this is going to avoid copies like we have seen when we were passing parameters by value a few lectures back i would like to welcome you in this new chapter where we will be focusing on how to get data out of functions again the model of the function is really what you see here it is like a machine and you can give input to that machine and you expect to get something out of that machine this chapter is going to focus on this part here and we're going to see the different facilities offered by the c plus plus programming language to get output from functions and we are going to start in the next lecture and see how we can use input and output parameters go ahead and finish up here and meet me there in this lecture we're going to see how we can use function parameters to get data out of the function here is a simple example and we have three functions here we have max str max and and max double and you notice that we have three parameters for each of these functions the first two parameters are going to be input they are going to get data and the function and the third one is going to be the output parameter and it is going to get data out of the function let's focus on max hdr here and really drive the point home the key idea here is that for the third parameter we are using a modifiable reference and if we use a reference the changes we do inside the function are also going to be visible on the outside and we explicitly", "57895.596 - 58196.796": "other parameters because we want to be able to modify the output variable here inside the function if we marked the third parameter as const we would get a compiler error if we're trying to do something like this and assign something to the output parameter here so the main purpose of this function is to compute the maximum between these two strings we are going to say if input 1 is greater than input 2 then input 1 is going to be our maximum and we are going to store that in our output parameter here if input 1 is not greater than input 2 then input 2 is our maximum we're going to store that in our output and whoever has access to input 2 outside the function is going to see the changes that we are making in the body of the function this is really the technique we can use to send output from the function and make it visible when the function has returned and again the key idea is that we set up the function in a way that the changes we do inside the function are going to be visible on the outside and we are able to do that because output here is a reference this is really key we have used references here but we can set up the same thing using pointers because we have seen that with pointers we can also make our changes inside the function visible to the outside the two other examples here are really extensions of the same thing we have two input variables input 1 and input 2 and output is going to store the output from the function you notice that output is a reference and because of this the changes we do in here are going to be visible when this function has returned and we do exactly the same thing on max double here but you see that it is using a pointer okay i really wanted you to see this so inside we're going to try and figure out who is the maximum and if input 1 is the maximum we're going to write that in our output variable here and you notice that we are the referencing here because this guy is a pointer and if input 2 is our maximum we're going to write that in our output variable here one thing i don't think i explained here is that we have a cost std string reference here for maxed hdr and the reason is that the input variables aren't really meant to be changed that's why we market them as cost and if you want to modify them in some way you can take the const away and it is going to work okay this is really the big idea we are playing with in this lecture using function parameters as a way to output data from the function and here are a few ideas you should keep in mind output parameters should be passed in such a way that you can modify the arguments from the inside the functions and we have seen that we have two ways to do that we could either use references or even use pointers but references are what you should prefer in modern c plus plus input parameters shouldn't be modified they are meant to just get data in the function and that's why in most cases you're going to see that they are marked const okay now that we have seen all these ideas i think it is time we headed over to visual studio code and actually played with them okay here we are in our working folder the current project is input and output parameters we are going to grab our template files like we always do we're going to put them in place and we are going to open this guy in visual studio code we're going to just drag it and drop on top of visual studio code here and it is going to open up we have our main function here we can close the pane here and clean the file up a little bit we're going to remove what we don't need here and we're going to have a bare main function we can play with here the first thing we're going to do is to put in our max str function it is nothing special we just have two input parameters and one output parameter the output parameter is going to be what we use to get output outside the function and inside we're just going to compute the maximum if input 1 is the maximum we're going to write that in our output parameter if input 2 happens to be our maximum we're going to write that in our output parameter because our output parameter is a reference the changes we make inside the function are going to be visible on the outside because we will be working on the original variable through the reference which is really a true alias here okay now that we have the function set up like this we can head in the main function and try it out we're going to set up three variables of type std strand i think we should include the string library here let's do that and we're going to have an out string which is going to be our output variable and we have two input strings", "58196.796 - 58495.916000000005": "other is initialized with bell view and we're going to call our max sdr function here you notice that it's not going to be using the return mechanism we're going to be grabbing the output from this function using an output parameter which is going to be our out hdr variable here okay once the function is done we're going to have the maximum stored in our out sdr variable here and we can print it out now that we have this setup we can actually try and build this we're going to use gcc let's do that the build is good we can bring up a terminal and clear and run rooster now you see that the maximum is going to be bell view let's try and change this to casablanca why not and we're going to see that the maximum now is going to be casablanca and our function is going to be smart enough to store the maximum in this output variable here let's build again the world is going to be good going to clear and run rooster now the maximum is casablanca hopefully you understand that we are able to make the changes in the function processed because our output parameter here is passed by reference this is a true reference and any change we do to the output parameter here is going to be visible in whatever variable you passed as an argument for this third argument here this is what is making this work now that this is working we're going to comment this out and put in another example for you to play with the next function we're going to play with is going to be max and as you see here and it is very similar to our max hdr but you notice that our inputs are no longer references because we don't really mind copying fundamental types in c plus plus they are small in memory so copying them is really cheap we can pass them by value and this is not going to be so wasteful in our program but the first parameter must be passed by reference because we want to use it as an output parameter and we're going to use it to get output from the function and the way we're going to do that we're going to write whatever variable is the maximum in our output parameter and the changes are going to be visible on the outside now we are going to head over in our main function set up a few variables and play with us so we're going to say and out and this is going to be our output variable and we're going to say input one let's say in one and we're going to initialize this with a 45 why not and we're going to say ent in two and we're going to initialize this with 23 why not now that we have this we're going to say max and and we're going to put in our input we're going to say n1 and n2 then we're going to say out and as our output variable now that we have this we can actually print out whatever number is the maximum through an output statement like this really simple we're going to say max and and we're going to say out to end that's where it is going to be stored and we are able to do this because again the third parameter here is passed by reference and any change we do and the function here is going to stack even when the function here has returned and we're going to have that stored in our third parameter here and this is a really common technique especially in code that has to interface with c code out there from c plus plus and you really need to be aware of this now if we run this program we're going to see our maximum printed out and it is going to be stored in our out variable here let's do that we're going to use gcc to world the world is good you can clear and run rooster and you're going to see that the maximum is 45 if we change and store our maximum in into here and for example let's make this a 723 let's build it in to take the changes into account in our rooster.xe binary we're going to clear and run rooster and you're going to see that that's the maximum here we are able to grab whatever is the maximum from these two input parameters and store that in our output parameter here because we are passing that third guy as a reference this is really important we have seen that we can use references to make changes we do in the function stick and be visible in outside variables but we can also use pointers and i am going to show you an example of how we can do that first we're going to comment this out because we don't want noise output in our program and we are going to go on top and set up a max double function which is going to grab our output using pointers the name of the function is max double it's not going to return anything", "58495.916000000005 - 58795.916000000005": "parameters input 1 and input 2 and it is going to tell us whichever of these 2 is the maximum the maximum is going to be stored in our output parameter but we are using pointers to make these changes inside the body of the function stick and be visible on the outside of the function so we are going to the reference here because the third guy here is a pointer and we're going to store in whichever is the maximum and when the function returns the maximum is going to be visible on the outside so let's go down and try this out we're going to say double out double and we're going to set up our input here we're going to say in double one and we're going to make this 45.8 why not and we're going to do a second input parameter and int we should say n not end sorry for this in double for input double so we're going to say double 2 and we're going to initialize this with 6.9 for example we can really put in anything now that we have this we can call our max double function let's do that going to say max double we're going to say in double one and in double two let's do that and we're going to have out double as our output parameter and uh because it's a pointer we need to pass this guy as an address so we're going to say address of how to double here that's how we're going to be able to manipulate that inside the function here once we do this we are going to have our maximum stored and out double and we can print that out so we're going to say stdcl max double and we're going to say mac and we're going to say out to double std e and el and if we weld why do we have a squiggly line here we don't have a semicolon at the end of our function called here so we're going to build with gcc as always you're going to see that the world is good we can clear and run rooster max is 45.8 if we change and store our maximum and in double to here we can change this guy to 76.9 we're going to build and see that we are actually grabbing the maximum regardless of the variable in which it is stored if we run rooster we're going to have our maximum and this is working exactly as we want this is really all we set out to do in this lecture showing you how you can use references to use parameters as output channels for data to get outside of the function and be used in variables that are outside the function here i really hope this makes sense and this is a technique you need to be aware of we're going to see other techniques to do the same thing and uh starting in the next lecture we're going to see how we can return from functions for now i hope you found this lecture interesting we are going to stop here in this one in the next one we're going to see how we can use the return mechanism to get data outside our function go ahead and finish up here and make me there in this lecture we're going to see how we can get data outside of a function through the return mechanism and this is going to be an alternative to the way we have been doing things in the last lecture where we used function parameters as channels to get data outside the function let's look at the simple example of how this is done here we have a simple function called sum the function is going to return end and it is going to sum up two parameters that we pass to at nta and end b if we get inside the function we're going to do something really simple we're going to set up a new variable which is local to the function we're going to call that reserved it's going to be the same type as our input parameters and we're going to add up a and b and store the results back in our result variable here once we have this we're going to return this for this variable to be visible by whoever called this function here one thing you should know is that this variable is local to this function here and it will be destroyed the moment we hit the end of the function here and the function terminates so if we go in main here we're going to try and see an example of how we can call this function we have two variables a and b and we have a new result variable set up in the main function please note that this variable is very different from the variable we have and the sum function here because they live in different scopes okay we are calling our sum function here and we are passing it two arguments in the form of a and b here the function is going to compute our sum and it's going to return it and we're going to store that back in our local variable to the main function here the result variable here again is local to this main function okay once we call this function we're going to have our results stored in here and if we print", "58795.916000000005 - 59097.52": "printed out on the console in this case it's going to print 50 because 34 adding 16 that's going to be 50. but one thing i want you to know is that this is going to return by value and what we mean by this is that we're going to copy whatever we return here and store a copy of that in this result variable that we have in the main function and we're going to prove this notice the stdc out statement we have here this is going to print the address of this local variable and once the function terminates we're going to try and print the address of this resort variable in the local scope of the main function and we're going to see two different addresses and hopefully this is going to prove that we are returning a copy it's not the original variable that we have in the sum function here that we are returning okay hopefully this drives the point home that we can use the return mechanism to get data outside the function and we're going to grab the result in our result variable here and we're going to use it however we wanted the main function but things don't always work like this sometimes the compiler is going to insert optimizations and not really returned by value but returning by value is the default but if the compiler notices that it can do things better it is going to optimize your returns by value to return by reference and you're not going to make a copy but you're going to somehow reuse the local variable in the main function let's look at a simple example to really drive this home we have a function here which is going to add strength it is going to basically concatenate them using the plus operator here and you notice that inside the function here we're going to set up a local variable which is going to store our concatenated string here and we're going to print the address of the local string after that we're going to return the strength so that it is usable by whoever calls this function let's go in main and see how we can use this function here we are setting up a variable called sdr result which is going to store our result strength we are saying add strings here we are calling our function and we are passing in two strings hello and world and we want to concatenate these guys this is going to give us our result and if we print it out we're going to get hello world printed out but the main message here is that the address of the outside string here is going to be the same as the address we have on the inside here and this is going to mean that the compiler has actually done some magic to return the local variable because it has seen that we could really be wasting this guy here inside the function when the function returns this string result here is going to die off but the compiler knows that we can reuse that and avoid the work of copying this string which might be really large suppose this string has a thousand characters inside and copying it would be a waste so the compiler is not going to return by value which is the default it is going to do some kind of return by reference but it's really not a return by reference because this is a local variable we can't really have a reference to a local variable to a function that would be really bad because we might be able to modify it when the variable is actually dead after the function has returned so it is a magic that the compiler is doing to save you from unnecessary copies but you should be aware of this and not make your code rely on returning by value okay now that we know this we're going to head over to visual studio code and actually play with us here we are in our working folder the current project is returning from functions by value we're going to grab our template files pretty quick we're going to copy them let's do that and we're going to put them in the current lecture or project and we're going to open this guy up in visual studio code pretty quick let's do that now we have our main cpp file here we can clean it up a little bit and close the left pane here because we don't need it the first thing we're going to do is to put in our function which is going to compute the sum of two integers and return as the sum of these two guys inside the function we're going to set up a result variable which is going to store the sum and we're going to return it and it is going to be visible to whoever has called this function here again i am going to emphasize that this is going to return by value so what we return is really going to be a copy of this variable here and we're going to prove that by printing the address of this variable inside and outside the function here so we're going to set up two variables in", "59097.52 - 59395.840000000004": "our input parameters x and y we're going to put in a five and the second guy is going to be a y and it's going to store an n9 why not after that we're going to set up a variable which is going to store the results let's call this result why not and we're going to say some x and y okay we are passing these guys by value because we don't really care about copying and and it is a fundamental type it is really small in memory so it's going to be very cheap to copy it's not going to hurt the performance of our application but what we want to do now is to print the address of the reserved variable in the main function here and see that it is the same as the address of the variable we have inside here another thing you should watch out for is that we are able to get data outside the function here the sum was a local variable but we are able to get it out of the function through the return mechanism here okay before we go ahead and run this program we're going to fix the statement here we forgot to change this to say out to mean that it is outside the function here that's the meaning we're going to build with gcc the world is good we can clear and run rooster now we're going to see that inside the function the address of the result variable here ends in dac and outside the function when we hit the end of the function here we're going to see that the address ends in de4 so this proves that the local variable inside the function and the outside variable here in the main function leaving two different memory addresses there are two different variables and the return mechanism here is just going to copy whatever we have in the local variable and make it available on the outside here so that we can assign it to the reserved variable in our main function here this is how the return mechanism is working and it is going to be returning by value by default it is going to be making copies this is the message here now that we know this i want to show you that there are exceptions to that rule if you return by value like this you won't be really always using separate memory addresses for the inside and the outside here and we're going to prove that with a function that is going to add up two strings let's comment what we have out because we don't want this to confuse us so we're going to bring this inside our block comment here and we are going to go below our sum function here and set up a new function which is going to be called add strands it is going to return a string by value okay it is by value because this return type here is not qualified with anything like a pointer or a reference so by default it is going to be by value and inside you see we are doing the exact same thing we did in the sum function here we are adding up two strands we are storing the results in a local variable and we are returning that but if we run this program you're going to see that the address on the inside is going to be the same as the address on the outside so let's set up something that we can play with here we're going to go down in the main function and set up a few variables we're going to say hdd strand we're going to say nstr1 and we're going to store in hello let's do that and we're going to say std strength and str2 and we're going to store and world by now you know what i am trying to do here i am trying to say hello world okay once we have this we're going to set up a resort strike so we're going to say std strength and i say result str and we're going to say add sdr and we're going to add up nstr1 and in str2 this is how we do this and after we do this we're going to print out the address of the variable here so let's do that and it is going to be the address of result hdr let's say that here and we also need to print the actual result of this operation here so let's do that we're going to say sddc out result sdr we're going to print the actual strength i don't think we did that on our sum function here but we can quickly go there and prove that to you so let's comment this out sorry for this this is going to be confusing but i don't want to leave you with unexplained thanks so we're going to see that if we print this out we're going to get the sum which is 14 printed out let's do that pretty quick we're going to go down and say sddcl and say result and we're going", "59395.840000000004 - 59695.276": "it pretty quick with the gcc and if we clear and run the rooster we're going to see the result which is 14 here and you can change these guys up to really play with us for example if we make this 15 and put in a 9 we're going to get a 24 printed out let's build again just to have fun with this and we're going to clear and run rooster we're going to get a 24 here now we can comment this back i am happy i have showed you this and we can uncomment our string code here and uh build and run it so we're going to build with gcc the build is good we can clear and run rooster and again what we want to see is that the compiler is going to optimize this out it is not going to return by value like we had was the sum function where we had the address on the inside different from the address on the outside you see here that inside ah we forgot again to change this guy to out uh sorry for this so we're going to make this guy out and we're going to build again and we're going to clear clear and run rooster now we're going to see that inside the address ends in d30 and outside the address ends in d30 this can be really confusing because we said we want to return by value by not decorating our return type with a pointer or a reference or something like that it is going to be returning by value and if you return by value you're going to make copies and if we made the copies the address on the inside and the address on the outside should be different but they are the same the reason is the compiler is going to notice that you are trying to copy strands and it is going to see that the variable here which is inside the function is going to be wasted when the function returns by default this should be really destroyed and you should copy because you are returning by value but the compiler is going to insert an optimization to do some magic and make it look like you are returning by reference and it is really not going to make a copy so it is going to reuse the address on the inside and hopefully this is going to prove this to you the message here is that you shouldn't rely on your functions returning by value because if the compiler sees that it can do a better job than you it is going to optimize your return by value to return by reference and you're going to not be making copies so don't make your code rely on returning by value and making copies and you should be aware of these optimizations that the compiler can do behind your back i would like to welcome you in this new chapter where we will be learning about function overloading function overloading is a mechanism we have in c plus plus to have multiple copies of the same function but taking different parameters for example here you see that we have different functions but all these functions have the same function name and these are said to be different overloads of the same function there are a couple of rules you need to be aware of to be able to set up your overalls correctly and get them to work and that's what we're going to be learning about in detail in this chapter but now i just want you to see the flexibility you can get with function overloading for example here if we have a few variables in our program we can call the max function and the compiler is going to select the most fitting overloading here so for example if we call our function with integer arguments the compiler is going to choose this overload here if we call a function with std string arguments the compiler is going to choose this overload here and we don't really need to concern ourselves with making sure we have the correct arguments the compiler is going to choose the correct function overload for us and it is going to call it and it's going to be very flexible to call these functions from our c plus plus code this is how function overload can be really useful we are going to stop here in this lecture in the next one we're going to learn about how you can set up function overloads based on different function parameters go ahead and finish up here and meet me there in this lecture we're going to see how we can overload functions based on the parameters that we pass to the function when we are declaring it or defining it and here is a simple example to drive the point home here we have a function called max and this is the name it is taking two parameters which are of type and here and by overloading this function we will have to use the same name as this function here so the differences really will be in the parameters that we pass", "59695.276 - 59995.115999999995": "isn't involved in defining the signature of the function so if we try to set up another function called max here which takes the exact same parameters as our max on top here the difference is only going to be in the return type the compiler is not going to allow us to do this because the return type isn't really significant in making two functions different okay the only way we have to set up a function which is legal in c plus plus is to change something about the parameters that we have here we can change the types like you see here for example we change the types to b double if the types are different we might even change the order of the parameters you just have to make sure the parameter list is different in one way or another that's how you're going to get this function to run with the same names here and if we manage to set up multiple functions with the same name in c plus plus these functions are going to be called overloads of each other okay if we go down here we have another overload for the max function this overload is going to take two parameters and the parameters are going to be of type string view they are different from what we have on top here which is ant so this is a legal overload for this max function here and we can use it okay we really have a few ways we can make our function overloads by now we can change the order of the parameter we can change the number of the parameters or even we can change the types of the parameters again function overloads are a mechanism we have in c plus plus to set up multiple functions with the same name to make our code easier to work with okay now that you know that let's look at a simple example of how we can call our overloads we have a few variables declared here we have ant variables we have double variables and we have std string view variables and if you go down here we are calling our max function passing in integers so the overload that takes integers for this max function is going to be called here down here we are passing in integer literals so this is going to call the int overload down here we are calling the function with double parameters or arguments so this is going to call our double overload for the match function here and down here we are passing in our string view parameters and this is going to call the overload that takes string view parameters and the last guy here is going to take two string literals string literals can implicitly convert to std string view so our std string view overload for the max function here is going to be called now that we know this we're going to head over to visual studio code and play with this a little more okay here we are in our working folder the current project is overloading with different parameters here we're going to grab our template files like we always do we're going to put them in place and we are going to open this guy in visual studio code by dragging and dropping on top of visual studio code here this is going to open our project here we're going to click on our main cpp file and open it we're going to clean it up a little bit and close the left pane here we are going to go on top here and put in our first max function here the return type is and in this case it is going to take two parameters and it is going to return whichever number is the maximum and we are taking parameters in by value and returning by value here nothing special we can go in main and call this function and you already know how to do that i don't think i really need to do that but now what we really are interested in is being able to set up different functions with the same function name like we have here because if for example you take this function and put that down below we're going to make a copy of it and only change the return type if we try to compile this program you see that even visual studio code is unhappy now if we bring up a terminal it is going to tell us cannot overload function distinguished by the return type alone so again the message is super clear here the return type is not enough to make two functions different because the return type isn't involved in making the signature unique what makes the signature unique is either the function name or the parameters that you pass to the function here so we're going to make this return type back a double and we're going to figure out a way to make these two functions different but have the same name here because sometimes you really want this one way we have to do this is to change the types of the parameters that we pass in here so we're going to make them", "59995.115999999995 - 60295.756": "double here and this is going to be valid c plus plus could these two functions are different even if they have the same name here they are two different functions because they take different parameters so if you try to call this function with integers this one is going to be called which takes integers n if you call it with double arguments this guy here is going to be called let's try and prove this so we're going to go inside and say stdc out and overload called i think this is enough and we're going to go in the double function here and say sddc out double overload cool okay once we have this we also have to change the return type here to double because it's going to make things a little bit consistent here but now we want to go in our main function here and set up a few variables we're going to say and x and we're going to make this a four and we're going to say into y and we're going to make this a nine why not we're going to set up also double variables let's say double a and say five point four to make it a double variable and we're going to say double b and put in 7.4 why not now we are going to call max we're going to say auto result and say max and passing x and y what do you think we're going to return here so what we really are interested in is the return type of the result variable here and the compiler is going to deduce whatever is returned by this function if we call the function with x and y x and y are integers so the compiler is going to search for a function that takes integers and it's going to find this guy here and that's what it's going to be called let's weld and run this program we are not interested in looking at the output here we're just going to see this std out statement here print whatever function was called okay we expect the end one to be called so we're going to see ant overload called on the terminal here when we run this program so let's do that we're going to build with gcc like we always do the world is good so we can clear and run rooster we're going to see int overload called okay so this proves that we can set up two functions with the same name and make them different only in the parameters that they take and the differences may be either in the types of the parameter like we are doing here they may also be in the order of the parameters and we're going to see an example of that in a minute but before we do that we also need to try this with a and b and show you that the double one is going to be called because we are passing in double arguments here so let's build again the bullet is good we can clear and run rooster this is going to call our double overload hopefully this really drives the point home that we can set up multiple overloads for the same function name and again the differences are going to be in the parameters that we pass here we have been able to pass different types for the parameters and this was a vehicle c plus plus code but we can also set up another overload just by changing the types and the order of the parameters let's do that we're going to make the first parameter here and and once we do that this is different from any of the overloads we've had so this is a valid overload for this max function here this is going to work we can even change the order of these two guys and it is also going to be a valid overload let's put in another variant of this guy and we're going to change the first parameter to double and the second one to end and now we have four overloads for the max function and again the message here is that you just have to make sure the parameters are different in some way and your overload is going to be valid and again i'm not telling you to set up functions like this because in this case this is really useless but i am trying to expose this facility to you so that you can use it to your advantage if it makes sense for whatever application you are designing here so let's go down and put in meaningful output i think we can come in here and say the parameters that we are passing in here so we can say and double overload called and if we go down here you can take this out and say double and overload called and to get any of these guys to be called we have to pass the parameters or of the arguments in this order so if we pass in an end which is x x is in it and we pass in a double which is a b here this is going to call our overload which takes the first argument to be an integer and the second argument to be double", "60295.756 - 60595.520000000004": "build with the gcc the bolt is good so we can clear and we can run rooster and we see ant double called because x is an end and b is a double if we flip these guys let's say b and x then we're going to have the overload that takes the first argument of double type and the second argument of into type to be called and that's this guy here and we're going to see this message printed out on the terminal here let's build with gcc to really prove this so we're going to do that the bullet is good we can clear and run rooster and the double end overload called hopefully you can really see that you can set up all kinds of crazy overloads for your functions the next thing i want you to see is that we can even change the number of the parameters for example here we can set up another guy here and i call it max it is going to be exactly like the one on top here for the first two parameters but let's add a third parameter maybe make it an end and say c and this is going to be a valid overload for the max function here so we're going to say double and because it takes three parameters i won't go into the details of how we can compute the maximum between these three guys what i really am interested in is showing you that you can set up overloads here so for this case we are just going to return let's just say a this is going to work but this is a valid overload for the match function and it is going to compile so let's draw and do that we're going to pass and a double a net and the net so we're going to pass in b which is a double and x and y let's see what is called here we can compile with gcc the border is good we can clear and please try to come up with what is going to be printed out here what is going to be printed okay now that you have guessed we're going to run and we're going to see double and ant because this is going to call this overload again you can overload based on the differences in the types of the parameters that you pass you can change the order of the parameters like we are doing here double end and end double or you can even change the number of the parameters using these techniques you can make sure that your overloads are different in some way before i close this lecture i'm going to show you that you can also use another overload that takes string view parameters let's go down here and put that in again the name of the function is max the return type isn't really meaningful in making sure two functions are different but watch the parameters we pass here the types are string view and we have a and b here and we are going to compute the maximum so if we go down here and say max and pass n hello and world the compiler is going to try and look for a function that takes two character array parameters it's not going to find it because we don't have that guy in here but it's going to see which function can take something i can come up with through implicit conversions and the compiler is going to see that it can really convert from a string literal to a string view type and it is going to insert an implicit conversion from string literal to string view and this function here is going to be called so we're going to put in a an output statement here we're going to say string view string view overload called and if we try and run this program let's build with gcc make sure that the build is good the world is good so we can clear and run rooster this is going to show string view string view overload called we are able to call this guy here and again the message is that we really have a lot of flexibility in how we can set up overloads for a function in c plus plus and please use this facility at your advantage if this makes things better for whatever application you are designing i would like to welcome you in this new chapter where we're going to be learning about lambda functions lambda functions are a mechanism we have in c plus plus to set up anonymous functions once we have anonymous function set up we can do all kinds of crazy things with them for example we can give them names and code them multiple times or we can even call them directly without even giving them a name i realize this can be really cryptic so we're going to head over to the next lecture and see how we can declare and use our lambda functions go ahead and finish up here and meet me there in this lecture we're going to see how we can declare and use our lambda functions and again lambda functions are a mechanism we have in c plus plus to set up anonymous functions", "60595.520000000004 - 60895.04": "without a name we're going to see how we can set up an anonymous function optionally give it a name and call it or we can even call it directly without giving that a name let's see how we can do that before we talk about anything about lambda functions we're going to first to see the lambda function signature and there is a special syntax you have to follow if you want to set up a lambda function in c plus plus the first thing you have to put in place is angle brackets like this and that's going to be your capture list we are not going to talk anymore about this we're going to have a chance to talk about this in detail after your capture list which is going to leave in this pair of angle brackets you're going to have the parameters to your lambda functions and this is where you can pass arguments if you want to call your lambda function after that you're going to have a return type for your lambda function but you don't have to put this in explicitly you can live this out and the compiler is going to deduce your return type by itself after all these things you have to put in a pair of curly braces and inside these curly braces we're going to have our function body and we can do whatever we want our lambda function to do in this function body here after this you will have to remember to put your semicolon to make whatever statements contain this along the function to be valid and this is the syntax you have to follow here we have a simple example so we have our lambda function we want to say hello to the console this is what we have in the body of the lambda function but notice that we have our capture list which is going to be delimited by these angle brackets we have our parameter list which is going to be empty in this moment because this lambda function doesn't take any parameter and we have our body which is going to leave within these two curly braces and after that we have our semicolon to make this a valid c plus plus statement if we try and put this thing in our c plus plus source code this is going to be a valid lambda function but it isn't really useful by now because we can't call it one way we have to call it is to give it a name and we can give it a name by assigning our lambda function to a variable like we see here once we have our lambda function declared like this this entire thing is going to be our lambda function type we can take this and assign that to a variable which is going to deduce the type using auto type deduction here this is what we are doing once this thing has a name then we can call it with the syntax we have here and if we run this code now it is going to print hello world to the console i realize this syntax can be really cryptic but if you try to remember this you're going to find that lambda functions are really cool and later in the course we will see that they really make a lot of things easier in c plus plus so try to remember the syntax here and everything is going to flow from here again the syntax is to have the capture list which is going to be the first thing the second thing is going to be the parameters the third thing is going to be the return type which is optional you can leave this out and the compiler is going to deduce this and after this you're going to have your pair of curly braces and the body of our lambda function is going to leave within these curly braces this is the syntax you need to remember okay we have seen that we can give a name to our lambda function and call it but it is also possible to call our lambda function directly without giving it a name and we do that by appending a pair of curly braces to the lambda function definition here so we have a lambda function we have our curly braces and we have our parameter list we have our body here and after the closing curly brace we're going to add a pair of parentheses to call this lambda function and because this lambda function takes no parameter we're not going to put any argument within our parenthesis here and this is going to call our lambda function don't worry if you find this confusing we're going to head over to visual studio code in a minute and all of this is going to make sense okay so far we haven't really seen that we can pass parameters to our lambda function here is a simple example that takes parameters this is a lambda function because it follows the syntax for lambda functions we have our capture list we have our parameter list we have our curly braces and the body is going to live inside these guys and we are calling this lambda function directly with this parameter list the lambda function is going to take two parameters of double type we're going to print out the sum of these two numbers and that we are going to call this", "60895.04 - 61195.36": "are passing in our arguments as double literals okay this is how you can set up a lambda function that takes parameters and call it directly another thing we can do is make our lambda function return something and that's really simple we're going to set up the lambda function like this so it's going to take two parameters a and b and here you see that we are returning a plus b and we can do that the lambda function is now going to return something and this entire thing we have here is going to be a lambda expression the lambda function is going to be called it is going to return something and what the lambda function returns is going to be assigned to this result variable here and if we print it we're going to get the sum of whatever pass in here printed out on the console and you're going to see it printed out on the terminal it is also possible to put your lambda function directly in an output statement i realize this can be really confusing but please look at this entire lambda function is same here as a single value because this is a lambda function that is going to return something and what is returned by this lambda function is going to be printed as our result here again i realize this may be confusing to many of you guys we are going to head over to visual studio code in a minute and we're going to see this and you're going to really understand okay the last thing we're going to look at is that we can specify a return type to our lambda function and the syntax to do this is to do a dash a greater than symbol and put your type after that and when you do that now this lambda function is going to be forced to return double type even if you pass it to parameters that are not of double type we are going to add them up and the return type is going to be implicitly converted to double and that's what we're going to return and we can print it out on the console and we're going to see an example of this in a minute when we hit visual studio code in fact this is really all i had to share with you in the slides i realized many of these things may be confusing we are going to head over to visual studio code and play with these things step by step and i am sure you're going to understand here we are in our working directory the current project is declaring and using lambda functions we're going to grab our template files and put them in place let's do that and we're going to grab our folder here and drag and drop it in visual studio code and this is going to open it it is opened here we have our main cpp file opened we can close the left pane here because we don't want it anymore and we can clean up our function here and the first thing we're going to do is to put in the syntax for a lambda function here and use it as a reference as we learn about this i think this is going to make things a little easier so the first thing we want to do is to declare a lambda function and the first thing we need to put in is a capture list a capture list is going to be in globe in this angle bracket so this is our empty capture list and after this we're going to put in a parameter list which is going to leave inside this parenthesis here after that we're going to put in an optional return type for now we're going to ignore this and after that we're going to put in our pair of curly braces and inside this pair of curly braces is where the body of our lambda function is going to leave so inside here we can do whatever we want in the body of this lambda function for example we can say hello world which is the logical thing to do at this point so we're going to say hello world here and we're going to put in our new line character with endl okay now we have a lambda function declared but we have to put in a closing semicolon because this is a c plus plus statement okay now we have our lambda function declared and this is valid c plus plus code if we're trying to compile this program you're going to see that it is going to compile fine cape world finished successfully and if we try to run it it is not going to do a thing because we are declaring the lambda function here but we're not calling it to get it to do things so let's bring up a terminal and show you that if we run this program it is not going to do anything so let's do clear and run rooster you're going to see that it's not going to print anything and we can even go down here and put in a closing stdc out statement saying it done to me that we are hitting the end of the function here without doing anything so if we vote again the vote is going to be good we can clear and we're going to run rooster you see we are printing done we are hitting the end of the function here and are we not seeing hello world so this function here", "61195.36 - 61496.796": "is not being called one way we have to call it is to give it a name and we have seen that to give it a name we have to assign the entire lambda function thing we have here to a variable and we're going to use auto type deduction here so we're going to say auto func and we're going to assign our lambda function here to this variable and this is going to be basically a handle we have in our program here to the lambda function and we can use this handle to do things with the lambda function but by now i want you to see that even if we run the program now it is not going to do anything because we're still not calling the lambda function here let's show you that we're going to world again and the world is going to be good no problem we can clear and run rooster still not hello world because we're not calling our lambda function to call our lambda function we have to use our handle here which is this variable and use regular function called syntax so we can go down here and say func and we can put in our parenthesis we're not putting in any parameter because this lambda here doesn't take any parameters and now if we run this program it is going to say hello world because this line here is going to call this lambda function let's bolt and see that we're going to use gcc to build so now if we clear and run rooster we're going to see hello world we can call this function multiple times because we have a handle to it the handle is going to be valid throughout the scope of the main function here so we're going to go down and call it again and if we build we're going to build with gcc the world is good we can clear and run rooster we're going to say hello world twice because we are calling our lambda function twice this is one way we have to call our lambda function here so we're going to comment this out because we're going to see a few other things and on top here what we were doing is declaring around the function and call it through an a now we're going to go down set up a lambda function and call it directly without giving it a name because that's also a possibility in c plus plus for that we're going to grab our lambda function here and we're going to copy it and we're going to say declare a lambda function and call it direct and the syntax to do that is really simple you set up your lambda function like we have seen before you see this is our lambda function statement here but you're going to go to the closing curly brace and add a pair of parentheses this is going to declare the lambda function and call it directly notice that we don't have a handle to this lambda function so if you do things like this you will have only one chance to call the lambda function so we're going to say hello world once because we are declaring the lambda function and calling it directly here and after that we're going to say done because we're going to be hitting the end of the main function here let's build the program and show you that we're going to build with gcc like we always do we're going to clear and run rooster this is going to say hello world and we're going to be done here because we are calling this lambda function once again notice that now we don't have a handle to this lambda function so we really have one chance to call this and you will do this if you just want to set up some function that you want to call directly and you don't care about calling it ever again in your c plus plus application and we're going to see that we have many kinds of problems where we want to do these kinds of things okay now that you have seen this the next thing i want to show you is how to set up a lambda function that takes parameters and we're going to comment out what we have on top here because we don't want noise output on our terminal and we're going to grab this lambda function and adapt it so let's copy it we're going to go down here and put it in and we want to pass two parameters now let's pass in double parameters we're going to pass in double a and double d you can do that and inside the lambda function we can print the sum of these two variables so we're going to say a plus b for example and we're going to print out whatever is the result of a plus b let's do that and after we do that you're going to see that we get a compiler error because now our lambda function is taking parameters but we are calling that with an empty list of parameters so we need to give it something to sum up let's give it 10.0 for example and a 5.0 and see what we get and after this we need to put in our semicolon because this is a z plus plus statement and any c plus plus statement needs to end with", "61496.796 - 61797.36": "we are doing here we are setting up a lambda function okay it's going to end at this closing curly brace and this lambda function is going to take two parameters of double type and inside the lambda function we are going to print out whatever is the sum of these two parameters that we are taking in here after that we are calling our lambda function with two variables 10.0 and 5.0 or i should say two double literals that's what we are calling our lambda function with and now if the program runs the lambda function is going to be called once and we're going to print out whatever is the sum of these two numbers and that's going to be 15. let's build so we're going to build with gcc the world is good we can clear and run rooster we're going to see a plus b is 15. we are calling a lambda function here if we put in a 50 here for example we're going to get 60 printed out because that's going to be our sum okay let's boil it again and see that print it down if we run rooster we're going to see 60 because that's the sum of 10 and 50 here another thing we can do is actually not call the lambda function directly here we can actually comment this out i don't want to take this out because you might want to use this as a reference so we're going to comment this out and set up another example that is going to name our lambda function and then we will have a handle to the lambda function and we can call it multiple times so let's take out the call we are doing here and we're going to assign our lambda function to a variable we're going to say auto func one we can call this func one no problem and now we can call this lambda function multiple times for example we can say funk one and pass in 10 and 20 okay and we can say funk one and pass in five and seven why not if we run this program it is going to print the sum of 10 and 20 and it is going to print the sum of five and seven and it is going to be calling this lambda function multiple times hopefully you can see that if you want a chance to call your lambda function multiple times you will need to give it a handle like we are doing here and then you can use that handle multiple times and call your lambda function however many times you want so let's build this program and see what we get on the console i'm going to clear and run rooster now we're going to see a plus b it's 30 as a result of this call here and we're going to see a plus b is 12 as a result of this call here notice that we are passing an integer literals so the compiler is going to insert an implicit conversion from and to double because our lambda function here is taking double type you really need to be aware of these implicit conversions and make sure they are working to your advantage if they are working against you trying to find a way to make your code work exactly like you want because we are learning about all these cool tricks in c plus plus you're going to be using them at your advantage okay hopefully now you know how you can set up a lambda function that takes parameters we're going to go down and comment this out because now we want to see how we can return something from a lambda function and we're going to be using the same lambda function here so let's grab it and we're going to say lambda function that returns something and we're going to set up our lambda function here let's put that in place correctly and instead of printing out the sum of a and b we can return that we can go in our lambda function and say return a plus b okay now that we have this we can either call it directly by saying for example 10 and 20 but now if we try and run this code it is not going to do anything try to guess why this lambda function is not printing to the concept directly it is just returning whatever is the sum of 10 and 20. and if we return it we're not doing anything with whatever is returned from this lambda function so we're not going to print anything and we're just going to print done here let's boil and make you see this because you really need to be aware of these little things so the build is good we can clear and run rooster we're going to see down our lambda function is returning something but we're not doing anything with the return value if we want to print the return value we need to catch it somehow and we can put that in a variable for example we can say auto result and assign the return value of our lambda function to this variable now we have a chance to print this for example by doing sddc out result and we're going to print that out and save result now if we", "61797.36 - 62097.04": "whatever is the sum of 10 and 20. let's do that and show you that this is actually the case so world is good so we can clear and run rooster result is 30. if we pass in 10 and 50 for example we're going to get the same thing let's pass in 60 here so we're going to build with gcc the build is good we can clear pretty quick and run rooster now the sum is 70 and this is how you can return stuff from your lambda function and once you return stuff you have to be sure you cut your results and print them out another thing you can do is print out the result directly after you call your lambda function so for example we can grab this entire lambda function thing here and put that in an sddc out statement so we're going to put in a second one here and say result or we can even comment this out we don't want to be confused when we look at the terminology we're going to comment out the first sddc out statement here and we're going to say stdendl here and put in a placeholder for our lambda function and we're going to paste it in if we do something like this again this entire lambda function thing is going to return the sum and that's what we're going to print i realize this syntax is really cryptic but it is going to work let's try and build our program here the world is good so we can clear and run rooster we're going to see that result is 70 and this is coming from our call here which is nested inside our htdc out statement you can do this if you want another thing you can do as we have seen before is give your lambda function a name and call it repeatedly so for example we can try and comment out what we have here and set up another lambda function because we don't want to confuse you again so we're going to grab our lambda function here we're going to copy it because we don't want to type this a thousand times and we don't want to call this lambda function directly instead we want to give it a name and we're going to say aro funk 2 and we're going to assign our lambda function type to func one now that we have this we can say auto result 1 for example and we can say func and we can pass in whatever we want let's put in 23 and a seven and this is going to add up 23 and seven we're going to grab the result and we're going to assign that to result one if we go down and say auto for example result two and say for example funk one and say 9 and 45 why not and go down and print out these result variables we're going to see the sums printed out and again the message is that we can use this handle to call our lambda function multiple times so let's go down and print this out we're going to say result one and we're going to say result one here we're going to go down and say result two and we're going to print that out and we can even call this lambda function directly and put that in sddc out here so let's say that we're going to say result to 3 for example or direct call i think this is descriptive enough so we're going to say func one the name of our lambda function or the handle to the lambda function and we can put in a five and a two for example and we're going to see this print out the result if we build our program let's do that with gcc the bolt is going to be good we can clear and run rooster we're going to have result 1 is 30 which is 23 and 7 so the sum is 30. the second one should say 54 because that's the sum and the third one should say 7 because that's the sum of 5 and 2 and it is what we have here and after that we're going to see that our program is done this is how you can set up a lambda function that returns something and we have seen many ways we can work with us let's comment this out because there is one more thing i want you to see and that's along the function whose return type is specified explicitly okay we are going to reuse the same lambda function we have been using all along and we're going to copy that and we're going to go down and put it down here and now we want to specify the return type as a double the way we do that we go after our parameter list and we put in a dash symbol and we put in a greater than symbol and then we're going to specify the return type of our lambda function let's say that we want our return type to be ant this is how we say it now our function here is going to return end regardless of the types that we put in so what the compiler is going to do when we call this lambda function it is going to take the parameters it is going to add them up for example now they are double so it's going to add a", "62097.04 - 62397.200000000004": "double variable then it is going to convert that to end and return it you notice that now we have forced our lambda function to really return a specific type here before the return type was deduced from the operation that we did here and before we were returning double because that's what the compiler was deducing for a and b here to really drive the point home let's assign this lambda function to func one or func three let's do that we're going to say func three and this is a lambda function that is going to explicitly return and and we're going to set up another one which is going to deduce the return type we're not going to specify the return type explicitly so we're going to take out our return type here let's do that and we're going to go down and say auto result 3 and we're going to say funk 3 and add up two double variables let's set up these variables explicitly so that you really see what is happening so we're going to say it a and put in a 6.9 why not and let's make this guy a double because that's what our function here expects and we're going to do another one do double b and we're going to put in a 3.5 for example and we are going to use this variables as arguments here we're going to say a and b and we're going to say auto result for this should be funk 4 sorry for this and i'm going to say result 4 and this should say result i am making many typos so we're going to assign our lambda function the result of our lambda function i should say to result for here and we're going to pass in a and b now we want to see the types of result 3 and result 4 here we're going to go down and print them out we're going to say sddc out size of this is one way we have to get the types of our variables we're going to pass in result three we're going to say size of result three and we're going to go down and say size of result for okay we have our code in place and what we want to see is the type that is deduced by the func 3 lambda function here we are explicitly turning the return type into end the parameters we pass in are going to be double that's what we have here we are going to add up a and b and the result of this is also going to be double but the compiler is going to notice that we are returning and explicitly here and it is going to take this double result and transform that to end and we're going to get and we're going to get the result of that assigned to func 3 here for the second lambda function here we are going to automatically deduce the return type so what we return here is going to be a double type and we should see a size of it for research 3 here printed out so we should see a 4 on my system and for the second statement here we should see a size of double printed out this is one way we have to try and prove this so let's build this program and see what we get okay the world is good we can clear and run rooster and we're going to see that this is exactly what we expect here if we want we can even print result 3 and result 4 and see what we get so let's do that we are learning so let's experiment with this a little bit we're going to say result 3 and we should go back and say result three if i can type e and dl here and we're going to go down and say sddc out result for okay if we build and run this we're going to see the results printed down the both is good we can clear and run rooster now we have result is 10 for the first thing here for the first lambda function and for the second one result is 10.4 you can see that for the first one the result was transformed from double to and and for the second one we deduced double so we still have our decimal point here hopefully this makes sense and this is really all we set out to do in this lecture showing you different ways you can set up your lambda functions we saw the syntax of setting up a lambda function we saw that you can declare a lambda function and call it through a name like func here we went down and so that you can declare a lambda function and call it directly through the syntax you see here we saw that how we could specify parameters to our lambda function this is the syntax and once you do this you have to remember to call your lambda functions with parameters like we see here we can even use a handle given to our lambda", "62397.200000000004 - 62695.840000000004": "multiple times after that we saw that we could return something from a lambda function and we had many chances to play with us and we finished by looking how we could specify the return type explicitly and the syntax to do that is what you see here we are going to stop here in this lecture the next one we're going to see how we can use our capture lists here and make them do useful things go ahead and finish up here and meet me there in this lecture we're going to see how we can use capture lists in our lambda functions and do some useful things we have seen that the syntax of our lambda functions includes these angle brackets here but we haven't really used them to do anything for what we have done in the last lecture they were empty all the time in this lecture we're going to use them here is a simple example of how we can use our capsule list we have two variables a and b they are of double type and they contain these values 10 and 20. but sometimes we want to use thanks outside the scope of the lambda function inside the lambda function here and if you set up your lambda function with an empty capture list suppose you don't have these two guys in and you try to use a and b like this you're going to get a compiler error because the body of the lambda function doesn't have access to the outer context here it can only use things inside the lambda functions or events that you pass to the lambda function here but it can't directly access things outside the lambda functions and we can have access to thanks that are declared and defined outside the lambda function through our capture list if you look here we are saying a and b and this is the syntax we have to capture these two variables a and b and have access to them inside our lambda function here and this is what capture lists are really for giving you access to things that are declared outside the scope of the lambda function because if you really think about it this lambda function thing we have here is really a type so it is its own thing that has these behaviors well then so that we can call it and do things but it doesn't really have direct access to the outside where it was declared and you have to give it access through the capture mechanism here okay now that you know this we're going to see different ways we can use the capture mechanism one thing we can do is capture by value and if we capture by value what we're going to have inside the lambda function is going to be a copy suppose we have a variable here which is c the value is going to be 42 as you see here we're going to set up a lambda function and capture our c variable by value in this lambda function here and what we're going to do outside the lambda function notice the lambda function has a handle so we can call it we're going to loop five times and at each iteration we're going to call our lambda function and print the inner value here but after that we're going to increment our c variable and this is going to increment the outer variable here and what we want to see is that the changes we are doing on the outside here are picked up by the inner value that we have in our lambda function here and ahead to break it to you this is going to not be the case because what we have inside the lambda function is a copy of the outside variable here so what we're going to have is for the outer value to go from 42 all the way to 47 we're going to go five times incrementing this little guy but the thing on the inside is not going to change because it is a copy the incrementation here is affecting the outside variable here but it is not affecting the copy we have inside our lambda function so for all these loops here we're going to see 42 print it down and we're going to see this in a minute when we hit visual studio code let's say 42 correctly excuse my typing here okay so now you know that we can capture by a value and you know what this really means another thing we can do is capture by reference and the syntax to do that is to add an ampersand symbol in front of the variable that we capture here and if we do this and run the semicolon we run in the last lecture we're going to see now that the changes we do on the outside are going to be picked up by the inner side of our lambda function because we are capturing by reference what we have inside our lambda function here is a true reference to the outside the variable here and we're going to see that now the outside and the inside are going to be incrementing together and", "62695.840000000004 - 62996.4": "like that printed out on the console okay this is really all i have to share with you in this lecture showing you how you can use your capture lists and that you can capture either by value or by reference we're going to head over to visual studio code and play with this a little more okay here we are in our working folder the current project is capture lists we're going to grab our template files pretty quick and we're going to put them in place we're going to put them in the current project and we're going to open this guy in visual studio code by dragging and dropping in place here and we're going to open our main cpp file clean it up a little bit and close the left pane here what we want to do in here is uh learn a little more about capture lists and we're going to put in a piece of code to play with just that we have two variables a and 10 here and we have our lambda function setup and let's take out our capture list so that you can see the compiler error we see if we try to use them as is here so we have our two variables and we have a lambda function set up here and inside the lambda function notice that we are trying to access the variables that have been declared on the outside of the lambda function here and by default if we try to do this we're going to get a compiler error because these two variables don't exist in the scope of the lambda function here let's bring up a terminal and see what visual studio code is saying about this and it is going to say an enclosing function local variable cannot be referenced in lambda body unless it is in the capture list and you see that this is really descriptive okay we have sent this error but we want to see what the compiler says about this we're going to pass this through gcc and we should get a similar error it is going to say a is not captured and it is going to go down here and say b is not captured here and this is the error we are trying to use outside variables in our lambda function but to really do that we need to capture a and b and the syntax to capture our variables is to put them inside our angle brackets here with a comma separate to the list of the variables that we want to capture so we're going to say a comma b because that's what we want to capture here and the moment we do that visual studio code should be happy it is not happy i think we need to compile this for it to be happy so let's do that and you see now our variables are being captured and we are summing them up and we are printing the result of adding them up here by calling the function through a handle we have set up here hopefully this is really making sense let's build the program again so let's use the gcc you're going to see that the world is good we can clear and run rooster we should see a plus b is 30 but the values are getting inside the lambda function through our capture list they are not going through the parameter list here this is really something you need to be aware of now that you know how capture lists work let's see that you can capture either by value or by reference and we're going to see what that means exactly i am going to go down here and put in a piece of code to play with capturing by value okay let's do that we have a variable called c the value is 42 and we set up a lambda function which is going to capture c with this syntax here and this is the default syntax we saw like we did on top here so we are going to be capturing like this and if we do this we're going to be capturing by value the meaning of that is that what we have inside our lambda function is not going to be the original value here it is going to be a copy of what we have there what we can do here is use this thing in a loop and really prove this so we're going to loop five times from zero all the way to four because this is going to go until i is no longer less than 5 and inside we're going to print the outer value which is going to be the c here after that we're going to call our lambda function which is going to predict the inner value in the lambda function and we're going to see that the incrementation we do on the outside which is going to affect the outer value here is going to be visible inside the lambda function here and that's not going to be the case the change we do here is not going to be picked up by the lambda function here because what we have inside is a copy so what we're going to see is for the outer value to go from 42 43 43 45 and it is going to go until we hit the end of this loop here but the inside value is not going", "62996.4 - 63295.435999999994": "here is not going to affect the copy that we have in our lambda function here hopefully this makes sense and again if you have a problem please make sure you ask through the course platform and i will do the best i can to help you out for now we're going to build and run this program you see the world is good so let's clear and run rooster you're going to see outer value is 43 outer value is 43 outer value is 44 outer value is 45 the outer value is changing but the inner value is staying at 42 as you see here hopefully this proves that the outer value and the inner value are two different things but we can even go further and print the addresses of the outer value and the inner value let's do that we're going to add that to our statement here and say the address of this guy so we're going to say address of outer value or say address of inner value we can say it like that to really be descriptive in our terminal here so we're going to say the address of c and on the outer value we're going to add another piece of information and say address of outer value and we're going to say the address of c and this is going to pick up the outer value that we have here and this is going to use the inner value we have in our lambda function here let's try and work and hopefully these two addresses the inner and outer addresses are going to be different that's what we want to see here and really proving that what we have inside the lambda function is a copy through the capture mechanism so let's run the program the world was good so the outer value the address is the e4 the inner value the address is de0 we are proving that what we have inside our lambda function is really a copy so this is how you can capture by value and that's going to make a copy but sometimes you really want to capture by reference and we're going to see how you can do that so we're going to comment out the code to capture by value here we're going to grab the code and reuse it because that's going to be very similar to what we had before we're going to say capture by reference we're going to put in our code and we're going to change it a tiny bit what we're going to do is add an ampersand symbol in front of our variable here that we are capturing and we're going to say ampersand the moment we do this what we have inside the lambda function is no longer a copy it's going to be a true reference to the outer value here and now the changes we do to our outer value are going to be visible inside the lambda function here and you're going to see the addresses to be the same let's build and really see this we're going to use gcc to build our program the world is good we can clear now and run rooster and we're going to see that the outer value let's make sure we have some spaces after these guys and let's go up and do that and both again because things are really cramped together and i don't like this so the boost is good we can clear and run rooster so we're going to see the outer value and the inner value are changing together and the addresses are now the same because we have captured by reference the inner value and the outer value are referencing the same variable we have outside here this is really all we set out to do in this lecture i hope you found it interesting the main idea was the capture mechanism we have with our lambda functions to capture thanks outside the context of lambda functions we can capture by specifying a comma separate to the list of the variables that we want to capture and we have the option to either capture by value by using the variable directly in the capture list like we do here or by prepending an ampersand symbol here and capture by reference and you are going to have to choose whichever way you want to capture your variables now that you know about all these options here we are going to stop here in this lecture in the next one we're going to see how we can capture everything from the outside context to the lambda function go ahead and finish up here and meet me there in the last lecture we saw that we could capture things outside the context of the lambda function now we want to see that we can capture everything living outside the context of the lambda function the syntax to do that is ridiculously simple if you want to capture everything by value you just put an equal sign in your lambda function capture list and if you do something like this now you're going to", "63295.435999999994 - 63595.68": "scope of the lambda function for example we can access the c variable here from the lambda function but if we have any more variables declared outside the scope of the lambda function we will have access to them inside our lambda function here again this is enabled by the syntax that we use here by putting an equal sign inside a lambda function notice that if you use the equal sign like we do here we're going to be capturing by value what we have inside the lambda function is going to be a copy if you don't want to capture all by value you can capture all by reference and again the syntax is really simple all you have to do is put an ampersand symbol inside your capture list the moment you do this you're going to have access to everything outside the context of your lambda function but that's going to be by reference what you have inside the lambda function are going to be true references to the outside variables and you can do pretty nasty things with them because the changes you do inside the lambda function are going to be visible outside the lambda function and any change you do from the outside is also going to be visible inside the lambda function so if you do this make sure this is what you want and you can use this to your advantage okay now that you know this we're going to head over to visual studio code and play with us a little more okay here we are in our working folder the current project is capture all lists we're going to grab our template files pretty quick and we're going to put them in place and we're going to open this little guy in visual studio code let's do that we are going to have our folder open we can open our main cpp file clean it up like we always do and we're going to close the left pane here the first thing we want to do is to capture everything by value and we're going to put in the code to do that which should be very easy to understand by now and again the syntax to capture everything by value is by putting an equal sign within your capture list you have to put that within these angle brackets and that's going to capture everything by value now now if we run the program we're going to see that c has been captured by value if we look around we're going to see that the outer value is going to change but the inner value is going to stay the same this is the same behavior we have seen before by capturing by value so let's build again we're going to build with gcc the world is good we can clear and uh bring up a terminal so that we can clear properly so let's do clear and run rooster now we see that the outer value is changing but the inner value is not changing and again this is classic capturing by value if you want to capture all by reference you're going to use the ampersand symbol here and let's do that we're going to comment this out and we're going to take this out and uh use the code here we can do that we're going to go down and put in a code and say that we are capturing by reference we should say capturing all by reference and all we have to do to make that work by reference is to put our ampersand symbol within this angle brackets here and this is going to capture everything by reference if we run now we're going to see that the changes we do from the outside are going to be visible from the inside here let's weld with gcc and see that this is actually the case the bolt is good as you see here we can clear and run the rooster we're going to see that the outer value is 42 the outer value is changing and the inner value is changing as you see in our output here and this is really how you can capture by reference just to play with this we're going to set up another variable call it d and we're going to say it contains a 5 and we can try to print that inside our inner value here and it is going to work you're going to see that it has been captured we can say sddc out inner value let's say that it is the d variable we are trying to access here and we're going to say d and it is going to be visible inside our lambda function here because it was captured by reference here let's build again we're going to use gcc to do that the bolt is good we can clear and if we run booster we should see d printed out multiple times d d d d and we are able to access it through the capture mechanism and we are capturing everything in the context by reference here this is really all we set out to do in this lecture i hope you found it interesting i hate to say it but this happens to be the last lecture in this chapter on lambda functions we", "63595.68 - 63896.4": "functions but unfortunately we don't really have enough tools to understand that now but for now we're going to stop here and learn a little more things about c plus plus then we're going to come back and see some crazy things you can really do with lambda functions i would like to welcome you in this new chapter where we're going to be learning about function templates function templates are a mechanism we have in c plus to set up blueprint for functions and have one point of control to set up the function but the compiler is going to generate the actual function that gets called when it sees the function call so this is going to solve the problem we had before with function overloads if you look at the code here we have multiple overloads for the maximum function but what we really are doing in the body of these functions is the same and suppose you have 12 or 13 or 20 overloads of the same function you're going to be basically repeating the same logic in the bodies of this function and this code repetition is bad function templates are an effort to solve problems like this the way they work you set up a blueprint for your function and this is the syntax to do something like that you say template type name t here don't worry about this syntax we're going to have a chance to go through it in detail but if you do things like this this is going to be a blueprint for your maximum function and the compiler is going to use this blueprint to generate an actual function when you call this function and this is going to make things super easy i realized some of this is really cryptic so let's head over to the next lecture and let you set up your very first function template go ahead and finish up here and meet me there in this lecture we're going to set up our very first function template and again function templates are a mechanism we have in c plus plus to avoid code repetition for example if you are setting up function overloads if you look here we have our max function and we have multiple overloads for this function we can call it with and double and string view here but if you look inside you see that we really are repeating the same logic and it is even possible to have dozens of overloads if you want to support tons of types for your function and this code repetition is really bad function templates are a mechanism we have in place to avoid things like this and what you do you set up a function blueprint using the syntax you see here and your function template is going to be prefixed with this template type name teeth and here type name t is going to be in this angle brackets and then you're going to put the blueprint for your function t is a placeholder for the types that you use in your function you see that t is in the return type here it's in the parameters that we pass to the function and because it is the same character here all these things have to be of the same type the return type the first parameter the second parameter they have to be of the same type okay so once you have your function template set up like this you're going to implement it like we see down below here it is nothing complicated we just set up the prototype for the function on top and inside we put our implementation you see here we have separated this into function declaration and function definition but inside you see that it is the same logic we had to compute our maximum between these two parameters that we pass to this function so how does this work when the compiler sees you call this max function for example as we are doing here it's going to look at the types that you pass in and in this case a and b are of ant type so it is going to replace the t in here for and and it is going to generate a function initial code and this really brings up a big point about function templates many people think that function templates are actual c plus plus code they're not they're just a blueprint from which the compiler is going to generate the actual function that is called by the compiler for example when you issue a call like this again function templates are not real c plus plus code they are just a blueprint that the compiler uses to generate your function based on the arguments you pass to the function when you call it so when we issue the call like we do here an int version of our maximum function is going to be created so the compiler is basically going to go in and replace n and for t here the return type is going", "63896.4 - 64195.916": "be end the second parameter is going to be empty it's going to go in the definition it's going to do that and we're going to have an it function if we issue a call with c and d like we do here in the second line here then the compiler is going to see that c and d are of double type so it is going to generate another function from this blueprint here and it is going to replace in double then we're going to have another double function if we go to the third line here we're going to do the same we're going to call it with strengths and it is going to generate a stringed version of the maximum function here so what we achieve with function templates is to avoid several overloads for the same function and we have one point of control in our code but the compiler is still going to generate this function overloads but one thing about this is that if a function is not used for example if you never call a maximum function with string then the string version is never going to be created the compiler is going to generate the overloads that you only call in your c plus plus program and this is really all function templates are all about they give you a mechanism to set up a blueprint for your function and then the compiler is going to generate actual functions based on what you call in your c plus plus code okay we have saved this but i want to emphasize this again function templates are just blueprints they're not real c plus plus could and when we hit visual studio code in a minute we're going to see a tool that allows us to see how the compiler instantiates your function templates based on the arguments you call your function with but keep this in mind function templates are not real c plus plus code the rio c plus plus functions get generated by the compiler when you call your function and another thing i wanted to point out is that once a function template instance is generated for example the interversion of our maximum function template then if it is needed again the compiler is not going to generate that again it's going to see if there is one generator already and it is going to reuse that okay this is really all i have to share about function templates at this point in this chapter for now we're going to head over to visual studio code and play with this a little more okay here we are in our working directory the current project is trying out function templates we're going to grab our template project and one thing i should point out here is that our template project has been now updated to have the launch.json file which is going to allow us to debug our programs so you should use a template that includes the launch.json file here that's going to allow us to debug your programs and we're going to do that in a minute when we have set up the example here so we're going to grab our template files and put them in place and we're going to open this little guy in visual studio code by dragging and dropping on top here this is going to do our job then we're going to open up the main cpp file and i think we should close the left pane here we don't need it anymore and we're going to clean this up a little bit so one thing i want to do is to first do things the bad way so we're going to set up a max function let's call this maximum and it's going to take end parameters and we're going to return the maximum between a and b and the way we do that we say a greater than b we are going to use our ternary operator here we're going to put a question mark we're going to return a or b and this is going to be our function but suppose we need another function that works on doubles if we put double arguments in here the compiler is going to insert implicit conversions from double to end this may seem to work but suppose you use a parameter type that is not convertible to end for example you use a string or something let's put in std string here just for an example so we're going to say maximum std strength a and std strength b and we should make these const references because we're not interested in modifying these strings here let's finish the name here and we're going to say const std string reference a this is much better it's going to avoid unnecessary copies of strings and we're going to say const htd string reference be here then inside we're not going to do anything different we're just going to use the same logic okay let's do that suppose you have another function which takes what should i say long long end if we need that we need to copy this function and put that in okay we need to do that and we're going to change this to long long end and we're going to do the same here", "64195.916 - 64495.2": "going to say the same here and you see we are setting up a lot of functions with basically the same thing inside and that this is a lot of code copies suppose we have this function maybe 20 times it is possible or even worse the logic in this function is really long maybe 20 or 30 lines and we will have to repeat this thing in aku so the designers of the c plus plus language saw this problem and they said why don't we set up a one point of control where we can set up our logic to do the maximum and we let the compiler generate actual functions based on the arguments we call our functions with and they came up with function templates and that's what we're going to see so we're going to take out all the other functions and we're going to turn this maximum and function into a function template the syntax to do that is ridiculously easy so we're going to say template this is what you say you put an angle bracket and you say type name and you specify the placeholder for the type in this angle brackets here this is the syntax you have to use then you have to specify your function in terms of this placeholder t it is going to take the place of the type so for example here we want to return and we're going to change this to t and the parameters are going to be taken by value t and t let's do that and now we have a legal c plus plus function template it is going to take this template here and use it to generate actual c plus plus functions so for example if we go in the main function here and say ent result equals max maximum we should say and say x and y for example let's create these variables on top here so we're going to say ent x and we're going to put in a five and we're going to create a y and put in a seven why not now this function is going to store the result and print it out let's do that so that we can see that this actually works so we're going to say result and say results this is going to do and if we build and run this program we're going to use gcc you're going to see that the world is going to be good and uh world finished successfully we can run this program like we always do let's bring up a terminal and clear a little bit and run rooster you're going to see that we're going to see that result now is 7 because that's the maximum you see it is working here so how is this mechanism working here the compiler is basically looking in the main function here and it is noticing the call and it is going to look around and see if it can find a declaration for the maximum function here it's not going to find it because there is none then it's going to look at the function templates it has in here and it's going to see that it can do a replacement and replacing the types that we are passing in here so it is going to do that it is going to take this template and it is going to replace t by end and then it is going to generate a function that basically looks like what we have here we're going to copy this and we're going to put this in the compiler is going to take the first t here it's going to turn that into a net it's going to take the second one here it's going to turn that into an end it's going to take the third one here and turn that into an it and we're going to have a function definition for the call here this is what the compiler is going to do one thing some of you might be thinking is there a way to really prove this and somebody was nice enough to design a tool to let us see this function or template instances generated by the compiler and i happen to have that opened it is a web-based tool so you can use this in your browser just go to cppinsights.io and then we're going to grab the code we had in our main cpp file we're going to copy it all and we're going to go back to our browser and remove whatever i had in here because i don't want this anymore and i'm going to put in my function template if we want we can even take this sddc out statement because we don't want all the junk that comes with that we are just interested in looking at the template instances generated by the compiler now that we have the code in here we're going to see what the compiler generates because of the call we have here i think i could increase the size of the font here so that you guys can see this i think this is a little better then if you hit this play button here let's click on it it's going to do its processing and then the code generated by the compiler is going to show up to the right here you see it has detected", "64495.2 - 64795.116": "called the function template on line 13 here you see this line is highlighted and then if you go to the right we're going to see the functions generated by the compiler so if you go here you see that we have an interversion of our function template and another thing i should prove here is that template instances that are not needed are not going to be generated by the compiler another way to say this the compiler is only going to generate the template instances it needs and again a template instance is what you have here the function the actual function that is callable by the compiler generated from your blueprint so if for example we change the type of our parameters to double let's do that okay so we changed our types to double we're going to hit the play button again you're going to see that now it is going to generate a double function here you see that here if we change this for example to what can we use let's use long long end like we did in our lecture we can do that we can say long long and and if we hit the play button that's what is going to be generated by the compiler so hopefully this proves that the compiler is only going to generate the instances that are needed for the calls you do in your c plus plus program and this is really function templates are all about okay now that you know this let's set up a few more examples to see that this really works so let's change the types of these guys to double let's do that and we're going to play with this a little more in visual studio code and let's use double liters 5.5 and 7 or 78.7 here let's do that 78.7 and we're going to build this and one thing i should point out is that template instances are generated when the compiler is doing its job and then they are going to be put in the binary representation of your source code so the world is good as you see here we can clear and run a rooster we're going to see that the result is 78 and it is transformed to end because we are assigning to end here to really get to the correct results here we should use auto type deduction if we do that the compiler is going to deduce the type of result here based on the return type of this function or the function template instance i should say now we're going to change this to auto to do auto type deduction and if we both again we should see a double printed out correctly the both is good we can clear and run the rooster now we have the correct value printed out from our function template here let's change this to std string we can do that so let's include a the string library and we're going to change these two guys to std string why not std string x is going to be a string electro let's use hello for example and uh for y we're going to say std strength and we're going to put in a world here okay this is going to do and you notice that we don't even have a compiler error visual studio code is not complaining the compiler is going to look at the types we call our function with then it is going to generate is an sdd string version of this function and what it is going to do it's going to replace in t and replace that for std strand we can actually put this thing entirely in cpp inside so let's copy this code before we run it so that you can really see what is happening here we're going to take out whatever we had before we're going to put in our code and then we're going to hit the play button here it's going to generate our thumb we wait for it to do its thing and if you look here you see that it has generated std strength this is really a compiler representation of std string we don't have enough tools to really understand this but hopefully you can see that it has replaced t with some other type we don't know yet std basic string car it has a few things inside that we don't really know yet we will have to learn a few more things about this as we progress in the course but for now i want to prove to you that the compiler is doing the replacement you see t was replaced by this thing here std basic strength and we have angle brackets and this entire thing is really hdd strength in the eyes of the compiler okay now that we know this let's go back to visual studio code and run this we're going to build with gcc as we always do the world is good we can clear and run rooster going to see that the maximum is world and this is going to be using the", "64795.116 - 65095.596": "and this is going to compare two strengths based on this and we know that w here comes after h in lexicographical order so the comparison that is done here is lexicographical for this strength here or i should say it is comparing things in alphabetical order in abcde and things like that okay now hopefully you have a big idea about function templates they are just blueprints you use to generate actual functions and this is going to allow you to avoid multiple function overloads as we have seen before one thing i want you to see is that you have to be sure that the logic you do inside your function is supported by the types that you pass to the function and i'm going to show you what i mean here we're going to set up another function template we're going to say template type named we're going to set up another one pedem and we're going to use t here you can use this however many times you want and then we're going to set up the function which is going to do a multiplication so we're going to say t that's going to be the return value and we're going to say multiply and we're going to multiply two parameters we're going to say t a and t b okay and we're going to put in the logic and we're going to just return a multiplied by b this is our multiplication operator in c plus plus and we can use this function so for example we can say we can comment this out and we can set up two variables we're going to say and x and we're going to put in whatever we had before let's put in five and end to y we're going to say 7 i think this is what we used before you can really put in whatever you want and now we're going to call the multiply function template so what this is going to do is to generate a function template instance which is going to be of type and it's going to do a replacement in here and replace t with ant and then we're going to multiply two end parameters that are passed to this function and we're going to return end and if we do that we're going to get 35 printed out let's prove this we're going to use gcc to bolt the bolt is good we can clear and run rooster we get a 35 if we change this to double it is going to work so let's change this to double and maybe put in five point one and 7.0 why not and then we're going to see what we get we're going to build with gcc the build is good we can clear run rooster we get 35.7 this is what we expect but watch what happens if we try to use the std string types okay i want you to see that so we're going to enable our std strength variables here and if we try to bolt we're going to get a compiler error but i want you to try and guess why why do we have this compiler if we look at what gcc is saying here it is saying an instantiation of our function template required from here and no match for operator multiplication here and this is the problem the compiler is going to do what it knows to do it is going to do a replacement in our function template and it is going to replace t by std strength because that's the type we are using as an argument here the problem is we can't really multiply two strands if you try to multiply two strands like we do here it's not going to make sense what do you expect to get if you multiply two strings it doesn't make sense the compiler doesn't know what to do with this operation it's going to give you a compiler error okay to really drive this home let's go back to cpp insights and put in the code here and see what is generated by the compiler you should use these tools to your advantage because they really help in understanding what is going on so let's hit the play button here i just put in my code and it is going to say compilation failed because we have the same error cpp insights needs to compile the code correctly to give you the template instantiations but here you see that it is basically giving us the same error let's try and see the entire thing here and see if we see the real error and we can't really scroll around with this i'm having trouble scrolling around here i can use these buttons i guess okay so let's see if we see the actual error and we're not seeing it here auto result multiply error generated so we're going to get an error if we try to instantiate our template with the types that we are passing in here which are hdd strength cpp insights isn't really helpful here but hopefully you understand the problem the problem is if the compiler tries to generate a template instance using std strand multiplying two strands isn't", "65095.596 - 65397.116": "going to give you a compiler error because this is not supported so the message here is that you should make sure that the template instances generated by the compilers support whatever operations you are doing in the body of your function template this is the message here another thing i want you to see before we close this off i'm going to take out this problematic line here and we're going to go back to our maximum function what i want you to see is that if you pass different types for this function template you're going to get a compiler error and what do i mean by that let's take out our std strength because it's no longer useful for our purposes here and we're going to just use double and 8 parameters let's use ant here and we make this an intellectual and then we call our maximum function you see that we have a squiggly line because the function template is forced to use the same type for the return type the first parameter and the second parameter here because the placeholder is the same so the compiler is supposed to use the same thing for the first argument here the second argument and the return type that we get from this maximum function here but the problem is we are passing in parameters of different types and this is going to give us a compiler error because the compiler want to know what to do with the types that you pass in as arguments and if we look at our problems tab here visual studio code should give us an error no match for operator uh this is the error we had before we can try and build again we're going to get a compiler error again but this time it's going to be different it's going to say no instance of function template maximum matches the argument list that we are using here which is double and end so this is a problem but we will see ways around this as we progress in the chapter but what you should know is that if we set up a function template like this this is going to enforce for all the types where we will place in t to be the same if they're not the same the compiler won't know how to do its replacement and it is going to give you a compiler error okay the last thing i want you to see is that we can use the debugger to debug function templates so let's turn this back to end because we wanted this to compile so let's take out the decimal point here so that we have proper intellectuals and if we compile again this should compile okay the world is good now what really happens if you try to debug a program with function templates are you going to be working on the template instances because remember the function templates are going to generate function template instances with actual types for example our template instance here is going to have ants because we are passing ant as argument here so how are we exactly going to debug this let's try this we're going to set up a break point here on the call to our maximum function and we're going to start debugging we're going to go to our run tab here and we're going to use the debugging tools that come with gcc we have seen how to do that in the last chapter and we're going to start debugging let's minimize this guy here so that we have some breathing room and we're going to run our debugger let's maximize this a little bit and push this a little to the left and we're going to start debugging and see what really happens here so we hit the green button here we're going to start debugging our code is building now the build is done the binary has been passed to the debugger and now we have hit our break point here so let's minimize this a little bit so that we have an easier way to see this we have hit or break point you see the locals are what we have in the main function which happens to be to the top of the call stack here okay now we want to jump into the maximum function and see the types that we have inside so what we want to do here is head the step into function and you notice it is going to jump into our function template here but the locals here are not giving us the types and this is because this is a function template it's not going to give you the types because it's not easy to get those here but if we look at the call stack you see that we have information about the types of the function that is being called we are calling it a and it b and it is going to return and you see that in the angle brackets here and again this is possibly another way to look at what template instances were generated by the compiler because we see the function called here is taken into parameters and it is going to return end", "65397.116 - 65695.516": "really all we want to see and change the types to double here and we're going to see that the function to the top of the call stack is going to be taking double parameters so let's change this back to five point something 5.5 maybe 7 and 0.9 why not and we're going to print our results here but uh what we really are interested in is seeing the function template instance generated by the compiler because of this call here and we can do this through the debugger this is a little bit convoluted because you have to set up breakpoints and whatever but it is helpful if you don't want to use things like cpp insights as we have seen before and again this is also useful because you will need to debug your code if it is using function templates let's run this to really prove our point here the world is going to go through the binary executable is going to be passed into the debugger and we're going to hit our breakpoint here again you see our locals are not giving us the types here but we cannot use the function call stack to really see this we have hit the breakpoint here at line 15 so we can step into the call and if we hit the body of the maximum function here and look at the call stack we're going to see that the parameters we have in our function call are of double type and again this hopefully proves to us that the compiler has actually generated a double function template instance okay since we are debugging we can actually try and follow this program let's hit next so that we can hit the end of this function we can finish it and hit the main function by the moment we hit the main function results is going to be 7.9 which is what we have here and it is what we're going to print we can just step over this because we don't want to step into the logics of sddc out so step over we're going to print our result and our debugging session is going to basically end because we have hit the end of the main function let's try and use the compiler from microsoft to see the information it gives us because these things can be different depending on the compiler and the debugging tools that you are using we have the luxury to have these two set up here so all we have to do is switch the tool we want to use here and this is going to be using the one from microsoft if you are not on windows or you don't want to use the compiler from microsoft and its debugging tools you can just use gcc and its debugging tools here i just want you to see different ways to do the same things and that compilers and debuggers can give us different information we're going to try and debug with this so we're going to hit the green button here notice that this is going to be using the compiler from microsoft if we look at the world output here you see that we are calling cl.exe it is what we are using to build our binary the binary is going to be passed to the debugger and then we're going to hit the breakpoint here as we know and then we're going to have our output here these are our locals you see in the main function we don't see the types of our locals why is that i don't know why but we see the values here in the main function and if we hit the step into button to jump into our maximum function a is going to have this value b is going to have this value and we look at the template instance we can see the same information but we are using a different compiler this is really how you can debug your code that uses function templates and this is going to give us a peek into the actual template instance that was generated by our compiler this is really all i had to share in this lecture and before i let you go let's summarize a little bit function templates are blueprints we have seen that the compiler is going to use those to generate actual function template instances real function definitions and uh declarations are going to be created when you call the function with arguments if the template parameters are of the same type maybe t and t then the arguments you call the function with must also match otherwise you'll get a compiler error we have seen this okay here we have a point we haven't already covered template instances won't always do what you want a good example is when you call our maximum function with pointers so let's go back and really say this because i want this to cover as much as possible about function templates so let's go back to our code and we're going to modify things a little bit okay so what we're going to do here is take out whatever we have here we're going to set up into variables x and y x is going to be 5 as we have seen before and", "65695.516 - 65996.64": "and then we're going to set up two pointer variables we're going to say endpointer px and we're going to initialize this with the address of x nothing sophisticated so far and we're going to say end p y and we're going to initialize this with the address of y we can do this the problem is going to come when we try to call our function here with the pointers let's use px and py to call this function and py and what this is going to do is to generate a template instance that takes end pointer this is what the compiler knows to do we're going to take the types that we pass in here which happen to be end pointer and we're going to change the return type to end pointer we're going to change the first parameter to end pointer the second parameter to end pointer and we're going to compute the maximum if we compute the maximum here we're going to be comparing pointers okay notice this and if we try to do that we might not get what we want because what we get now depends on the address used to store these guys in memory hopefully you can see that and let's try and debug this program so that you can really see this we're going to use the tools from g plus plus or gcc and we're going to try and debug it let's do that it is going to run through the debugger and what we're going to have is our terminal here i think this is not needed anymore so let's put this to the right here and minimize a little bit and now you notice that px contains an address and py contains an address hopefully you can see that in the body of our template instance we're going to be comparing these addresses because we're comparing what we pass by value here and what we pass are these two addresses so whichever is the maximum in these guys and i think that's going to be dd4 here it is the maximum so whatever is contained in px is going to be considered the maximum let's kill this because we have seen this information so if we have a value in px and that happens to be at a bigger address it's going to be considered the maximum let's see what we print if we run this program we're going to build with gcc let's do that the world is good we can clear and run rooster now you see result is some address because we are returning a pointer and printing that out but we can easily dereference this and get to the value inside this pointer let's build again we can clear and run rooster this is going to give us result is 5 and hopefully you can see that this is really bad and not correct we are trying to compute the maximum between x and y and we are seeing that the maximum is five so how can five beat the maximum between five and seven the problem is we're not comparing the values here we are comparing the addresses stored in these pointers because that's what we are passing here hopefully you can really see this and we can prove this again through our debugger we can run this through the debugger we're going to hit the breakpoint let's minimize this so that we can see our terminal window here and we're going to move this around a little bit and now we have hit our break point if we hit next to jump into the function you see that what we are really comparing are a and b here and a contains a much larger address so it is the pointer that is going to be returned and if we dereference that we're going to be dereferencing the pointer that contains this x value and the message here is that you should be careful that your function templates are really what doing what you want somebody might do this if they are not careful just pass in pointer and expect to get the maximum but the compiler is just going to compare pointer addresses and you're going to get something you probably don't expect okay this is what is meant by template instances won't always do what you want a good example is when you call a maximum function with pointers you're going to get a wrong value possibly there are tools like cpp insights which can show the template in spatial instruments we have seen that and again the arguments passed to a function template must support the operations that you are doing in your function template we have seen an example of this by setting up a multiplication function template and we saw that we had a compiler error if we try to pass std strength arguments because we can't multiply two strings this is really all i had to share in this lecture i apologize it turned out to be lengthy but i really had to put this in one lecture so that i can really show you different sides of the same things we are going to stop here in this lecture and the next one we're going to learn about template type deduction and explicit arguments go ahead and finish up here and meet me there", "65996.64 - 66296.4": "about template type deduction and explicit arguments what we mean by template type deduction is the mechanism the compiler uses to deduce the type it would use to set up our template instance from the arguments that we passed to our function call here for example the compiler is going to look at a and b here in a call to the maximum function and it is going to notice that they are of into type and then it is going to say okay you are calling your function with it types and i see that your function templates takes three replacers in here so i am going to replace these guys with and and it is going to guess that from the call that you make here there's no other mechanism to help the compiler out this is really what template type deduction is about and for the first example here we are passing an end parameter so nt is going to be deduced for the second function call we are passing in double parameter so a double function template instance is going to be generated for the third call here we are using std string parameters so we are going to deduce a template instance that uses hdd string here this is what we mean by template type deduction but we have seen that automatic template type deduction can really have problems especially if you pass parameters of different types for example if we call a maximum function here with a and c which happen to be end and double type then we're going to have a problem because this function template can't handle parameters with different types because the replacer is the same the compiler is going to enforce that all the template arguments are of the same type and the template arguments are going to be what you pass in here so a and b must be the same if they happen to be not the same for example ant and double you're going to get a compiler error now we're going to see that we can use explicit template arguments and again i want to make it very clear the difference between a template parameter and the template argument a template parameter is what you have in your function declaration or a definition so what we have in our function setup here are template parameters ta here and tb are template parameters but what we have when we call a function template is going to be template arguments for example c and d here are template arguments and we're going to be using this terminology in this chapter and many more chapters to come in this course make sure this is super clear so what we're going to look at is using explicit template arguments and what this means is a mechanism through which you can force the compiler to use some type to generate your template instance and the syntax to do this is really simple it is what we have here we say maximum and we put the type we want to use to generate our template instance in angle brackets like we see here so this is going to use double so this is going to explicitly tell the compiler we want the double version called and it's going to generate that and that's what is going to be called by this call we have here a good benefit with this is that now this is going to support template arguments of different types so if we make the call like this the compiler is going to see that uh-huh we are calling with intent double types because a is ant and c is double but it's going to see that you want the double template instance generated now the compiler will have the possibility to do implicit conversions from other types to double and if this implicit conversion fails then we're going to get a compiler error so if you look here for example this is the example for that we are passing in a and e and a is ant and e is an std strength we cannot do an implicit conversion from std strength to double so this is going to give us a compiler error and this is really all template type deduction and explicit arguments are about we can use these things to really make our code easier now that you have this understood we're going to head over to visual studio code and play with this a little more here we are in our working directory the current project is template type deductions and explicit arguments we're going to grab our template files pretty quick and put them in place and after that we're going to open this in visual studio code let's drag and drop on top of visual studio code here this is going to open our folder and we can open our main cpp file and set up our function template let's clean this up a little bit and we're going to", "66296.4 - 66596.72": "this out to just to practice so we're going to say template and we're going to say type name and we're going to say t and if you want you can put this on a single line but i prefer to put this on separate lines but let's show you that so we're going to say t here and we're going to say maximum and we're going to say the parameters they are going to be of type t and we can pass them by value just for now and after this we're going to go in the body of our function template and then we can return whichever parameter is the maximum we're going to say a greater than b here we're going to use our ternary operator and if a is greater we're going to return a if b is greater we're going to return b and this is our function here okay now that this function is set up let's set up a few variables to really play with that so we're going to include the string library because we're going to be using it a little bit and we're going to go down in the main function and put in our few variables we have a through f here a and b are end c and d are of type double and e and f are of type std strand the first thing we can do we can say auto max and we can assign whichever is the maximum between a and b and once we do this we're going to have that maximum stored in max here but what i want you to see is what the compiler does when it sees the code like this the compiler has no other outside help to know the function template instance it should really generate it is going to look at the types we have here a and b it's going to see that they are of type and it's going to see that it can use the function template we have here and it's going to use that and generate a template instance that it's going to take and and it is going to call it to get our maximum here again we can prove this through the debugger we're going to set up a breakpoint we're going to go to our run tab here and we're going to run this through our debugger we're going to build our thing and when we hit the main function you're going to see that a is 10 b is 23 which is what we have here cd we have our values n and std string because it is a compound type or a custom type we can expand on this and really see more information about this but we don't have enough tools to really understand this by now so we're going to just to use this as a wrapper on our stream information here now we want to call the maximum function and see what was generated by the compiler and we can step into this function because we have hit the breakpoint by now so if we hit step into we're going to step into this function and we're going to see that it is an int function instance that was generated this is enough for our purposes if we change our call here to use c and d we're going to generate a double instance so let's do that we're going to generate a double instance and if we print this out we're going to see this printed out but we can use the debugger to really prove this not that we know how to use it we don't have to look through the terminal output window but you can do that if you want you can set up sddc out and print max here you're going to see it printed out so let's run our debugger we're going to see the template instance that was generated through the divider we're going to hit the breakpoint at line 17 here if we step inside we're going to see the local variables for our function here a and b and we're going to have the maximum function to the top of the call stack and you're going to see that it is a double instance for our function template here okay this is what we mean by template type deduction it is the default mechanism that the compiler uses to know which template instance to generate from your function calls but as we have seen in the last lecture this can be problematic one way this can be bad is if you pass different types to the maximum function here let's pass in a and c for example or a and d this is going to work equally well you see that we get a compiler error because the compiler now it says that we are calling with different types but the template parameters here are really of the same type they should be of the same type because t is going to be replaced for a single time so the call we do here is going to fail and if we run this through the compiler again let's do that we're going to use gcc we're going to get a compiler error and it is going to say deduce conflicting types for parameter t and then double so it can't really know which one you want you want ent or double the compiler doesn't know and it is going to give us a compiler error but now we're going to see a mechanism we can use to make this work and that's", "66596.72 - 66896.31999999999": "okay what we can do to do this we can go down and put in our call we're going to say auto and say result or max we can call this however we want we're going to say the name of the function and we're going to specify the template type that we want generated for our function template here so if we do something like this with double inside angle brackets here we're going to be basically telling the compiler please generate a double template instance for this call we are doing here so if we pass in c and d for example this is going to give us what we want and we can print this out if we want so let's say max okay this is going to work if we build let's build with gcc let's use that the build is going to be good because we are passing any double arguments and if we run this we should see our maximum let's bring up a terminal window and a visual studio code here so that we can use that to see things running we're going to clear and run rooster you see that we have our maximum here but using explicit template arguments like we are doing here is going to allow us to even pass different types for our template arguments and for example now we can change the first argument here to ba which is going to be an end and we're going to leave the second one to bd which is of type double now the compiler is going to see that we're going to generate a template instance of type double and it is going to know that it can do implicit conversions for the arguments we pass in here so this is going to work if we pass an argument that is implicitly convertible to the type we passed in the angle brackets here and let's debug this again to show you that we're going to generate a double template instance that is going to be called and give us the maximum that we print here so we can run our debugger by hitting the green run button here let's minimize this so that we can see our terminal window and it is down here let's grab it and put it to the left so that we can really see things printed out as we debug we have hit the breakpoint here and we have our local variables you can look at this if you want it is basically what we have in the main function here but what we want is to step into this maximum function and we're going to see the template instance that was generated you see that it is of a double type here okay hopefully now you can see that even if we passed different values for our template arguments i should say different types because a is of type and and d is of type double but we're not getting a compiler error the compiler is going to insert implicit conversions from whatever arguments we pass here to the explicit template argument that we specified here again the explicit template argument like we are doing here using the syntax with angle brackets and putting in our type is going to tell the compiler please use this type and replace that for t in our function template here and generate a template instance we can call to service this call here and we're going to do implicit conversions basically from and to double because that's what we want then d is going to be of double type we're not going to do any implicit conversion then we're going to call this function we're going to return a double from it because that's our template instance and we're going to print that out here this is what is happening and we can prove that a double instance was generated through our call stack here we see the maximum function is taking in double parameters and it's going to return double as our explicit template argument here this is the syntax that gcc uses is using but we know now that it is a double template instance for a function call here okay if you're not happy with what we are seeing with the debugger you can also use cpp insights to really prove this let's open this up we're going to say cpp insights let's do that and we're going to have it open here okay we're going to erase whatever we have in here and we're going to put in another piece of code we have our maximum function i should say template function or function template and we have alcohol here and it is passing different types a and d remember the last time we did something like this by passing in different types for the template argument this guy failed it couldn't really generate a function template instance because the template parameters we have on top here specify that these guys should be of the same type but now we are able to use", "66896.31999999999 - 67196.4": "have an explicit argument specified let's run this and see the template instance that is generated and you can see that it is of double type we basically replaced every instance of t here with double and this function is going to be called to service the call we are making here okay this is really all we set out to do in this lecture i hope you found it interesting the main message was template type deduction a default mechanism c plus plus uses to know which template instances to generate from your function calls but if the defaults aren't working for you you can use explicit template arguments to specify the template instance you want to generate it we are going to stop here in this lecture in the next one we're going to see how we can pass template parameters by reference go ahead and finish up here and meet me there in this lecture we're going to show you that you can pass your template type parameters by reference and we're going to look at a simple example to really drive this home what we have seen so far is that we can do things like this and specify our t like this and this is going to generate a template instance that passes our arguments by value for example if we pass in double a and double b here for our maximum we're going to generate a template instance which takes double as parameters and returns a double here and this is going to be doing things by value okay this is what i want you to focus on right now it is that this is going to do things by value so if we go in our function here and compute the maximum you're going to see that the addresses we have on the outside are going to be different from the addresses we have on the inside here if we try to print them out but you can also pass your template parameters by reference and the syntax to do that is ridiculously easy you just use this like you would use any reference we say cast t reference here and this is going to just replace in whatever type that you pass when you call the function here for example here we are passing in double arguments so this is going to deduce a double template instance which basically says cost double reference maximum cost double reference a and cost double reference b and this is going to be the function that is called so this is going to really do things by reference and the values we have inside a function template body here are going to be true references to the values we have on the outside if we happen to do any modification inside the body of the function the modification is going to be visible on the outside what we're going to be doing in this lecture is just printing the addresses here and we're going to see that they are the same here on the outside and inside the body of our function template here okay this is what we want to really play with in this lecture but before we head over to visual studio code i want to show you that you can confuse your compiler if you are not careful if you set up these two function templates you see here they are going to be overloads and we can use function overloads with templates but for now we're just going to focus on the parameters that we are passing in here the first one is taken thanks by volume and the second one is taking thanks by reference as we see here and if we issue a call like this we're going to have the same problem we have seen with function overloads before this is not going to know whether you are calling by value or by reference and this is going to cause a compiler error i really want you to be aware of this okay now that you know this we're going to head over to visual studio code and really play with us a little more okay here we are in our working folder the current project is template parameters by reference we're going to grab our template files and put them in place so let's do that and we are going to open this little guy in visual studio code by dragging and dropping here the folder is going to open up we're going to open it and we're going to close the left pane here and clean up our main file here and we are going to put in our function template one thing i want you to see in this lecture is that it is possible to separate these things into function declaration and function definition let's just try and do that here so that you can really see this and then you're going to have to choose what you like a little more so let's grab a function header here and use that as a prototype we're going to put that in front of the main function and that's going to be our declaration and if we go down after the main function here what we have is our definition this could work and this is going to generate template instances for the calls we do in the main function here okay now that we have this we can head in the main function and really play with the function template here we're going to set up two double", "67196.4 - 67499.44": "function for example we say addon result and we're going to call the maximum function and we're going to pass in a and b this is going to do default template type deduction and it is going to generate a double function template instance here but what we really want to prove is that this is going to pass things by value and one way we have to prove this is to bridge the addresses both on the outside and on the inside of the function here you see we are already doing that in our function template body we are going to print the address of a so we can really grab this and we use this stdc out statement and we are going to change it to say out here and we're going to print the address of a let's grab this again and use this after the function call and what we expect to see is some address on the outside so for example we may have something like zero x and a one one one abc which is some hex number here and that's the same thing we're going to have on the outside because the value we have before the function call and the value we have after the function call are going to be leaving at the same address but what we have inside the function body is going to be a copy so it's going to live at some other address for example let's say d a and uh the main point here is that what we have on the outside is going to be different from what we have on the east side and hopefully this is going to prove that we are passing by value so let's print out our maximum here and see the addresses printed out we're going to build with gcc and we're going to build successfully we can bring up a terminal to play with us a little more we can clear and run rooster we're going to see that the address on the outside ends in dd8 and the address on the outside ends with dd8 after the function call but inside you see that we have a different address and this is going to tell us that we are passing by value and what we have inside the body of the function is basically a copy again i don't expect you to see the same addresses as me here because your operating system is going to set up the addresses however it wants the main point here is that the addresses you see on the outside are going to be different from the addresses you see on the inside here and this proves that we are passing by value but what if you don't really want to pass by value and make your function template work by reference well we can do that we can change our function here to do things by reference and all we have to do is use t reference like this okay and when we start using references we really need to be careful and make sure people don't modify things without our knowledge and a good practice is to mark your things as cost references so we're going to do that and we are going to do the same in our function definition so we're going to change this to cost t reference let's do that and let's say cost t reference for the first parameter here and say the same for the second parameter here and this should be it we shouldn't be able to use this reference to modify the data inside the body of the function and our function is a little safer but what the compiler is going to do is really what it's been doing all along it's going to look at the arguments that we pass to the function call here it's going to see that it is double and it's going to do default template type deduction so it's going to generate a double template instance for the function template here and it's going to replace in double and we're going to have const double reference maximum cost double reference a constant double reference b and we can prove this by going into cpp insight i think we can do that so we are here in cpp insights we can take out whatever we had we're going to put in new code here and we can hit the run button to generate our instances and here we have our template instance here generated you see that it is going to generate a double version of our function template here and this is what we have so const double reference maximum and it is going to put in a double explicit argument here but this is business of the compiler what we really care about is that it generated a double template instance for our function template here now if we run this it is going to be passing parameters by reference and what we have on the inside should have the same address as what we have on the outside here so to really drive this home we should change our address to abc to comply with what we have on the outside here we can try and build our program we're going to use the gcc to do that the build is going to be good we're going to clear and if we", "67499.44 - 67795.51199999999": "being the same out d e 0 in d e 0 and out d e 0 and you see now we are passing our parameters by reference and if you want to set up a function template that passes template parameters by reference this is how you can do this and i think we can also try and debug this and see if we can see any more information on how this works we're going to hit our run tab here and we're going to hit the green button to start debugging this program we're going to be using the debugging tools from gcc and we see our local variables here we have hit the breakpoint and we have the main function to the top of the call stack this is what we have here and if we try and step into the maximum function we're going to see that the template instance now is using const double references and this is the template instance that was generated i think this is all we can really see here and let's stop this and show you one last thing what i'm going to show you is that you can't really have the function template that passes by value and the other one passing by reference if you do that you're going to have problems when you issue the call like this because the compiler is going to be confused let's change the second one here to pass by value so we're going to remove the cost reference here i think it's going to do let's do that pretty quick we'll remove the cost and the reference we remove the cost and the reference here and we use this guy as our function prototype in front of the main function here and how can we say that we're going to go on top here and say that okay we're going to put our semicolon and this is going to be our declaration but the moment we do this you see that our compiler is going to be confused because we have two possible candidates for the call here it can either be by value or by reference and if we try to build this program we're going to get a compiler error and it is basically going to be saying what is wrong here so it's going to say call overloaded maximum double ambiguous because we have two candidates again one by reference one by value and this call can be surfaced by both of these candidates here so the compiler is going to give us a compiler error and we have no choice but to use either of these two but we can't have them all in our code and for example if we take out the one by value here and leaving the one by reference so let's comment this out again if we're boiled we're going to bolt you see the world is good and we're going to print our data however we have it in our code we see the addresses are the same and another thing i don't think i really proved to you is that we are passing by const reference here so the template instance that is going to be generated is going to be passing by const double reference because we are passing in double parameters but because of this cost in front of our arguments here we want to be able to modify the data referenced by this name here if we go inside for example and say plus plus a try to modify a in any way through this reference we're going to get a compiler error let's work again and we're going to see that and uh world finished with an error and it is saying increment of read only reference a because we are passing by const reference here so you should really remember this even if we are doing the things in the context of function templates this is really all we set out to do in this lecture showing you that you can set up function templates that take parameters by reference and contrasting this with passing by value and seeing the differences between these two things we're going to stop here in this lecture and the next one we're going to learn about template spatialization go ahead and finish up here and meet me there in this lecture we're going to learn about template specialization and this is a feature we have in c plus plus to bypass the default mechanism of how function templates work in c plus plus okay let's make myself super clear here we have a simple function template we have seen a thousand times by now it is the maximum function and it is going to compute the maximum between a and b here and it is going to return that it is a function template so if we pass in a and b which are of type and we're going to generate a net instance of the template here if we pass in c and d of double time we're going to generate a double instance of the function template here if we pass in hdd string parameters we're going to generate an std string instance of this template here and this is going to basically be comparing the parameters we pass so we're basically", "67795.51199999999 - 68095.76000000001": "return a if a is not greater than b then return b okay that's going to work if what we're doing is what we have here but the moment we pass something like what we have here closed car pointers then we're going to have a problem because we're going to be calling our function template with cost car pointer parameters the default mechanism is going to deduce a template instance that works on cost car pointer arguments here and what we're going to be comparing now are going to be pointers to the string rather than the string data itself and hopefully you can see that this is going to be a problem template specialization is a mechanism we have to tell the compiler for a template function if i pass you this type please don't do the default thing you do of replacing in the argument type for the template parameter instead use the implementation that i am going to give you and you tell that to the compiler using the syntax we have here you put a template keyword here you put an empty pair of angle brackets and then you specify your function the way you want it you see it's going to return a const card pointer the function name is maximum which should be the same as the function template here it's going to be specialized for const car pointer so we specify an explicit template argument here and then we pass our parameters which are also of cost card pointer and when we do this then we can head in the body of the function and do the comparison however we want okay so how do we do this comparison here here is a simple implementation of the function template we just saw on the previous slide you see that it really is the same thing we have the template keyword we have our angle brackets and we have the function header here it's going to return cost car pointer it's going to be called maximum and an explicit template argument is specified within these angle brackets and then we have our parameters what is really important about this function is that it's not going to do the comparison we've been doing all along it's going to use a built-in function and it's a c plus plus standard library which is specialized for comparing c strings okay if we come at cpp reference here and look at a function called htrcmp we have seen this before i guess it is going to compare two null terminated byte strings lexicographically and you see this is really what we want we have two const car pointers one is going to be the first parameter the other is going to be the second parameter we're going to compare them and look at the return value we get from this function we're going to get a negative return value if the first parameter comes before the second parameter in lexicographical order we're going to get a zero if they are equal and we're going to get a positive value if the first parameter comes after the second parameter in lexicographical order so we're going to use this information here and compare our two c strings here and return something in visual studio code okay so this is the function here it's going to be using the logic from hdr cmp and notice what we return we're going to return whichever strength compares the greater to the other so we're going to do strcmp we're going to pass in our two arguments here and we're going to say if this returns something greater than 0 return a because in that case a is greater than b lexicographically this is the comparison we want to do here and otherwise you're going to return b and this is going to compare our strings and not compare pointers directly which is what we are trying to avoid here and you see that template specialization is really helping out here now if we have this n and the compiler sees a call like this it's not going to compare pointers it's going to use the template specialization because the compiler knows that this is a better fit for the call that we are doing here because we are passing cost card pointers this is how template specialization works and it can really come in handy if you are doing things that work with pointers we are going to head over to visual studio code and play with this a little more okay here we are in our working folder the current project is template specialization we're going to grab our template files we're going to put them in place and we're going to open this in visual studio code by dragging and dropping on top of visual studio code here this is going to open our project and we're going to clean it up a little bit and we're going to close the left pane here we don't need it anymore the first thing we're going to do is to put in our function template the same thing we have been doing for a gazillion times by now the maximum function is going to return", "68095.76000000001 - 68396.72": "it is doing this by value after that we're going to head over in the main function and set up a piece of code to really play with us we're going to set up a few variables and we're going to call our functions so we're going to say maximum a and b this is going to return the maximum between a and b the compiler is going to deduce that the template instance should be of ant type so it's going to generate that and call it it's going to give us the return value here we can print it out and see it and we're going to basically do the same for double type and the string types here and you're going to see that this is going to work just fine so let's build this we're going to use gcc to do that the bolt is good we can clear and i bring up a terminal to run this and really see the output here we can clear and run rooster you see max end is 23 because that's what we have here max double 34 and that's what we have here and we called max double to be of int type we should use auto type deduction here to avoid these mistakes because the compiler can do this better than us that's what we're going to do and we're going to deduce max sdr here and we're going to build again let's weld with gcc because that's my favorite compiler i'm going to clear and run rooster now we have correct output we have 23 which is the maximum between a and b we have 34.7 which was deduced to be of type double here and then we have the maximum strength which happens to be world here again when comparing strengths the default is going to compare them lexicographically and what that means the one that comes after the other in alphabetical order is going to be greater by that logic world is greater than hello and it is what we are seeing printed out here okay this is working just fine but what if we use cost card pointers and try to call our maximum function template and by that i mean doing something like this we have two variables g and h which are of type cost card pointers so they are c strings they are going to be now terminated because we are initializing them with a string electron and we are comparing them here we are saying maximum g and h and we're going to print whichever is the maximum after we return that from the function when the compiler sees the call like this it's going to do what it knows to do it's going to replace an scar pointer in our function template here so it's going to return cost card pointer it's going to pass the parameters as coast guard pointers and we're going to be comparing these pointers here and we're going to return whichever pointer is greater again here you must be noticing the problem we're going to return whichever pointer is greater and we're not going to be returning the actual string data we're going to be returning just the address and this can be really wrong because if the addresses happen to be messed up we're going to get the wrong output so let's try and prove this again for that i am going to comment out what we had on top here because this could mess things up a little bit so i'm going to comment all this now and i am going to debug this so we're going to look at this line here and i think we should say cos car pointer result and i say equals max c mom g and h and i printed the result here this is going to make it easier to step into this function without the noise from stdc out here so we're going to set up our breakpoint here we're going to hit our run tab and we're going to debug this program and we're going to hit this breakpoint here let's see the types that we have inside our function call so now that we are here we're going to see that our locals are g and h and they contain our strength if we go inside we're going to see that g is really a pointer to the first element in our string here and it contains w here which is what we have here and h is going to be a pointer to a that's what we have here okay and result is going to contain some junk data because it's not initialized yet but we can step into this function and see things happening a again is an address and b is an address you see that the debugger is really smart it's noticing that this is a pointer to a strength and it's going to show us the string here but what we compare are these two addresses and you see that b lives in a larger address it leaves at address that ends in 55 and a lives at the address that ends in 50. so if we really execute this function we're going to return the pointer to b but you see that b is not really the greater string and this is really something bad you", "68396.72 - 68695.92": "compiler is doing by default and it is going to give us a result that is not correct let's close this and see a way we can solve this problem and we can use template specialization for this what we really need is a way to compare c strings and not compare pointers like we are doing here we're going to do that using a template specialization and the syntax for this to work you say template and you specify an empty pair of angle brackets and then you specify whatever function you want to use so we're going to go down here and specify that we want to return the cost card pointer the function is going to be called maximum we're going to specify an explicit template argument which is of const car pointer because we want this template instance to work for scar pointers so once we have this end we're going to specify our parameters we're going to say cos car pointer a and cost car pointer b and we're going to head into the body of our function template here now we have our two parameters and we're going to compare them as if they were const color strengths and we have seen that we have a built-in facility from the c plus plus standard library it is this htr cmp function we can use it to compare two strengths and we're going to use the logic that we have here so if the first parameter is less than the second parameter i am talking in a lexicographical order we're going to return something negative if they are equal dexicographically we're going to return zero and if the first parameter is greater than the second parameter lexicographically we're going to return a positive value so let's transform this logic into a ternary operator we're going to say return sdd str cmp we can say that and if you have access to this function we're going to need to include c string let's do that we're going to include the c string library and now we can say this and we're going to pass in a and b and we're going to ask ourselves is this greater than zero okay if it's greater than zero then if the first parameter is greater than the second parameter let's see graphically so we're going to return a if it's not the case we're going to return b this is our ternary operator here and it is going to work now that we have this n the compiler is going to know we have a template specialization for a const car pointer if we call the function like we did here calling the maximum function the compiler is not going to use this function template we have on top here it's going to see that this template specialization is better for the cost card pointer type that we are passing here and now if we try to build and run the program the boat is going to be good if we clear and run rooster we're going to see that now the maximum is wild let's see what we see if we don't have this specialization and we're going to comment this out because i don't think i really showed you we're going to build again and again if we do this this function template is going to be used and you know that it is going to deduce a function that compares pointers directly and that's going to be really bad we can build this with gcc and really see what we get as output we can clear and run rooster now you see that we are saying animal is the maximum between these two guys but that's not true animal is less than wild in lexicographical order we need a way to really compare c strings properly and our template specialization is really doing that using the htd crmp function and it is working pretty well this is really all template specialization is all about you're going to do this if the default function template you have is really not working according to your needs for the type that you want to use for this and use this to your advantage because it's available to you and now you know how to use this the syntax is really simple you say template and you say angle brackets and then you specify whichever implementation you want for your specific type for example here our specific type for which we want to specify this function template is cost card you specify that as an explicit template argument and then you specify your return value your parameters and you do whatever logic you need to do to do things right in the body of this template specialization here i would like to welcome you in this new chapter where we're going to be learning about concepts concepts are a mechanism we can use to set up constraints or restrictions on the template parameters in our function templates for example we can use this technique to say that we want our function to be only called with", "68695.92 - 68996.8": "something that isn't an integer it's going to give you a compiler one thing i should emphasize is that concepts are one of the big four features in c plus plus 20. so we're going to be learning about this in this chapter we have just said that we use them to place constraints on our template parameters but we saw that we could do something like that in the last chapter where we could use type trades and static concerns for example if you look at the function here it's going to print a number but we have a requirement for this number to be an integral type through the static assert that we have here we're going to see that we can do something really similar with concepts but it's going to be much cleaner and that the logic to enforce our constraints is not going to be in the function body it's going to be somewhat in the function declaration in the constraints that we put on the template parameter here we're going to see specific syntaxes of how you can do this starting in the next lecture there are two sides to concepts in c plus plus there are standard built-in concepts that come with the c plus plus programming language but if for some reason these happen not to be enough you can build your own and we're going to see how we can do that later in this chapter here are a few examples of concepts you can use in your c plus plus program you can use the integral concepts to enforce that your parameters be integrals you can use the floating point concept to enforce that your template parameters be of floating point type you can do all kinds of crazy things okay concepts are really cool and they are going to make your function templates much safer to work with we are going to stop here in this lecture and show you how you can use concepts starting in the next lecture go ahead and finish up here and meet me there in this lecture we're going to learn about concepts again concepts are a mechanism we have in place in c plus 20 to place constraints on our function templates for example we can use concepts to specify that we want our function template to only be called with integers or doubles or strings or whatever and when somebody violates our concept they're going to get a compiler error in this lecture i am going to show you how you can set up your concept and the different syntaxes you can use and how we can understand them but before we do that please note that there are two sides to concepts there are concepts that are standard and built into the c plus plus standard library and those are ready to use and these are what we're going to be using in this lecture but know that you can also build your own concepts and use them to do whatever it is you want to do here are a few examples of built-in concepts we can use from the c plus plus standard library we have for example a concept we can use to enforce that people call our functions only with integral types if they violate this they're going to get a compiler error we can also enforce for our template parameters to be floating point we can do all kinds of crazy things okay now that you know this let's see how we can set up a concept on our function templates and this is the first syntax we're going to look at all you really have to do is to put in your template declaration like we have been doing all along you also have to add in the requires keyword here after the requires keyword you're going to specify your concept and specify your template parameter in angle brackets here when you have this thing in front of your function template like we have here the function template can only work right if the concept in here is satisfied and this concept in this case is going to be satisfied if somebody tries to call this function template only with integral types if they violate that again they are going to get a compiler error okay once we have this concept set up we can look at the piece of code that tries to use it and try to guess what is going to happen here is a piece of code we would set up in the main function and try to call a function template we have two variables of car type we know that car is an integral type so if we issue a call like this this call is going to work the template instance is going to be generated and it's going to be called and give us the results that we can print here this is right on the second piece of code here we have two variables of type and we're going to call them we're going to call our function template with and and this is also an integral type int is an integral type so this is going to generate our function template instance and we're going to call it and get the", "68996.8 - 69297.76000000001": "to call our function template with double types the concept is not going to be satisfied and we're going to get some kind of error and our function template instance is not going to be generated this is really how you can use concepts to force some rules on users of your function templates if i can say it like that we have been able to do something like this using typed traits and the static asserts in the last chapter but concepts are much cleaner and that they are kind of built into the signature of your function you don't have to go in the body of your function and set up static asserts the function is already supporting concepts when you declare and define it and this is really cool okay this is our first syntax we can use to set up concepts for our function templates using the requires close after our template declaration and following that with whatever concept we want to enforce on our function template here please note that you can also use type traits directly in the required clause here and this is going to work and this really says that all you really have to put after the requires close is an expression that can be evaluated at compile time but also results in a boolean value once you satisfy these few requirements you can really set up your concept however you want you just have to be careful that the expiration can be evaluated at compile time and that it evaluates to a boolean value and when the expression evaluates to true the concept is going to succeed if the expression evaluates to false you're going to get a compiler error because the concept is not satisfied this is how these things work now that we have seen the first syntax i think it is big time we looked at the second way you can set up concepts and that's going to be in your template declaration you're going to say template put in your angle brackets and inside instead of saying type name t like we have been doing all along you just specify your concept directly and save the template parameter like this once you do this this concept is going to be enforced on this function template here this is just another syntax to really do the same thing we also have a third syntax we can use if we use auto to set up our function templates and the way this works is to just add your concept in front of the auto keyword and once you do this the compiler is going to enforce for the first parameter and the second parameter to this function to satisfy the integral concepts so if you have to use auto to set up function templates this is how you can use concepts to constrain ways in which people use your function we still have another way we can use concepts in c plus plus and this is how you do it you specify your template declaration like we have been doing all along you specify your function template but after the parameter list as we see here you're going to put your requires close and you can put that in this place here and it is going to work i realize these are many syntaxes to process for the first time but some of these syntaxes are going to work better in some situations and they are there just to make it flexible for you to use concepts in your c plus plus code okay now that we have seen different ways we can set up concepts for our function templates i think this big time we headed over to visual studio code and tried them out okay here we are in our working folder the current chapter is concepts the current lecture is using concepts we're going to grab our template files we are going to put them in place and we are going to open this thing in visual studio code by dragging and dropping on top of visual studio code here we do that this is going to open our folder we're going to open up our main cpp file and close the sidebar here and we're going to clean things up a little bit and we're going to set up a function template which is going to add two numbers we already know how to do that so we're going to say template type name and it's going to have a template parameter of t then we're going to set up the function like we have been doing all along we're going to say add we're going to say t a and t b and this is going to return the sum of a and b once you have the function in we can go in the main function and set up code that would call this function and if we try to compile this program it is going to work now because we are not placing any constraints on this function template here let's try to build with gcc like we have been doing all along you see it is going to weld okay you see the world is good world finished successfully and if we want we can run this application and", "69297.76000000001 - 69597.83200000001": "result b let's take this out because we haven't done this yet but it's not going to print result c but if we want we can really print it it's going to work so let's put that in and we're going to say result c and print result c here and world again let's world now to take this into account world is good we can bring up a terminal to try this out and we can clear and run rooster now you see result a is 30 because that's the sum of a and b here result b should be 16 which is what we have result c is 13 which is what we should get by adding these two double variables now we wanted to constrain this function to only work if somebody passes integral types and when we put that constraint in place it is going to work if we add up two character variables because they are integral types it's going to work if we add up two integer variables because they are integral types but once we hit this guy here with the double variables we should get a compiler error because the constraint is not satisfied let's do that we're going to comment the double thing first because we want to really isolate it and see it and see the compiler error that we get and we're going to add a constraint to our function template using concepts okay if you want to use concepts in c plus plus 20 the first thing you need to do is to include the library that gives us access to concepts and we're going to do that by saying include concepts this is easy now that we have this end we're going to use the first syntax we saw in the slides and we're going to add the requires close after the template declaration and we're going to say std integral and we're going to say the template parameter here i think this is the syntax okay watch what happens if we do this down in the code we are calling the function with car types and integer types so this is going to compile fine because the concept here is satisfied this concept is going to enforce for the template parameters we call a function template with to be integral types let's build and see if we get to compile successfully you see both finished good everything is going to work and if we run our program we should see results a and result to be printed out let's run the program we see our result here now we're going to comment out the others and leave in the double example and we're going to uncomment that and i want you to see the problem we get when we try to use our function template with double variables here you see visual studio code is already complaining it is saying there is something wrong if we look at the problems tab is going to say no instance of function template add matches the argument list but this is really not descriptive enough but the problem is our concept is not satisfied by calling our function template with double types because we clearly said that we want the function to only be called with integral types let's build our program we're going to pass this through gcc and we're going to get a compiler error that says that some concept was unsatisfied and we see we see in function main use of function t add with double with unsatisfied constraints and this is really clear when we see an error like this we will go and look at the constraints that the function has and we're going to see if we satisfied those constraints by calling like we did in the main function here and we will know that the function doesn't support non-integral types and we will fix this problem this is really how concepts can help in writing safer function templates now that we have seen the first syntax i think it is big time we looked at the other syntaxes so let's do that let's copy the code here because we're going to be reusing this a couple of times and adapt it instead of typing this entire thing the second syntax involves getting rid of the requires close all together and just using the concept instead of type name here so i'm going to say std integral and this is going to be enough this is going to tell the compiler to enforce this concept for this function call for all the template parameters that go in the place of t here i hope this makes sense now if we go back we see that we still have our squiggly lines here if we try to compile we will get the same compiler error okay and you see we have the same compiler error function add t called with unsatisfied constraints i think if you go down we're going to see", "69597.83200000001 - 69896.55200000001": "to say required the satisfaction of std integral with t but now we are trying to call this with double so this is really going to lead to a compiler error so this is the second syntax and it is going to do the same thing now that we have seen this we also have a third way we can do this and that's through the auto mechanism let's set up a function using auto so we're going to say auto add auto a and auto b we have seen that we can do that in the last chapter and we're going to return a and b a plus b i should say if we do this you see that the squiggly line goes away and we can add these things up and print the result the return type is going to be deduced by the compiler automatically but know that this is going to generate a function template behind the scenes this is just a nicer syntax we have to use auto to set up functions that work for multiple types let's build and uh see how gcc handles this the world is good because we have no constraints here and if we run our program it's going to work it's going to give us 13 as the sum of 11.1 and 1.9 but we can also place constraints on this function here and you do that by specifying your concept in front of the auto keyword here so for example we can say std integral and std integral fold the second parameter here let's say that and once we do this if we go down we should see our squiggly line on the call of the function here because now the way we are calling this function is not valid the function clearly says that it wants to be called only with arguments that satisfy this concept here if we're trying to build again with gcc we're going to get the semicompiler error let's do that and it's going to say use function with unsatisfied constraints the same error and if we go down we should see that it requires the integral concept to be satisfied here so this is the third syntax you can use if you happen to be using the auto syntax for your function templates let's comment this out because we still have another syntax we need to learn about this is going to be our syntax three and we're going to comment this out and the last one involves just leaving in our function template let's copy this because i don't want to type this again we're going to go down and say syntax form and put in our function template we're going to take this requires close we're going to cut it out and we're going to put it after the function parameter list like this and this is going to be valid c syntax to enforce a concept on your function template if we go down you see we have this wiggly line and i should prove that this works with other integral types here let's just comment out the double line here and uncomment the other we had for car and ant if we try to build this program now it is going to work fine because the constraints are satisfied but the moment we uncomment the calls with double types we're going to get a squiggly line which is a good warning that we have a problem but if we ignore the squiggly lines and adjust build with gcc we're going to get the same compiler error and it's going to say that to call our function we need to satisfy the integral concept for the arguments that we pass here and the double arguments we're passing in here are violating our concept so we get a compiler error this is really how you can use concepts in c plus plus i tried and came up with simple examples to show you different syntaxes you can use concepts with and this is really it try to get yourself familiar with these syntaxes and it's not going to be really hard to use concepts in your c plus plus programs okay this is really all i had to share in terms of the syntaxes you can use with c plus plus 20 concepts if you go to the documentation you're going to have more information about this but we're going to do a few more lectures to really drive this dancehall for now you can come to cpp reference here and see more concepts that you can use we have a lot of this and we can really use this to tune our function templates however we want okay for example you see our integral concepts you see a floating point concepts and there are even more that are usable with classes but we haven't learned about classes yet and we will do that starting at the next chapter but now i just want you to be familiar with concepts that were introduced in c plus plus 20. and here is another piece of documentation", "69896.55200000001 - 70196.552": "we are talking about in this chapter but i wouldn't recommend reading this just yet because it's just going to confuse you there is a lot of things we still need to learn to really be able to understand this so try to go through this chapter and i am going to try and break this down in ways that you can understand this the main message is that there are more concepts here you can try in your c plus plus code if it makes sense for the problem you are trying to solve with c plus plus we are going to stop here in this lecture in the next one we're going to show you how you can set up your own concepts in c plus plus go ahead and finish up here and meet me there in this lecture we're going to see how you can build your own concepts and this is going to bring us into the second part of concepts we can use in c plus plus in the last lecture we used the concepts from the standard library that are built into the c plus plus programming language starting in c plus plus 20. in this one we're going to be building our own concepts and without waiting anymore let's see how you can do that and this is the syntax you can use to do that and it is really simple the way you do that you say a template declaration specifying the template parameter you want to constrain and then you say concept you say the keyword concept you give your concept a name you put the equal sign after that and then you're going to specify the requirements for your concept so for example here we are using a type trait to specify that this type trait is going to determine what works for this concept here and what this is going to do is to enforce for our template parameter to only be integral if it's not integral we're going to get a compiler error and one thing i should tell you is that the std integral concept is exactly built like this in the c plus plus standard library this is really cool so if you want to set up your own concept and you want to do that using typed traits you can do that like this and it is going to enforce for your template parameters to satisfy that typed rate or to be exact this concept is going to be satisfied when the type trait evaluates to true if the typed rate evaluates to false at compile time the concept is not going to be satisfied that's another way to look at that down here we have another syntax we can use if we have multiple statements in our concept all you have to do is specify the concept keyword you give it a name you go to the equal sign and then you add a requires close the requires close is going to specify the template parameters for which you want to enforce your concept and then you're going to put a pair of curly braces and inside that you're going to specify the syntax you want your concept to satisfy for example here we want for the two parameters to be supporting the multiplication operator if this multiplication operator is not supported for the template parameters that we passed the concept is going to fail and again i should emphasize that this doesn't check for the value of a multiplied by b it's just going to enforce from the syntax to be supported so for example if you call a function template with this concept and you try to pass in integers it's going to work because you can multiply integers but if you pass two strings this is going to fail because it doesn't really make sense to multiply strings okay this is the syntax now we only have one statement to enforce inside but if you want you can even put more statements if you go down here we have another example called incrementable this is going to require for the template parameter to be incrementable we specify the concept key world we say the concept name we put in our equal sign and then we say requires we put on template parameter and put in our requirements for any template parameter that is using this concept the syntax here must make sense so you must be able to take the value that you get from here and for example say i plus equals one this is going to be valid syntax you're going to say plus plus a and plus plus b all these are going to be valid c plus plus syntaxes for the template parameter that you try to call this function template with and if this doesn't work you're going to get a compiler error because your template argument isn't really satisfying this concept so this is really how you can set up your own concepts in c plus plus once you have your own concepts set up you can use them like we have been using the other concept from the ziploc plus standard library for example we can use syntax one to put a requires clues and", "70196.552 - 70496.4": "concept with this particular syntax you will have to put in these angle brackets and put your template parameter inside this is the syntax you have to use you can also use syntax 2 and specify my integral directly in this angle brackets in your template declaration and this is also going to work we can even use this with the auto syntax for our function templates it is going to work okay now that you have sent this i think it is time we headed over to visual studio code and play with us a little more okay here we are in our working folder the current project is building your own concepts we're going to grab our template files like we always do and we're going to put them in place and we're going to open this thing in visual studio code let's do that we have our project open here or folder i should say we're going to clean this up a little bit and we're going to include our concepts library and we wanted to set up our own concept the first syntax we're going to see is by using type trades and we're going to say template type name t and we're going to say this concept we want this template parameter to satisfy we're going to say concept and we're going to say my integral which is going to be the name of our concept we're going to put an ecosign and then we're going to say std integral v and specify that we want this type trait to be satisfied for this concept here and after this we need to put in our semicolon and i think we need to include the type traits library because we are using that we should say std is integral so sorry for this and this is going to work now okay now that we have the concept set up we can use it like we have been using other concept for example we can set up a function which is going to add up two numbers and it is going to use this concept here we have multiple syntaxes we can use so let's go down and try this out we're going to say template and say type name t and we're going to require this concept to be satisfied for our function template we saw that we could use the requires close here and say my integral and say the template parameter we want to enforce this on and after this we're going to just put in our function template we're going to say add what we have been doing all along in the last lecture we're going to say t a and t b and we're going to return a plus b now this function is going to support our concept let's go down and set up two variables we're going to say and x and we're going to say 6 for example and into y and i'm going to make this a 7 why not and we're going to say add x and y once we do this you see that we have no problem because the concept is satisfied for the arguments that we are passing in here the concept is satisfied because the type trait here is going to return true for this type here because it is an integral type when the type trait returns true then the concept is going to be satisfied if the type trait returns false the concept is going to fail let's try and bolt and really drive this home you see that the world is good our function is working so the function template and stands for this code here is going to be successfully generated and we're going to call it when the program runs now let's change the type of these guys to double and try to violate our concept and make it fail once we do this you see the call here has a squiggly line and a visual studio code is not going to say that it is a concept problem which is a shame but we can still run this through the compiler and the compiler is going to tell us what is wrong so it's going to say use of function add with unsatisfied constraints and if we go down we're going to see the exact constraints we violated and we're going to say required for the satisfaction of my integral with t we are calling this with double and double is going to evaluate this to false hopefully you can see that you can really set up your own concepts using the syntax here and we can use our concept with all the syntaxes we have seen in the last lecture so for example we can take out the requires close all together here and say my integral in the template declaration here so we're going to say my integral and if we do this we're going to fail again because the concept is not going to be satisfied we're going to have the same problem we can change the syntax to use the auto syntax but before we do that let's change this back to type name t and then put our requires close after the parameter list of our function template we're going to say requires and we're going to say my integral and specify the template parameter and this", "70496.4 - 70796.0": "concept applied to app and if we both again we're going to get the same compiler error so you see the same error and we can use the auto syntax let's do that we're going to take out the template declaration here we're going to take out the requires close here and we're going to change our t to auto and the way we do that we're going to say std no no std we are using our own concept so we're going to say my integral auto this is going to work and we're going to say my integral auto and my integral auto here the moment we do this you see that we have squiggly lines here because our concept is violated but if we're trying to build again we're going to use gcc to do that the build is going to fail you see that the same concept is violated and we are able to use our concept throughout the four syntaxes that we saw in the last lecture and this is really cool now that we have this we're going to comment this out and we're going to see that we can set up concepts that have requirements spanning multiple statements or multiple lines okay let's go down and do that suppose we want to set up a concept that is going to enforce for the templates parameters to be multipliable with the multiplication operator we have here we can use this syntax here we're going to put in our template declaration we're going to say concept we're going to say the concept name we're going to put in an equal sign and then we're going to put in a requires close with our template parameters and and after that we're going to put a pair of curly braces and inside the curlies we're going to put the requirements for example in this case we require for the template parameter here to support the multiplication operator between two of these types if the multiplication operator is not supported we're going to have a problem and that this is the concept that is going to enforce that one thing you should know is that this is just going to check that multiplying a and b is valid syntax it's not going to check the value of a multiplied by b and you should really understand this now that we have this n we can set up a function to use these two guys why not use the function we have seen before to add two numbers let's do that and we're going to put in our requires close and we're going to require now to support the multipliable concept and we're going to specify our template parameter we have the concept n so we can use that to do whatever we want now we're going to say t add and we're going to say t a and t b and we're going to return a plus b this is the same function we've been using all along okay now we have our concept in place and we have a function template that is going to use this concept let's see if we can add up x and y and see what we get we're going to world with gcc we're going to see that the world is going to be good because our concept here is satisfied we are passing double types for our function template and it is legal to multiply two double variables if we multiply two doubles we're going to get a value and that's going to be valid c plus plus syntax but let's see what happens if we try to change our arguments to hdd strength let's do that so we're going to say x is hello and we're going to say why is world why not let's go down and put in a semicolon and the moment we do that you see that we have a problem and visual studio code is not good at this yet but if we go inside and run this through gcc we're going to get that our concept is violated let's look at the compiler error here it's going to say constraints not satisfied and it's going to tell us that we are calling the add function with the values that can't be multiplied it's going to say the required expression here is invalid and this is how you can set up a concept like this and you can really use this to put constraints however you want on your function templates but here we have just used one statement inside our concept here we can even put in more so to drive this home we're going to set up another concept let's go down and put that in place the concept is going to be called incremental it's going to be using the same syntax we saw here but we're going to be putting a requirement on the template parameter here to support incrementation and we want for every type that goes in the place of t here we must be able to say a plus equals one this must be valid c plus plus syntax we must be able to say plus plus a this must be valid c plus plus syntax and we must be able to say a plus plus this must be valid c plus plus syntax", "70796.0 - 71095.92": "add function to use this concept why not we're going to say incrementable and now this function is going to be required to use things that we can increment on and you see it is failing already because we can't really increment strengths what does that even mean so let's build and show you the compiler error okay you see incremental is not satisfied and that the required expressions aren't valid you see plus plus a is not valid a plus plus is not valid and a plus equals one should not also be valid but we're not seeing that here but hopefully you see the message here that our concept is failing here if we comment out our strengths here and uncomment double all these operations we have here are supported for the double type so we should not fail here if we try to compile this because the concept is going to be satisfied let's use the gcc compiler to build you see the build is good now and we can clear and we can bring up a terminal to really see this that our binary was generated let's do the ir we're going to see our rooster executable here and if we go down let's say done we're going to see that if we build again to bring this in consideration clear run rooster the program was generated and it is really running because the concept here is satisfied with our call using double arguments here okay so this is really all i set out to share with you guys in this lecture i hope you know the syntaxes you can use to create your own concepts you can either use type traits like we have seen here and the syntax is to put the keyword concept put in your concept name put an ecosign and then specify your type trait here this is going to work if you need something a little more complicated then you're going to use this syntax here and put the requirements for your concept in these curly braces you can either put one statement like we did here or you can even put as many statements as you want just remember to end them with semicolons and another thing you shouldn't really take lightly is that this is just going to check for syntax it's not going to check for the value you get after you add one to a here for example it's not going to check for the value you get after you multiply b it's just going to see that a multiply b is valid syntax for the types that our template parameter is using here we are going to stop here in this lecture this one we're going to zoom in a little more on the requires close here go ahead and finish up here and meet me there in this lecture we're going to learn about some more things we can do with our requires close but before we do that let's look at the kinds of requirements we can put in our requires close the first one is a simple requirement which is what we have seen so far we can also do a nested requirement and we're going to learn about this in a minute and we can do a compound requirement which is going to allow us to specify more things about what we require for our concept there are also type requirements but these are really advanced for the scope of this course so we're not going to talk about these in this course what we're going to look at are these three first here so let's look at a simple requirement this is what we have seen already here we have our template declaration we have a concept declared the concept name is tiny type we're going to put in our requires close we're going to put in our parameter list and we're going to put in our curly braces inside the requires close we have a statement here which is going to enforce that size of t is less than 4. and what this really means it's going to check that size of t the syntax here is correct and this can really throw people off i have said this in the last lecture but i set up this little example to really drive this home and show you that if you are not careful your concepts are going to be really wrong this is going to check for the syntax so for example if we call a function template with this concept with a car type the concept is going to be satisfied even if the size of the car is less than 4 obviously but that's not going to be the job of this concept here this concept is not going to enforce for the expression here to evaluate to true it's going to just check the syntax and if you pass something smaller than a net in a function template with this concept this is going to be valid c plus plus", "71095.92 - 71397.19200000001": "so now you must be asking how can i enforce for the value of this expression to be true using concept well for that you will have to use nested requirements and a nested requirement is going to have another requires keyword inserted in front of it now if you use the syntax like this now this is going to check that size of t is actually less than 4. if it's not less than 4 this is going to return false here and the concept is going to fail and this is how you can use nested requirements to enforce for some expressions to be true in your requires close another kind of requirement you can set up for your concept is the compound requirement and this is going to allow you to check if something doesn't throw an exception you can do that using the no accept keyword but we're not going to use this now because this is not in scope for what we can do at this point in the course but you can also check the return type of an expression and divorce that it satisfies some type trait for example so here we are saying for our concept and if we pass in two parameters the syntax for adding a and b must be correct and supported for those types but the result of a and b must also be convertible to ant and you can do something like this and this is going to work you can enforce these kinds of things using compound requirements okay now that you know about these kinds of requirements you can put in your requires close let's head over to visual studio code and play with us a little more okay here we are in our working folder the current project is zooming in on requires close we're going to grab our template files and we're going to put them in place and we're going to open that in visual studio code pretty quick by dragging and dropping here this is going to open up our folder we're going to do the usual we're going to close the pane here we're going to clean things up a little bit and we're going to include our concepts library let's do that we are going to set up a simple concept we're going to say template and we're going to say what the concept is the concept is going to be called the tiny type and we're going to say what makes this concept a tiny time we're going to put in our requires close and we're going to put in the template parameter call it t why not and we're going to put in our closing semicolon here now what is going to make this concept a tiny type is that the size of the template parameter view is going to be less than four let's suppose we are doing the function and we wanted to use for integral types that are smaller than four bytes in memory suppose you want to do this and it is useful in the problem that you are trying to solve in c plus plus the way we can enforce this we can say size of t is supposed to be less than four let's say size of properly can't type can i okay the moment we do this you're going to see that this is valid c plus plus syntax so we're not going to have any squiggly lines but what you should know is that this is a simple requirement in c plus plus concepts and what this is going to do it's just going to enforce the syntax of what we do here what we put here must be valid c plus plus syntax so only enforces syntax this is what you should really remember okay now that we have this end let's try it out and show you some problems you can really run into we're going to set up two character variables we're going to call the first one x we're going to initialize this with 57 why not 67 and we're going to put in the other variable which is going to be y and it's going to have a 56 n you can put in whatever you want just make sure that you are within the range of the card type which is between 0 and 255 if you remember okay now that we have this n i realize we don't have a function we can try this on let's set up another function pretty quick we're going to say tiny type auto we can do that you already know this syntax and we're going to say add tiny type auto a and a tiny type auto p we can do that and we're going to return a plus b now that we have this let's say a and b down here and call this function we're going to say x and y and we're going to try and compile this program and it is going to compile fine because the type we are using to call the function which is car its size is going to be less than four okay so this is going to work and it is going to compile let's build with gcc you're going to see that the build is good let's try and uh change the type here to end or even double you know double is 8 bytes in memory so we expect this to probably give us something wrong double type is eight bytes in memory so we expect the", "71397.19200000001 - 71696.0": "to be false because the size of t is going to be eight and eight is not less than four this is going to be false so some might expect this concept here to fail but let's try and really prove you wrong we're going to build with gcc and you see it's building successfully what this is really doing is that with simple requirements like we have here c plus plus is only going to enforce for this to be valid c plus plus syntax and size of t is less than four is going to be valid c plus plus syntax even if this expression here evaluates to false this is not going to enforce for the value of this expression to be false you can't do that with simple requirements what you will do is check that this is valid syntax now what do we do if we really want to enforce that size of t should be less than four if you want that you should use nested requirements and the syntax to do that is really simple we can go down here and put that in we're going to say requires we're going to add a requires keyword in front of this then we're going to put our expression here let's copy it and put it in i don't want to type this again the moment we do this now compilation is going to fail if we pass a type whose size is not less than four and let's try and build again you're going to see that the world is going to fail now and we're going to have a failed concept and you see world finished with errors we have constraints not satisfied and if we go down here we're going to see required for the satisfaction of tiny type auto and we passed in a double type whose size is 8 bytes in memory and it is less than four bytes you see the requirement here it is not satisfied we can do this using nested requirements okay if we go down for example and change this to car some people call this char but i call this car that's my habit if we change this to car and try to bolt again you're going to see that it is going to weld fine because now what is wrong here let's see what we got wrong huh we are getting a compiler error here what is the problem it's going to say let's go up and try to analyze this a little bit it's saying deduce the return type does not satisfy placeholder constraints and we are requiring for the return type of this guy to be tiny time uh-huh i think i know what the problem is the problem is the arithmetic operations like the addition we're doing here are not supported for types which are smaller than ant and is the smallest type we can use with arithmetic operations so what the compiler is going to do is going to do implicit conversions from car to end and inside here what we will have are going to be ant the result of this is going to be ant and the return type is going to be deduced to be at but ant is going to violate the requirement we have here which is saying that the size of tiny type here should be less than four and the return of ant is not less than four so we can try and fix this by putting an equal sign here and i think it's going to work let's do that and world again this is a good learning experience and now you see that the build is going to work because now the return type is going to satisfy our requirements so let's prove that we are getting a net out of this actually we're going to do our own result and we're going to say equal and grab the result of this guy we should really prove these thanks and after this we're going to print the results we can do that and we can even go further and print the size of result here so we're going to say size of result okay now that we have this end we can weld with gcc and the world is good don't mind this squiggly line it is probably visual studio code messing with us you see that the world is good we can now bring up a terminal and run this and see the size of the return type and really prove that the compiler turned that into an end even if we called our function with car arguments this is interesting so clear and run rooster now we're going to see results is going to be 123 and the size of the result is for even if we passed in car types as our arguments okay so hopefully this proves that you can set up nested requirements to enforce for the expression here to be checked another type of requirement you can do is a compound requirement let's put this in and we're going to put in a simple example to drive this home i think i should take this function and put that below our concepts so a compound requirement looks like this you put your expression in acrylics like", "71696.0 - 71997.68000000001": "requirements on the values of the expression for example we can enforce that the value of a plus b here should be convertible to and if it's not convertible to end the concept here is going to fail this is a compound requirement you can even put no except keywords in here but we're not going to go this far because we haven't really learned about exceptions so for now i'm going to test this out i just wanted you to be aware that you can do that now that we have this concept n let's play with it and see how we can make it break thanks we're going to change our concept to edible let's say edible here and we're going to say edible and we're going to put in our car types here and it is going to slay work because we can add two car variables and this is going to work because we can add two car variables and this is valid syntax what we're going to get out of that is going to be an ant because remember the compiler is going to insert implicit conversions from card to end because it can't really add two card types and is the smallest thing you can do arithmetic operations on so the result of this is going to be an end so a lens is convertible to an edge this is going to work let's build and show you that this is going to work we're going to weld this with the gcc you see build is good we can try and run this and see what we get after calling the function we get result is 123 and this is going to be the size of four because we get a net out of this let's try and change this to double and see what we get so double let's say double here and if we would we expect this to work because adding up two doubles is going to give you a double and we're going to return a double from this function and uh a double is convertible to a net so we're going to return a double from this guy and this should say eight now because that's what we are returning from the function here let's build with gcc you see the both is good we can clear and run rooster this is going to say size of result is eight because now what we are returning is going to be a double from this function here and double satisfies our concept adding up two doubles is valid syntax and what we get out of that is going to be a double and a double is convertible to a net this is going to work let's try and change our parameters here to strength we're going to comment out our x and y variables here and we're going to set up two strings going to say std string x and we're going to say hello and you know what we're going to say and why we're going to say std strength y and we're going to say world why not and the moment we do this you see that we have a problem why do we have a problem because it is now a requirement for the result of a and b to be convertible to end remember that you can add up two strands for example you can say auto s and say x plus y this is going to work because you can add up two strings and this is going to concatenate them so this is valid syntax why are we failing here because we have a requirement for this to be convertible to an end and the strength isn't really convertible to an end so this is going to fail let's build this program and show you that this is actually the case we're going to see world finished with arrows and let's see the error we have okay so constraints not satisfied it's going to say required the satisfaction of audible with auto here in requirement and it's going to say a plus b does not satisfy the type requirement because what we get after adding a and b is not convertible to an end and you see that here a plus b convertible to an end this is going to fail okay so let's try and remove this requirement to convert to end and see that this actually works we're going to remove this i'm going to cut this out and try to build again i am going to use gcc to build and now you see that this is welding because we no longer have the requirement of the return value of this expression or result i should say the result of this function now doesn't have to be convertible to an okay let's put this back because i want you to see this later as a reference and now you know how you can use compound requirements to really put constraints on your function templates this is really all we set out to do in this lecture i hope you found it interesting i think i should comment out these guys because i don't like to leave you with code that has compiler errors let's turn this back to double so that this works we're going to weld again okay the world is good and we are going to stop here in this lecture in the next one we're going to see how we can combine concepts and do some crazy things go ahead and finish up here and meet me", "71997.68000000001 - 72295.83200000001": "how we can combine concepts using logical operators we can combine concepts using the and operator and the r operator as you see here let's look at a simple example here we have a concept it is time type we have seen before and it's going to check that the size of the template parameter we pass is less than four it's going to enforce the syntax with a simple requirement but it's also going to enforce for the value of this expression to be true if the value is not true the concept is going to fail and we are using a nested requirement for this so this is our concept here let's try and set up a function and see how we can combine this concept with other concepts here we have a function it is going to return a t the name of the function is func it is taking in our parameter and here we have the body of the function within these two curly braces but what we have here is a concept we want to apply to this function here and the first line here is going to show that we can combine the concept like we do here so this entire thing is going to be a logical combination of concepts so we can require that the template parameter be either an integral type or a floating point type using the or operator here another thing we can do is use the and operator as you see down here in the second line and we're going to require that the template parameter is both integral and a tiny type and the compiler is going to enforce these things as we are about to see in a minute when we hit visual studio code you can even specify your concepts in place for example the third line here is going to say we require for the concept to be integral so it should be an integral type and we're going to specify our tiny type concept in place you see we are doing that right here in the function declaration and this is going to work this is a valid c plus plus syntax but i don't recommend this because this is going to make your function declarations really ugly so now that you know this we're going to head over to visual studio code and play with this a little more it's just using the or and and operator to combine concepts okay here we are in our working folder the current project is combining concepts we're going to grab our template files pretty quick and put them in place and we're going to open this in visual studio code as we always do by dragging and dropping here we have our file we're going to open that up and close the left pane here i don't like it and we're going to include our concepts library let's do that we have this and the first thing we're going to do is to put in our tiny type concept here so it is tiny type it's going to require that the syntax for the size of t less than 4b supported this is a simple requirement again and we're going to require that this expression be true and we're doing this using a nested requirement okay now that we have this concept we can combine this with other concepts let's use the same function we've been using all along so we're going to say template type name team and we're going to put in our requires clause so we're going to say requires we can use std intergroup and say t and say or it should be htd floating point i think we have this end this is a concept we have which is built into the c plus plus standard library we can use this now that we have this we can then say the signature of a function t x is going to add up t a and t b and it's going to return the sum of a and b now you can only call this function with either integers or floating points if you try to deviate from this the concept is going to fail and we're going to get a compiler error let's go down and try this out we're going to say and x and put in a 6 for example and into y and put in a 4 and we're going to add this up we're going to say add x and y and if we do this this is going to work because this is an integer so the concept here is going to succeed let's weld with gcc and show you that the build is good the world is good so no problem we can change this to double it is going to work because double is a floating point let's say double properly and if we blow it again the bullet is going to go through but if we try and use for example a strength let's say std strength string that's a strength and we're going to change this into double quotes we can do that and say std strength and i put this in quotes again double quotes okay if we do this you see we have a squiggly line and if we walk we're going to have violated our concept because the parameters that we pass", "72295.83200000001 - 72595.28": "an integral type or a floating point type and if we go up here we're going to see that we have violated a concept constraint not satisfied and it's going to say the concept that was not satisfied here which is right here okay you can combine two concepts using the or operator but we can also use the and operator let's go down and try and put up a simple example that is going to do that now what we're going to require for people to use this function is to satisfy both tiny type and integral so we're going to say requires std integral i think we have this n and we're going to say and tiny time and we're going to say our template parameter here the moment we do this and let's turn this back to being at let's say ant x and put in a seven what we had before and at y and let's say four or a five doesn't matter if we do this let's see our thing again so tiny type requires for the size to be less or equal to four so ant is going to work this is going to build because the concept is going to be satisfied it is both integral and tiny type let's work and see this run you see the world is good our concept is satisfied but the moment we try and use something that is greater than four we're going to have a problem let's use a double for example we're going to change this to double and world we expect compilation to fail because the type which is double doesn't satisfy the tiny type concept and we're going to see that here okay so we're going to see weld finished with arrows and we're going to have a lengthy error here but the meat of this is that we have a constraint which is not satisfied and it is that for required for the satisfaction of std integral so double is not going to satisfy this i think double was a really bad example because it's not integral so integral is going to fail what if we pass in long ant okay which is really an integral type but it's not going to satisfy tiny type so let's say long end and we're going to build now we are going to violate let's use long long ant because i think long end is not large enough so we're going to build now we're going to fail because tiny type is not satisfied you see required for a dissatisfaction of tiny type and it's going to say size of t is less than 4 is not satisfied because guess what the size of lung lung ant is greater than 4. you can try and prove that by taking out this guy here and saying stdc out size of a long long end we're going to see this print out and if we're boiled now we're not going to violate our concepts because we're not calling the function the word is going to be good what we want to do is run the program and see the size of lung lung ant we can do this rooster eight the size of lung lung ant is eight and it is going to violate our tiny type concept okay you can do things like this and combine the concepts but we can even put our concepts in place we can do something crazy and for example say let's copy this and we're going to go down and say requires integral but we're going to put timely type in place for example we're going to grab the requires close here and copy it and put that in place of tiny type here we're going to do this and you're going to see that this is going to be valid c plus plus syntax if we take out the semicolon because it shouldn't be there but look at this this is really ugly this is going to make your functions really hard to read but it is going to work exactly the same way it did if we call this function we're going to violate tiny type let's do that we're going to build with gcc we have an error let's bring this up so that we can see what is wrong nested requirement size of t is not satisfied this is a syntax you can use but i don't really recommend this because this is going to make you code hard to read and this is really all we set out to do in this lecture looking at how we can combine our concepts using the and operator and the or operator and you can really use this in all the syntaxes for concepts we have seen but i just used this in this lecture because it is simpler to show we are going to stop here in this lecture the next one we're going to look at concepts and auto go ahead and finish up here and meet me there in this lecture we're going to zoom in on concepts and the auto key world we have already seen that we can do something like this use the auto keywords with our functions and let the compiler generate", "72595.28 - 72896.552": "and this worked pretty well we could use this syntax to put constraints on our other keywords and we saw that the compiler could actually enforce this and throw a compiler error if our concept here is violated what i haven't shown you is that you can even enforce concepts on variables that you declare you can do something like this set up a variable say auto x and call the variable x and enforce for the variable to be an integral type i don't really think you have much use for this because once you call the function and assign a value to a variable you already have an idea of what is going to come out of the function but if you have a use case for something like this please go ahead and use this it is going to enforce your concepts you can even use concepts like this set up a variable and assign a literal to the variable name using the auto keyword here but i personally find this useless because you are putting in the value yourself why do you want to put a protection if you know that you are putting in a double literal then the variable should be a double type i find this a little bit useless but it is supported in c plus plus if you have a use case for this please go ahead and use this now that you know this we're going to head over to visual studio code and play with us a little more okay here we are in our working folder the current project is concepts and auto we're going to grab our template files and we're going to put them in place and we're going to open this up in visual studio code let's do that pretty quick we're going to have our folder open we're going to open the main cpp file close the left pane and clean things up a little bit and we're going to include our concepts library and we're going to put in our function which is going to be using the auto keywords to really make the syntax nice and cool but we're going to be constraining our auto parameters here to use integral types if we call this function with something that is not an integer or any trigger type really we're going to get a compiler error so if we go down here for example and say add and say 10.9 and 0.1 we're going to get a compiler error because 10.9 and 0.1 are double literals and we only support integral types in this function here so let's work and show you the error but you must know this by now because we have done this like a gazillion times the concept integral is going to be violated and it's going to say required for the satisfaction of integral so the concept is failing here we're going to get a compiler error but if we change this for example to 10 and 5 put in whatever you want which is an integer this is going to work we're going to build with gcc you see the wealth is good so you can use auto with concepts like this we have seen this syntax already a couple of times in this chapter what we haven't seen is that for example you can set up a variable in main and call this x y naught and say this variable should satisfy the concept and specify the concept you want for example let's say std integral and if you do something like this let's see what we get from this we're going to world you see the work is good because if we add up these guys we're going to generate an integer instance for this function and we're going to deduce the return type as ant so the return type is going to be integral and it's going to be assignable in our variable here but if we change to floating point i think we have this concept in place yes we do but it is going to fail because what we get from this function is going to be an integer and we can't assign to this because this concept here is saying what you try to assign to this variable here should be a floating point this is the meaning here and if we do this we're going to get to the error probably so we have the arrow and it's going to say constraint not satisfied and it is going to say the constraint we didn't satisfy which is its floating point here this is how you can put constraints on your variables even when you are declaring them so another thing we can try here is to assign a literal to this variable here let's put in a 3.9 and see if this actually boils and compiles let's build with gcc you see the build is good and the requirement is for what we assigned to this variable here should be a double and a 3.9 is already a double so no problem but if we try and make this seven for example this is going to fail so let's build again you see the concept is going to fail and this is how you can use these things to constrain your variables i personally find this a little bit", "72896.552 - 73196.31999999999": "because i know that i have an integer literal and i am assigning this to a variable why do i need the help of concepts to really constrain my variable here but in the case where you are calling a function for example using a 5 and an 8 this can come in handy because it's not easy to keep track of the return type you get from a function because the function might have a return expression that has multiple different variables and it's not easy to keep track of what you get back from a function and you can use a constraint like this to make sure what you get from the function is what you want and if it's not what you want you're going to throw a compiler error because the concept you use is going to fail i would like to welcome you in this new chapter where we're going to be learning about classes classes are a mechanism we have in c plus plus to build our own types and use them like we have been using other bulletin types like and to double or whatever and we're going to be able to do that by setting up blueprints of our class types and we're going to be using those blueprints to build actual objects that we can use in our c plus plus program so for example we can have a class as a blueprint and we can create real class objects in our c plus plus program as we need them and we're going to be learning all about this in the next few chapters we are going to head over in the next lecture and let you set up your very first c plus plus class go ahead and finish up here and meet me there in this lecture you are going to build your first c plus plus class classes are a mechanism we have in c plus plus to be able to build our own types if you remember so far in this course we have been using basic types like ant and double and we were using them like this we said the type of the variable we give the name of the variable and then we initialize this variable and we can use this throughout our program now we are at a point where we need to start designing our own types suppose we want to build our own type that models a person for example suppose a person is defined by the name the age and the address and we want to model persons in our program and use them as players for example and when we have the properties of a person we can do all kinds of crazy things with them we can make them jump up for example if we are designing a game we can make them run we can make them fly we can do all kinds of crazy things in this lecture we're going to use a cylinder as an example and we're going to model a cylinder in our c plus plus program a cylinder is defined by two things it has a base radius which is modeled by this r you see here and it has a height and when we have this information about our cylinder we can really do all kinds of crazy things for example we can compute its area the base area and the formula to do that is pi r squared this is a formula you get from your basic mathematics education you can compute the volume of the cylinder and the formula to do that is area multiplied by the height and we can really do all kinds of crazy things with the cylinder if we have this information so we're going to use this information and model a cylinder we can use in our c plus plus program and we're going to be using classes to do that the syntax to set up your class in c plus plus it's really simple you say class this is the keyword you have to put in here you say the name of your class in this case it is cylander as you see here and then we put a pair of curly braces in place the start is on top here and the end is down here and after your class definition you're going to put a semicolon inside the class we really have two parts we have member variables which are going to model the properties that your class is going to have in this case we have two properties that really define a cylinder we have the best radius and we have the height we have decided to model these things as double types inside our class and this is going to make the first part of our class the member variables the second part is going to be made of behaviors or functions that do things on the class using the properties and one function we have is the volume function which is going to help us compute the volume of our cylinder here if you look at its syntax it really is a function we", "73196.31999999999 - 73496.31999999999": "the function we have the parameter list which is empty by now and we have our curly braces that delimit the body of our function inside the function we're going to do nothing special we're just going to return the volume of our function here and if you remember the volume is the base area multiplied by the height and this thing here is going to model the base area you see it's pi multiplied by the square of the radius and then we're going to multiply this by the height and we're going to return the volume for use by whoever is calling this function one thing we haven't really talked about is this public thing you see here and what this says is that the members that we have in this class are going to be accessible from the outside of the class for now we can't really understand this but when we hit visual studio code i'm going to show you what this exactly means now that we have the class declared we can really use it like we use any other types in c plus plus for example we can head in our main function and set up a variable called cylinder one as you see here is type is going to be cylinder and notice that this is really a type that we build ourselves and we can really use it like we use other variables for example we can call it function using the syntax here and print the volume this is going to print the volume using the volume function that we just set up in a minute if we go down we can modify things about our cylinder for example we can use the dot notation here to change the base radius and change the height and if we try to print the volume again this information is going to be picked up and be used by the volume function to compute the volume of our cylinder here this is really cool if you want you can also set up another cylinder like we do here and we're going to print the volume and we can really do all kinds of crazy things with our types like this okay this is our class and we can really use it to do a lot before we head over to visual studio code and play with us i want to bring to your attention that members of a class are private by default and what i mean by that is that for example if we don't put this public keywords in here we want to be able to use the volume function for example like we have used it in our main function as you see here if the member is private it won't be usable outside the class this is what we mean here we are trying to use this member in the main function outside the class definition it won't be accessible if it is private and we make it public by putting the public keyword and the column like we do here everything after this public keyword is going to be public until we change this to private somewhere in our program if we need that now that you have an idea about how you can declare and use your class in c plus plus let's head over to visual studio code and play with us a little more okay here we are in our working folder the current project is your first class you are going to build your very first class in c plus plus we're going to grab our template files we're going to copy them and put them in place and then we're going to open this little guy in visual studio code by dragging and dropping here this is going to open our folder we're going to close the left pane here and clean things up a little bit the first thing we want to do is to declare our class but before we do that we're going to need the pi variable because remember we're going to model pi for use in computing the area and the volume of our cylinder that we want to model like we did in the slides so the way we're going to do that i am going to declare a const variable and i am going to call it pi and i am going to initialize this with pi to get pi i'm going to cheat a little bit i'm going to go in my calculator and let's see if i can get pi here and i click on this and i'm going to grab pi here and copy it this is the easiest way i can find so i'm going to put it in here and this is going to be our variable now that we have this we're going to set up our class and that to define a class you say class you have to put in this keyword and then we're going to say the name of the class the name of the class is going to be cylinder and after we do this we're going to put a pair of curly braces and we're going to end this with a semi-colon you have to remember this if you don't put it here the ziploc plus compiler is going to complain now that we have the class blueprint here we're going to put in our member", "73496.31999999999 - 73797.12000000001": "variables we use to model the base radius and the height of our cylinder we're going to put in a double variable and we're going to call this base radius and we're going to brace initialize this to zero we can do this and we're going to set up another one and call it height and we're going to also initialize this to zero okay now that we have this we're going to put functions or methods in our class and we do that by just putting the function definition in our class so our function is going to be returning double because it's going to be returning the volume of our cylinder so it's going to return double here the name is going to be volume and it's going to be computing the volume and returning that remember the formula to compute the volume is going to be pi we have a pi variable on top and we're going to multiply by this radius twice because the base radius has to be squared let's do that and multiply by base radius again and then we're going to multiply by height and notice that these are guys declared in the body of the class if i can say that this is the definition of the class we are able to use this guys because we are inside this class here okay now that we have this our class is really defined but we can't really use it quite yet what do i mean by that let's go in the main function and we're going to set up a variable of type cylinder we can do that and let's call this cylinder one if we do this and try to compile this this is going to work fine let's do that we're going to world with gcc world finished successfully this is welding but we have a function called volume here and we can try and call it using the dot notation that we saw in the slides let's try and print the volume of our cylinder here and see what we get so we're going to say volume we can save that and we're going to say cylinder one and do volume okay let's see if we can call this function here and the moment we do that you see that we have a squiggly line here so visual studio code has detected that something is wrong let's hit the problems tab here and see what we get it's going to say expected an identifier on line what this is not making sense uh we put three columns here let's correct this a little bit and the error is going to change to be suddenly the volume declared at line 6 is inaccessible from this location here this is what the error says and it is not sensible because members of the class are private by default so they want to be accessible from the outside of the class like we are doing in the main function here notice that we are able to access them from the inside of the class you see base radius is declared down here and we are able to use in the function because the function volume here is inside the class so the members are accessible even if they are private but private members can't be accessible from the outside of the class like we are doing in the main function here that's why we have this problem let's see what the compiler says we're going to pass this through gcc and we're going to get a compiler error that we expect and the compiler is really specific on this it's going to say double cylinder volume the volume function from the cylinder class is private within this context and which context the line 19 when we are trying to use it in the main function so if you really want thanks inside the class to be accessible from the outside you need to make them public and change them from private how do we do that it is really simple you use the syntax we saw in the slides we're going to say public and put a column here and when you do this it is advised to align your things a little bit properly so when we do this everything after this public keyword is going to be public in this class and it will be accessible from the outside let's try and build now but before we build let's show you that the squiggly line should be gone visual studio code is still confused let's try and vault let's pass this through gcc now you see that the world is good okay now if you try and print the volume here we're going to get zero because the base radius is braced initialized to zero the height is zero and if we multiply like this we're going to get a zero and return that let's try and run this program because we just build it successfully we can bring up a terminal to do that and let's clear and run rooster and we can see that the volume is zero and it is what we expect okay now our class is working but there is", "73797.12000000001 - 74095.76": "that is because the public keyword is going to make everything public in this class the member variables are also going to be public so we can go down here and print the base radius and the height for example let's do that and show you that this is the case so we're going to say cylinder one and say base radius this is going to print and we're going to say hi we're going to print this out if we try and print these guys let's build and pass this through gcc you see the bolt is good and if we clear and run rooster we're going to see that this radius and height are or accessible to show you that this can also be different from zero let's change the base radius to one and the height to one to make it a unit cylinder let's try and weld we're going to change these guys to one and the volume is going to be 3.14 or something let's run rooster we're going to see our volume here and we have the base radius and the height but this is really bad design because the member variables in most cases you're going to want to keep them private from the outside because users of your class don't really care about the member variables they just want to do things with your class for example calling the volume function here so what we usually do in practice is to flag our member variables as private and we can do that using the private keyword as we do here and at the moment we do this everything after this private keyword is going to be private to the class it is only going to be accessible from the inside of the class but if we try to access that from the outside we're going to get the same compiler error we saw before when we tried to access private stuff from the class in the main function here visual studio code is going to give us a problem saying that these member variables are not accessible from this context here and if we pass this through gcc we're going to get a clear compiler error saying that the height and the base radius are now private in the class and we can't access them from the outside this is really what i wanted you to see and this is good design okay now that we have our class declared and that we can use it in the main function i want you to see that it is possible to change these member variables but to do that we will need to turn this back to public and we're going to see a better way to do this later but for now let's make them public and show you that we can change things around and make our cylinders a little more interesting so now that they are public we can go in the main function and do crazy things change the data for example we can change our member variables to be something else let's go down and say cylinder one and say base radius we can use the dot notation and put an ecosign and give another value to our base radius let's make it 10 for example and change the height to be something else we can change that and we're going to put in a 3 for example why not now if we print the volume again we're going to get another value let's copy this and put that down below our changes here and if we build the program it should well define the world is good so we can hit enter and clear and if we run rooster we're going to get the volume to be 3.14 first here the first line here and the second line is going to give us another volume and if we multiply these guys with pi and if we use our formula to compute the volume we're going to basically get the same thing let's try and prove this with our calculator we have it around so we have pi in here we're going to multiply this with 100 which is the radius squared we're going to put 100 here and we're going to multiply this with 3 which is our height let's put this in and we have 942.47 which is what we have here roughly the same thing so you see that our function is really computing our volume we can even go down and change the height to something else for example we're going to change the height to let's make an eight and i printed the volume again you can keep playing with us and really make it clear that our volume function is computing our volume using the data that we have in the member variables this is the message here let's build again the world should be good we're going to clear and run rooster now we see another number for our volume and this is really how you can declare a class again you use the syntax you see here class you say the class name you put a pair of curly braces and you put your semicolon don't forget this", "74095.76 - 74397.12": "default but you can make them public if you want using the public keyword as we did here inside your class you're going to have two parts you're going to have the member variables which are going to be properties that define what your class is and we're going to have functions or methods let's say that and these are going to be behaviors of your class you're going to go through these functions to make your classes do things and once you have the class definition in place you can use it to create variables as we do in the main function here and the variables we create from our class are usually called objects in c plus plus terminology okay the class is really a blueprint and we create objects using that blueprint and objects are going to have runtime data that we store in our class okay so for example if we hit this point here the base radius is going to be 10 and the height is going to be eight and that's going to be runtime information for our class object stored in this variable that we call cylinder one here this is really what i wanted you to see okay let's try and recap what we know about classes so far a class can have member variables but so far we have used member variables as stack variables if we go back for example you see that we say base radius here you notice it is not a pointer or a reference or anything it is a stack variable inside our class so member variables can only be stack variables like we have here but they can also be pointers but they can never be references and the reason is a reference can never be left uninitialized and in the classes when we declare member variables the ability to leave them uninitialized is really important and we can't really do that with references i can't really go into the details of that as we will see that as we progress in the chapter but know that member variables can either be stacked variables or pointers but they can never be references in z plus okay that's what we just said here members can't be references classes can have functions or methods that let them do things we saw an example of this with our volume function class methods have access to the member variables regardless of whether they are public or private we have seen that the volume function will have access to our member variables regardless of whether it is public or private and last but not least private members of classes aren't accessible from the outside as we saw in the main function you can't access them from the main function you can only do that from the class definition itself this is really all i had to share in this lecture i hope you found it interesting we are going to stop here in this one in the next one we're going to see how class objects are built from constructors go ahead and finish up here and meet me there in this lecture we're going to learn about constructors and constructors are special class methods or functions that are called by the compiler to construct your class objects and they are special because they have no return type a constructor can never have a return type as you see here they have the same name as the class so for example for our class in the last lecture that was called silenter the constructors are also going to have the same name as the class they are going to be called also slander constructors can have parameters but if it makes sense for whatever it is you are trying to do you can also leave the parameters out and constructors are usually used to initialize the member variables and put them in a state where you want them in your c plus plus application let's look at how you can declare constructors for your classes here is our cylinder class you see we have our member variables we had they are private now and we have a public section which is going to have our functions or behaviors as you see here the member variables are what we have seen from the last lecture but if you look here we have a few new things here we have two things that look like functions but they don't have return values that's something you should notice they have a parameter list as you see here and we have a pair of curly braces because these are really functions and these are special functions that are going to be called by the compiler to initialize your class objects if you look here in this example we are using the", "74397.12 - 74695.512": "initialize our member variables to 2 and we have another constructor as you see down here which is going to take parameters directly and it's going to take the radius parameter and the height parameter the parameters are of double type because that's what we expect in our class and we are passing them by value here because they are fundamental types and we don't really mind copying them but please keep in mind that they are going to be passed by value and what you have inside your constructor body are going to be copies of the original arguments that were passed to your constructor and this is really how you declare constructors for your c plus plus classes constructors can either have parameters like we have again on this example here or they can have no parameters and this is going to be a default constructor we're going to see that this is going to be called when you try to create variables of this cylinder type without passing the parenthesis like we do when we call this second constructor here we're going to see this in a minute okay this is all i think i have to share in the slides about how you declare constructors let's head over to visual studio code and play with this a little more okay here we are in our working folder the current project is constructors we're going to put in our template files pretty quick let's do that and we are going to open this in visual studio code by dragging and dropping on top here this is going to open our folder let's open our main cpp file and we're going to take out what we don't need in the main function and on top here and i am going to reuse code from the last lecture because we don't want to type that again so let's put in our class definition we have our variable pi which is going to be used to compute the volume in the class here and we have member variables okay now that we are here let's change the member variables to be private because making them public is really going to be bad design it's going to expose them in the main function and people can mess with them and really change the logic of how our class works without our concept it is advised to make your member variables private unless you really have a compelling reasons to make them public okay now that we have our class here let's set up constructors for it so we're going to go down here in the public scope and say constructors and we're going to set up the first constructor which is not going to take any parameter so we're going to say the name of the class remember a constructor doesn't have a return type and it has to have the same name as the class so we need to comply with that and we're going to put our pair of curly braces and inside we're going to initialize our member variables however we want so what we're going to do here we're going to set the base radius to something let's make it a 2 like we saw in the slides no problem with that and we're going to set the height to something else and we are going to set the height to 2 as well we can do that you can use what you want and now we have our constructor and it is initializing our thanks okay now that we have the constructor in place how is it really called by the compiler and notice that our constructor is in the public scope of the class if it isn't public you want to be able to access it from the outside and the compiler will fail to build your objects and we're going to see this in a minute but before we do that let's try and create a cylinder object now so we're going to say cylinder and say cylinder one like we did in the last lecture and when we do this notice what we see if we print the volume of our cylinder object here this is an object because we're creating this from our blueprint which is the class definition here you really need to know this this is a class object let's say that and we're going to print its volume we're going to say cylinder one and we're going to call our volume method we should say and if we build you're going to see that this is going to work but the volume is not going to be coming from the initial values we have here we will have changed these guys to 2 from our constructor here because the compiler is going to look at this line here and see that we are trying to build a silent object it's going to look at the class definition and it is going to say do i have any constructor that i can use to build an object from the syntax i see here and it's going to see that it has a constructor that doesn't take any parameter and it's going to use it to build our object and it's going to be using this information", "74695.512 - 74995.6": "radius is going to be two the height is going to be two and it's going to use that to compute the volume that we print here you really need to understand this let's vote and see if gcc accepts this you see the both is good now we can bring up a terminal and clear and run rooster you're going to see that we have 25 something which is a result of using this information we have here if we take pi multiplied by this base radius multiply by this base radius again and multiply by height we're going to get this here you can try this out it is going to be what you see here and this hopefully proves that the compiler is using our constructor here but we can also use a debugger let's set up a breakpoint here and we're going to run this through our debugger we can come back to the run tab here as we have done before and we're going to try and use the debugging tools that come with the gcc compiler that's what we can use if you are on windows you can also use the tools that come with the compiler from microsoft but we're not going to use that now gcc is going to be fine we're going to start the debugging and we should hit our breakpoint when the build is done let's wait a minute okay we have hit our breakpoint we can minimize this a little bit and i show the terminal to the right here i think we can do that let's do that let's put that a little bit to the right here and minimize a little bit okay we have our thunk in place we have hit our break point you see these are the local variables we have here we have a cylinder object which is not initialized yet because you see what we have inside is really junk data we haven't put in anything yet but now that we are at this break point here we can hit step into and step into the code that constructs our cylinder object because at this point liner 25 here hasn't run yet so we're going to step into and you're going to see that we hit the constructor for our cylinder object and this again proves that our constructor is being used to build our cylinder objects now we can move to the next line we're going to set up the base radius and if we hit next here this is going to set our base radius to 2 and you see that height is in one because we haven't set it up yet but if we execute this line you're going to see that height is also going to change to two and now if we hit next we're going to get out of our constructor and our cylinder object will be already constructed if we look again here we're going to see that radius is 2 height is 2 and we can print the volume and if we hit step over we're going to see our volume printed out here hopefully again this proves that our constructor here is being used to build objects and it is doing that because it is the syntax here we don't pass any parameter to our cylinder object as we created so this must be calling the default constructor which doesn't take any parameter this is the message here let's close our debugging session and maximize our visual studio code instance because we're going to set up another constructor which is going to take parameters now and you have seen the syntax to do that in the slides it is nothing complicated we're going to say the name of the constructor which is going to be the name of the class and we're going to say double and say rad param for radius and we're going to say height param for our height and we're going to make this double and after that we're going to head in the body of our constructor and we're going to initialize our guides to the parameters that will pass to the function here and this is really powerful after we have this constructor end we will be able to pass parameters that will be used to construct our cylinder object so we can say base radius and pass in red param and we can say height and say height param here and these are going to be used to construct our object now we can head over in the main function and change how we construct our cylinder object if we want to use tan as the radius and five or four as the height we can do that by passing arguments to our constructor here let's run this through the debugger again and see that our information here is being used now this constructor here is going to be chosen by the compiler because it is more fitting for the call that we are doing here let's run our debugging", "74995.6 - 75295.512": "and we are going to try and maximize this a little bit and bring up our terminal output okay we have hit the breakpoint here we can step into our constructor and notice the constructor that the compiler chooses our constructor that takes parameters is chosen here and we can do things inside let's hit next we're going to initialize the base radius to 10 and we're going to initialize the height to four okay we can see that to the left here if we hit next the height is going to be changed to four and our constructor is going to be done we're going to head over in the main function again and if we step over now we're going to print a new volume which is based on the information we used to construct our object here this is really what constructors do they are used by the compiler to build your objects and we saw the syntax we can use to set up constructors for our own classes okay now you must be saying if we need constructors to build our objects why was the code in the last lecture working in the last lecture we did something like this we said cylinder cylinder one cylinder one and this was welding and compiling fine and let's try and take out our constructors we can do that let's comment them out and if you look you're going to see that the code is going to compile fine even if we don't have any constructors in here let's build with gcc to show you that the code is going to compile both is good so how is this working how is this constructing our objects even if we don't have any constructors in here well the reason is the compiler is going to set up its own constructor and what it is going to set up is a constructor which is really empty and doesn't have anything inside it's basically going to be as if we put in an empty constructor let's copy this and actually show you this we can do that and we're going to make this constructor empty and not do anything in the body this is the constructor that your compiler is going to generate and if we're both now and i try to set up a break point here you're going to see that our empty constructor is going to be chosen let's debug and show you that okay you see that we're going to hit the breakpoint here and if we step into the compiler is going to choose this guy and it's not going to do anything so it's basically going to take our member variables as they are and it's going to use the information to print the volume here we can hit next again and get out of our constructor and if we step over we should print our volume which is going to be 3.14 because the compiler just used the initial values we have in our member variables here so again the message is if you don't have any constructor in your class the compiler is going to generate an empty constructor for you and the empty constructor is going to take no parameters and it's not going to have anything in the body it's going to be an empty constructor and it is called a default constructor generated by the compiler this is really all i had to share in this lecture i hope you found it interesting now you should have enough knowledge to build your own constructors for your classes we are going to stop here in this lecture the next one we're going to learn about default constructors go ahead and finish up here and meet me there in this lecture we're going to learn about default constructors and this is a syntax you can use to let the compiler generate a default constructor for you all you have to do is do things like this you're going to say the name of the constructor which is going to be the same name as the class you're going to put in an empty parameter list and then you're going to say equals default if you do this the compiler is going to generate a default empty constructor for you in the last lecture we have seen that we can set up our own constructors basically like this what i haven't told you is that the moment you set up your own constructor the compiler is going to not generate the default constructor and if you want to keep the ability to construct objects without passing parameters you're going to have to put in your own default constructor and you can use this syntax here to do that let's head over to visual studio code and talk about this a little more okay here we are in our working folder the current project is defaulted constructors we're going to grab our template files and we're going to put them in place and we are going to open", "75295.512 - 75595.12": "and dropping here and we're going to open our main cpp file let's take out what we don't need we're going to clean the main function here and we are going to bring in the class definition we had in the last lecture if you remember we had two constructors and one constructor which didn't take any parameter and another constructor which was initializing our member variables with parameters that we passed in this parameter list here but in this lecture let's take out this constructor that doesn't take any parameter and show you that when you set up your own constructor the compiler is not going to generate a default constructor for you and we're going to lose the ability to construct objects without passing parameters the syntax we basically see here we're going to say cylinder and say cylinder one let's use a lowercase c and if we do this you see that we have a squiggly line the compiler is not going to generate an empty non-parameter taking constructor because it sees that we have a constructor here this is how c plus plus compilers work if they see that you have any constructor in your class they're not going to generate a default empty constructor and if we try to build we're going to get an arrow that says something like we don't have a constructor that can basically construct an object from the line here it's going to say no matching function call for cylinder cylinder you see here it is trying to call a constructor that doesn't take any parameter but we have no such constructor in our code we could go in and put in that constructor and for example say cylinder and put an empty parameter list and put an empty body now this line here is going to work because we have a default empty constructor and if we weld you see that the build is going to be good okay we are building fine but having to type all this if what you really want is an empty constructor is too much type in and in c plus plus we have a syntax we can use to let the compiler generate this kind of constructor for us and the way we do that is say cylinder and we say the name of the constructor we say equals and we say default if we save this the compiler is going to generate this constructor for us and the line here is going to work so let's bring this up and build again we're going to build with gcc you're going to see that the build is good and we can bring up the terminal and clear and run rooster we're not going to see anything because we're not printing the volume of our cylinder here but we can do that let's call this cylinder one to be consistent with what we did in the last few lectures and we're going to say hddc out and print the volume of this cylinder we're going to say volume and call our volume method and now that we have this we can weld we're going to use gcc to do that the build is good we can go down and clear and run rooster we're going to see that we see our volume here and this is really all i wanted to share with you in this lecture that you can use this default syntax here to set up an empty default constructor for your classes and one thing i haven't shown you is that your constructors have to be public to be able to be called like this and to show you that let's go up and actually change this to private and show you what happens the moment we do this we're going to get a squiggly line in the main function here and if we try to build but before we build let's show you what visual studio code is saying it's going to say cylinder cylinder declared is inaccessible so you see the constructor which is declared inside of a class as private it accessible from the outside when we try to call it to build our cylinder objects so for constructors to be usable on the outside here and both your objects they have to be public let's build and see what gcc says about this we basically going to have the same error the constructor is private within this context so we can't really call it so if we want our code to build we need to make our constructors public and this is something you need to know let's build again and see that the cold is now building the world is good and this is really all i had to share in this lecture we are going to stop here in this one in the next one we're going to see how we can use setters and getters to modify things about our class objects go ahead and finish up here and meet me there in this lecture we're going to learn about setters and gators and these are methods in our class that we can use to", "75595.12 - 75897.28": "our member variables let's look at a simple example and by the way i am sorry for my bad pronunciation of cylinder here i have said it was cylinder and after some careful thought i checked online for the pronunciation on this and i found that it was cylinder sorry for this if it was bothering you i apologize for the bad pronunciation and i am going to do this right starting from now okay here we have our cylinder class we have a few member variables and we have the base radius we have the height and now we want to go through some public functions to do operations on these member variables because now that they are private we can't really modify them or manipulate them from the outside and we really need to do things with them so if we want to read things from them we will use the getter functions and if you look here this is a simple function the only special thing about it is that it leaves inside the class it has a return value it has a function name it has a parameter list and then the body we're just going to return the member variable of interest because this is a getter we use that to get stuff from the class this is the meaning here here we have another getter function which is going to return the height and notice that these functions live in the public scope of our class this is key because we want to be able to go through them to modify and do things with our member variables but they will be used from the outside so they must be public otherwise they want to be accessible from the outside we also have a pair of setup functions they are going to be modifying our member variables so set base radius is going to take a parameter that it's going to use to set a base radius set height is going to do the same it's going to take a parameter and it's going to use that to assign a value to our height member variable here and because these functions are members of the class they have access to our member variables regardless of whether they are public or private so this is going to work we're going to go through them from the outside and they are going to do the dairy work for us and do things using our member variables to which we don't have access to from the outside this is the meaning here now that you have an idea about this we're going to head over to visual studio code and play with us a little more okay here we are in our working folder the current project is setters and getters we're going to grab our template files pretty quick and put them in place setters and getters it is let's grab the folder and we're going to open this in video studio code by dragging and dropping here this is going to open our folder we're going to open our main cpp file and we're going to clean it up a little bit we are going to grab the cylinder class from our previous lecture and use that as a starting point here and if you look we have a pair of constructors here we have the volume function which is going to give us the volume of our cylinder here and we have our member variables now what we want to do is to be able to do things with these member variables from the outside in the main function here and we're going to go through setter and getter methods which must be public so let's do that so we're going to set up our getter first so we're going to say double get base radius it's going to return double it's not going to take anything and and in the body we're just going to return our radius let's return that okay so we're going to set up another getter which is going to give us the height and it's not going to take anything and it's going to just return our height member variable now these are our getters they are going to be getting things from the class object we're going to set up other functions that are going to be our setters they're not going to return anything and we're going to say set base radius and it's going to take a double parameter in and we're going to use that to set our base radius so we're going to say base radius and we're going to say equals red parameter here and we're going to do the same for our height so it's not going to return anything the function here and we're going to say set height and we're going to take our parameter n so i'm going to say double height param and we're going to use that to assign stuff to our member variable we're going to say hi and we're going to say height param okay so this is our thing here now we have two functions to get stuff from our class and we have two functions to set data to our member variables here and again remember that we can't have direct access to these member variables on the outside of the class and if we want to do that we're going to be able to do that through our setter and getter functions now for these functions", "75897.28 - 76195.68000000001": "from the outside they needed to leave in the public section of our class you see this public keyword here is going to apply to anything after it until we change this to private software so the public scope is basically going from the constructors here all the way to our set height function and once we put this private keyword here everything after that is going to be private this is how these things work so let's try and use this in main we're going to set up a cylinder object cylinder one and let's put in for example two and three why not and now if we want to have access to the base radius remember if we tried to access that directly let's say that if we try to do something like cylinder one and say base radius you're going to see that we're going to have a squiggly line meaning that there's something wrong with our call here let's bring up a terminal and see what visual studio code thinks about this membership base radius declared this inaccessible here if we try to weld we probably going to get a compiler error that says that base radius is private in this scope and that's what we have here declare the private here so we can't access this from the main function here but now that we have our getter functions we can go through them and have access to private member variables and notice that because we are returning by value here what return is going to be a copy you really need to keep an eye for whether what you are manipulating is the original stuff or a copy so here we're going to be returning by value and we're going to return a copy but this is still useful in some cases so here we can use allocator let's take out this here and say get base radius it is a method or a function so we need to put our function call here and now if we try to build let's pass this through gcc and see what we get you see the build is good we can run this program let's clear and run rooster you're going to see that the base radius is two now now that we have this sense we can actually modify stuff about our cylinder here let's put in 10 and 10 just to be able to follow this easily and we're going to print the volume let's say volume and we're going to say volume here we're not going to use the getter here i'm going to say volume this is going to print our volume but we're going to modify our member variables remember this is an object of our cylinder class so we're going to say cylinder 1 set base radius we can do that and we can change this to 100 for example and we can change the height that height we can use this member function because we have it now and we're going to set this to 10 why not now if we print the volume you're going to see that the volume has changed because we are going through our public setter and getters methods so the cylinder is now going to be using this data and for the first case here the cylinder is going to be using the data we used in our constructor here let's both and run this application the build is good we can clear and run rooster now for the first time we're going to see that our volume is this number and for the second time our volume is going to be multiplied by 10 because we changed the base radius to 100 and if you put these numbers in you're going to see that they make sense we are able to modify our member variables through our setter and getter functions and again for this setter and getter functions to work they have to be in the public scope of your class because if you make them private they're not going to be accessible from the outside and you're going to get a compiler error let's try and do that we are learning so we're not afraid to break things a little bit so let's make them private we can do that and bring this a little bit to the left and at the moment we do that we should have a few squiggly lines in our main function and we do expect this because they are private now so we have no business accessing them from the main function like this they are meant to be used from the inside of the class if they are private like this and if you try to use them from the outside you're going to get a compiler error let's pass this through gcc to really see the compiler error and we're going to get set height is private from the context of the main function and if we go up i think we're going to see the same thing for a set base radius and that's here this is really all we set out to do in this lecture showing you how you can use setters and getters to manipulate your member variables from the outside and i hope you found this useful we are going to stop here in this lecture in the next one we're going to show you how you can split your class across multiple files but before i let you go let's fix this so that we don't have a compiler", "76195.68000000001 - 76497.68": "private keyword we have put here and we're going to build again to make sure the world is good let's use gcc for that the world is good and i will see you in the next lecture go ahead and finish up here and meet me there in this lecture i am going to show you how we can split our class information across multiple files so far what we have been doing is really cramping everything in the main function we had our constant declaration we had our cylinder class definition and we had our main function to use these things all cramped into the main cpp file now we're going to see how we can do things better the first thing we can do is move our constant in another file because if you think about it users of your class in the main function don't care about this constant pi because it really is an implementation detail that should leave somewhere else or even inside the cylinder class but we're going to put this in a separate file because that's going to give us room to put as a constant if we need to do that so if we split things up like this when we want to use the pi variable we will need to include the constants file because that's going to give us access to it but we don't have to maintain it in the main function so this is a little better but another thing we can do is remove the cylinder in another separate file and do something like this so now you see that our cylinder declaration and definition has moved in a file called cylinder.h and we have our constant pi living in another file called constants.h and if we want to use our cylinder class like we have been using it all along we will need to include the header that brings it in and this is how we're going to do it and we will be able to use it in the main function if we set things up like this but we can go even further we can split our class declaration and definition in two separate files what we're going to have in the header is going to be really a preview of the class and in the cpp file which is going to be called cylinder.cpp we're going to have the implementation details of our class and again this is going to make things a little easier to manage because it's really not good to have everything cramped into your main cpp file it should really have high level details about how your application works and all the low level details should be split into different files this is good design now that you have an idea about this let's head over to visual studio code and show you how you can do this okay here we are in our working folder the current project is class across multiple files we're going to grab our template files and put them in place and we're going to open this in visual studio code so that we can really play with us this is going to open our folder we can open the main cpp file we are going to clean it up a little bit and we are going to grab our class definition and put that on top here so this is our cylinder class we have the constructors we have the functions the volume function here and we have our setters and getters inside down we have our member variables which happen to be private to this class here now what we want to do is to organize our code better and the first thing we need to do is to move this constant from the main file here because it's really not that useful at this point here users of your classes won't really care about what pi is because it is an implementation detail to the cylinder class because we are using that to compute our volume so this constant really has no business being in the main file we're going to move this in a separate file we're going to set up a new file we're going to come to the left here click on the plus icon here that says new file we're going to say constants and we're going to call this constants.h because it's going to be a header file and we can just come from the main cpp file we're going to copy this we're going to cut this actually and we're going to put this in our separate file which is constants.h after we do this we're going to come in our main cpp file and we're going to include that header file so let's do that we're going to include constants.h and the moment we do that you're going to see now visual studio code knows where this constant is but we don't have to deal with that directly here another benefit of doing things like this is that we can go in this header file and declare thousands of other constants and we can have access to them in the main function by just using this single line that includes our file here so this is good design if we build our application you're going to see that it is going to", "76497.68 - 76796.16": "object we're going to say cylinder 1 and we're going to put 10 and 10 n as our parameters and we're going to print the volume of this little guy so this is easy to do now we're going to say volume and we're going to print that out cylinder one and we're going to call the volume method and this is going to print our thumb and again i am going to be using the terms functions and methods interchangeably in this course and what i mean in the context of the class that's going to be the member functions of the class so don't be confused by this right here if we build and run this application it should be working right because we have everything we need for it to work let's see if the world was good the build was good we can bring up a terminal and actually run this let's clear and run rooster this is going to print our volume so the code is working right the second thing we want to do is to move this class all together in another file because we don't really want to see it here in the main function what we really want is to use stuff and we don't care about how those things are set up in the same logic we used when we used std strength we didn't really care about how hdd strength is put together all we really wanted was to include the class that brings it in and use it in our code we're going to be setting up the same behavior for our cylinder class here and it is going to be given in its own separate file so let's set up another header file we're going to call this cylinder dot h and we're going to grab our class definition all together so we're going to go from the bottom here and select everything that includes our class we're going to cut this out we're going to go in our cylinder header and we're going to paste this in there and we're going to come back to our main file and include our cylinder class so let's do that we're going to include and we're going to say cylinder.h and this is going to make things work remember the preprocessor is going to put these things on the preprocessor is basically going to go in constants it's going to take whatever is inside and then it's going to paste that here and it's going to take everything inside our cylinder class and it's going to paste that here so it's basically going to be like we are declaring these things in the main function but our code is going to be better organized now if we try to build this program it is going to world exactly like it did because we have all the information for its world let's build world has finished successfully so the world is good and we can run this program and it's going to do what it was doing all along we can clear and run rooster don't worry about visual studio code here i don't know what the problem is with that it's just having ah it's having a problem with the pi constant here because it's not included in here so what we can do is say include and include our constants header and if we do this the problem here is going to go away but we're going to have a problem if we're trying to run this program now because try to think about it in the main function we are including the constants header and in the header of cylinder we are also including this little guy here so if the processor comes it's going to include this and it's going to have this little guy inside our main function and the cylinder is also going to include this because it's including this header so when the preprocessor is done we're going to have our constant here declared twice and if we try to build this program you can expect bad things to happen because it's really not good to have the same thing defined more than once in your entire program and let's try and build and show you this hopefully we're going to get a compiler error and it's going to blow up in our face it's going to say hero redefinition of const double pi so what is going on here we are including this thing twice once here and at the second time it's coming in directly from the cylinder class because we are including that in this location here and what the preprocessor is basically going to do it's going to copy the entire file here and it's going to paste that in the place of cylinder.h here and this constants header is basically going to be included twice so it's going to be redefined here that's the problem we have one way we have to solve this in c plus plus is by using include chords and the way we do that we come in our constants header and we say pound if and def this is a way to say if something is not defined yet and let's say cylinder underscore h and we're going to say define", "76796.16 - 77095.12000000001": "come down to the end and say and f this is a way we have to tell the preprocessor to only do something or include the code we have within these things if the condition on top here is satisfied so for example the code inside here is going to be put in our c plus source file if the cylinder name here is not defined in the eyes of the preprocessor so it's going to say if cylinder underscore h is not defined i am going to define that and i am going to put this code here but if it's already defined it's going to skip all these things and it's not going to include this okay so this is the logic here and i noticed this is really not a cylinder file so we're going to change this to constants underscore h let's say that and let's do the same here and this is going to do our thing and we're going to go in our cylinder header and do the same thing and put in our include guard it is basically a guard that is going to guard against something being included more than once so let's do that in our cylinder header so we're going to wrap this inside our include guards we're going to say if n def you see visual studio code is really helping out here and we're going to put in the name we're going to use for this this is a cylinder class so i think it makes sense to call this cylinder underscore h and we're going to do the same thing here define cylinder and we're going to end f at the end of the file here so we're going to say end f and again this is the syntax of the preprocessor i don't want to get too much into this because we will learn about this later in the course but we can now use this to guard against something being included more than once and if we're trying to build the program now hopefully it's going to world let's use the gcc and now you see that the world is good even if we are including the constant header multiple times in the main file here we can even go down and do that like a thousand times so let's do that and you're going to see that if we try to compile it is going to boil define because now we have a guard guarding against including this thing more than once the preprocessor is basically going to come in here and say if the constant's name is not defined i'm going to define that name and i am going to put the code here in the source file that includes me if it happens to be already defined this condition here is going to fail it's not going to do any more than in this file the preprocessor is basically going to give up on this file here this is what i want you to know so now we should be able to split our code into multiple files and now that i think about it we don't really need to include the constants header here because it's going to be broadened by the cylinder class but it was a good opportunity to teach you about the include guards here now that you notice we're going to remove this and we're going to build and show you that this is going to work anyway so weld is good we can run our program clear and run rooster this is going to work the last thing i want to show you is that we can go even further and split our class into two separate files because people who come to the header file are usually interested in your class definition they are really not interested in your implementation details for example they want to see that you have a volume function and they want to know that they can call that function but they don't really want to know how you compute your volume and we can really make events simple for them and hide the implementation details in a separate cpp file so let's do that we're going to set up a new cpp file we're going to call this cylinder that's cpp and we're going to move the implementations of our functions in the cpp file and i am doing this just to show you that it is possible in practice you're going to have to decide for yourself what you want to keep in the header file and what you want to keep in the cpp file so the cylinder default constructor here is going to stay this way but we can move the other constructor here in the cpp file and the way we do that we're going to just grab this and i am going to change this line by line so that you can see this and in the cpp file the first thing we want to do is to include the cylinder header because the implementations here are going to be using this and we're going to put in our constructor and modify it to be fit for living in a cpp file so let's come here and do that the way we tell this that this is really an implementation of a function we have in our header here is to put the class name in front we're going to say cylinder and put two", "77095.12000000001 - 77395.6": "compiler is going to know that this is an implementation of a function we have in our header file and this is the function here and now we can take out the body here and live this as a prototype for the function which is our constructor view we can do this okay if we do this in world the code is going to world it's going to construct our objects let's go back in main cpb and make sure that that's the constructor we are using it is we can weld and make sure that what we just did didn't break anything we are building and we can clear things up a little bit and run rooster this is going to give us our volume and we have started to split things up in our class here some things are going to leave in the header file some other things are going to leave in the implementation file so we have moved our constructor here let's move the volume function we can grab it and i move things line by line i think this is the best way to learn and i think we can move this things a little bit to the left let's do that and we're going to say that this is a function implementation for some function that is declared in the class here so we're going to say cylinder and we're going to put two columns this is going to tell the compiler this is an implementation of the function we have in our class and the return type has to live in front of this scope resolution operator okay what we have here cylinder column column is called the scope resolution operator and is basically telling the compiler that our function called volume leaves in the scope of the cylinder class this is what the syntax here is saying and this little thing here is called a scope resolution operator okay so we have moved our volume function we can now take the body out from the class and keep the prototype here we can go down and really practice on the setters and gators so let's do that so we're going to grab them all together because now you have the gist about how this works we can copy them and move them into the cpp file and we're going to fix the code lined by line here so let's make sure they are aligned properly we have two left to do let's do that and i really have to show you this life because some people are going to have problems regarding how i did this so i want you to see this live as i do this i'm not going to edit this out so we're going to put our scope resolution operator after our return type here i'm going to say cylinder cylinder can't type can i okay we have this in and we can really copy this and paste this into place wherever it is needed so i'm going to paste that here i am going to paste that here and i am going to paste that here now we have successfully moved all the functions in the implementation file cylinder.cpp and we can go back in our header and remove the bodies because we don't need them here if we keep them here we're going to have two definitions for this functions and we're going to have compiler errors let's take this out we're going to take the body out we're going to take the body out and we're going to take the body out let's do that for a gate base radius here and now if we build our program it should work we're going to work with gcc see the world is good and if we try to run the program it should give us what it was given before this is the volume here one thing i want you to see is that you don't want to keep two definitions for your functions so for example we can grab the body here and bring this back in the header file i want you to see what's going to happen if you do that i am going to paste that in here and i am going to move things a little bit to the right to align things properly here so if we do this the compiler is going to see that we are calling that constructor and the compiler is going to have no problem with us but once we hit the linker stage the linker is going to find that we have two definitions for the constructor here we have one in the header and we have one in the implementation file and this is going to raise a compiler error saying we have two definitions for the constructor here and the linker want to know which one to use so it's going to give you an error let's build and really show you this because this can be hard to debug if you don't know what is happening okay you see we have world finished with errors and the problem is cylinder cylinder double double is redefined we don't want to have two definitions for the sum function so once you move things from header to implementation file be sure you don't have any more definitions left in the header or you're going to have really hard to debug problems and now i think we have our program", "77395.6 - 77697.12": "so far about c plus plus we have our constants living in another header file and we have learnt about include cards what we can use to guard against our stuff being included more than once by the preprocessor we have our cylinder class living in its own file and again we have an include guard here and you can see that this class now is really easy to look at we can look at the information about the member functions we have for example we have a default constructor we have a constructor that takes two parameters but we don't see the details about how these things do their jobs for example we don't see the details about how the volume is computed those details are hidden in the cpp file and if you want to see them you need to go to this implementation file here this is a good design and i encourage to split your c plus plus programs in multiple files like this this is going to make your life easier in this lecture we're going to see how we can manage our class objects through pointers and in most cases we need to manage our class object through pointers if we are using some form of dynamic memory allocation here is a simple example we have our cylinder class included and down here you see that we can create cylinder objects on the stack if we use the syntax like we do here the objects are going to be created on the stack and we have seen that we can access the behaviors or data inside our class object using the data notation like we do here for example here we are calling our volume function but sometimes we want to manage our objects through pointers for example if you look at the syntax we have here we are saying cylinder and using the asterisk here this is going to say that this is going to be a pointer to a cylinder type and i'm going to give it a name c2 and we can allocate our object on the heap using the new operator this is going to dynamically allocate space from the heap and that memory space is going to be used to store our cylinder object now the interesting thing is going to happen when you try to access behaviors from your cylinder object here for example if we look at this line here we are trying to print the volume of this cylinder and you notice that we have to go through ugly dereferencing here we have to dereference the object and then call our method through the dot operator here but what i want you to see is that we can avoid this ugly the reference that we are doing here and use the pointer access notation this dash greater than symbol you see here is going to allow us to access stuff directly using the pointer to an object that is dynamically allocated on the hip okay after we are done using our cylinder object remember it is memory that was dynamically allocated from the hip we have to release the memory so that it can be used by the operating system and we release the memory using the delete operator as we do here okay the idea i wanted to introduce here is that we can use players to manage our cylinder objects and this is one way we can do this and once we are using a pointer as a handle to our cylinder object we can use the pointer access operator here to access stuff from our class objects easily and another thing you should know is that we can actually create a cylinder object and store in the address of objects that we have on the stack and we're going to see this in a minute when we hit visual studio code now that you have an idea about this let's head over to visual studio code and play with this a little more okay here we are in our working folder the current project is managing class objects through pointers we can see the entire name here and now we're not going to grab our template project because we want to start from the project we had in this lecture on a class across multiple files so we're going to go in that project and grab everything from there except for the executable because we obviously don't want this and we're going to go in our current project and paste in the code and this is going to give us a good starting point so we can grab this and open this project in visual studio code it's going to open the folder and we're going to have everything we want to start doing what we want to do in this lecture here so now we should have access to our cylinder class and if you look here we have an object of cylinder type already created by this line on liner number six here and we have seen that we can use the syntax like cylinder volume here using the dot call operator to access stuff from our class object and this is", "77697.12 - 77996.8": "can use pointers to manage our object here and the first thing i want you to see is that we can manage a stack object through pointers and to really show this off let's set up a another variable it's going to be a cylinder pointer and it's going to be p cylinder one it's going to be a pointer to cylinder one here that's what i mean and we can give it an address of cylinder one as a value so we can do that for example and put in the address of operator and this is going to work now we can go through our pointer here and do stuff with this cylinder object but the syntax is going to be pretty ugly so for example let's try and print the volume of our cylinder we're going to say htdcl and say volume can save that and we're going to have to go through the dereference operator so if we do something like p cylinder one and try to use the dot operator you're going to see that we have the volume function but if we try to call it let's do that let's make sure we are using the dot operator here if we try to compile this program it's not going to compile because we are trying to call stuff from a pointer and remember a pointer is just going to store an address it doesn't really have information about the type that it is pointing to if we try to compile this program we're going to get a compiler error so let's use gcc to do that and we're going to get request for member volume in pc lender 1. remember p cylinder 1 is just a pointer it's not an object so we can't really call the volume function to f if we want to use the dot call operator here we have to the reference and actually get to the actual object that the pointer is pointing to and we do that using the star operator you already know how to dereference a pointer so we can dereference our pointer and then call the volume function on what the pointer is pointing to and this is going to work it's going to print out volume let's build now now that we are dereferencing correctly and you see that this is going to work and if we try to print this let's bring up a terminal so that we can run this program let's run rooster you're going to see that we have our volume here so to really get to what is pointed to you need to use the reference operator and then call whatever method you want to call on your object but we can do things even easier there is a syntax we can use to use the pointer directly here because going through all this dereferencing ugliness is really not cool so we're going to grab this and show you that we can use the dash greater than operator that's how i called it and if we use that we don't need to the reference all we need to do is use the dash greater than symbol here and it's going to directly tell the compiler don't code stuff on the pointer directly do the reference the pointer internally and then call the volume function on whatever you get after referencing so this is basically going to push the the referencing ugliness here behind the curtains of the compiler and we can use a nice syntax like this and i think this is much better than what we were doing here so if we try to bolt now we're going to build and print our volume you're going to see the bolt is good you can clear and run rooster you see we see our volume here so this is what i want you to see it is possible to manage your cylinder objects through pointers and this is one way we can do this by managing a stack object through pointers and this is what we are doing here if you want to call stuff on your class object you can either do the ugly stuff we do here or you can use the nice pointer access operator and it is going to be cool okay now that we have seen this let's see another use case in which we're going to be creating a cylinder object on the heap through the new operator okay we can go down and save that we're going to say cylinder pointer it's going to be p c lender 2. we can call it like this and then we're going to say new cylinder and you're going to see that we can call a constructor we have two types of constructors we can call we're going to call our constructor that takes two parameters and we can pass in 100 and 100 why not oh let's put the two after here we can put in whatever we want this is going to create a new cylinder object the space for the cylinder object is going to be allocated on the hip so this is a hip object and because we are using the new operator here the other thing you should have in mind is that you will need to release this memory and let's go and do that directly this is a good practice because you will", "77996.8 - 78295.76": "don't really keep this in mind so we are going to delete p cylinder 2 because that's what we used to allocate our hip memory here okay now that we have taken care of memory management we can go in and use our p cylinder to object and for example we can print its volume by using the stdc out statement here so let's go down and save that let's align this properly and we're going to say volume cylinder 2 to really make this super clear and then we're going to say p cylinder 2 and call the volume function here this is going to work let's draw in world the world is good we can clear and run rooster this is going to give us our volume and if we try and use this information to create a cylinder we're going to see that the volume is what we see here we can even try and print its base radius let's do that we're going to say sdd cl we're going to say p cylinder 2 and we're going to say base radius we can hit the dot operator here you're going to see we're going to have a few options in a visual studio code here if we double click on get base radius here you're going to see that visual studio code is going to use the pointer access operator here and this is really cool so we can hit std and yeah we can close the left pane here because we need some more breathing space and if we try to build and run this program and we have a compiler error here and the reason is get base radius is a function if we go back in our cylinder class we see that we have a function called get base radius so if we want to call this in the main function we need to call that as a function so we need to put a pair of parentheses here and if we build we should build without a problem let's do that again you see the build is good and if we run the program we're going to see exactly what we expect let's run a rooster we're going to see what we expect here and the message here was really that you can manage your class object through pointers one case is when you have a pointer that is pointing to a stack object and we saw that we could do that here we can also use pointer notation to allocate objects on the heap and point to them with our pointer here and whenever we are using a pointer we have the option to use the pointer call operator here to do things easily i am going to be calling this the pointer call operator to mean this from here on if we happen to need this and you should know what i mean by that this is really all i set out to share in this lecture i hope you found it interesting we are going to stop here in this lecture the next one we're going to learn about these structures go ahead and finish up here and meet me there in this lecture we're going to learn about these structures these structures are spatial functions or methods in a class that are called by the compiler to destroy your object and these are going to be especially useful if you are for example allocating memory in your constructors let's look at the simple example here we have a class called dog it has two sections the public section and the private section in the public section we have two constructors a default constructor that doesn't take any parameter and a constructor that takes two parameters n the parameters are going to be used to initialize our member variables and they are passed by a value here for simplicity and they are going to be used to initialize these member variables doug name dog breed and dog age the special thing about this class is that it has a destructor and you declare the destructor using this syntax here he puts a tilde character in front you say the name of the class and then you put an empty parameter list it is also possible to declare a destructor and put in its entire body in the header and this is the syntax to do this inside the body you're going to do whatever it is you need to destroy your object for example if the class here is allocating some memory in the constructor the destructor is the best place to release that and this is an example of how you can do that here is a more direct example of how we allocate for dynamic memory in the constructor and release that memory in the destructor we have our three variables but we have chosen to allocate our dog edge variable on the heap using dynamic memory allocation and after we dynamically allocate a piece of memory to store our age variable we're going to set that to 0 because we are in a constructor if we are using the three", "78295.76 - 78596.31999999999": "the past parameter to initialize our age variable but the important thing here is that it is being dynamically educated memory on the hip here and when our object dies we need to remember to release that memory and the destructor is the best place to release that memory as you see here we say delete dark age when our object dies and the compiler is going to call this function when it's about to kill the object so you might ask when are destructors really called we are going to start by looking at obvious cases here for example when a local stack object goes out of scope the destructor is going to be called because that object is going to be wiped out from memory so this is an obvious case in which the compiler will need to call a destructor also when a hip object is released from memory using delete the destructor is also going to be called but there are some indirect ways in which the structures are also called for example when an object is passed by a value to a function this is going to call the destructor to kill the object when the object goes out of scope in the function because when an object is passed by value we're going to have a copy in the local scope of the function and when the function exits that local copy is going to be killed and we're going to see an example of that another case where you might have the the structure called is when a local object is returned from a function another copy is going to be created to be used outside the function and the copy inside the function is going to be killed but this is not guaranteed as some compiler may optimize your return value and use some kind of reference so you're not guaranteed to see this behavior but it is possible to see it now that you have an idea about destructors it's time we headed over to visual studio code and play with us a little more okay here we are in our working folder the current project is the structures we're going to grab our template files pretty quick and we're going to put them in place and after that we're going to open our folder in visual studio code by dragging and dropping here this is going to open our folder and we will see our main cpp file here we can open it and i clean up and remove what we don't need we have an unneeded breakpoint here we can remove that and we're going to clean up the main function the first thing we want to do is to put in our dog class i am going to just put this in here because i don't want you to watch me type all this that's just going to waste your time we have two sections in the dog class we have a public section which is going to now contain our constructors and we have a private section which is going to contain three member variables we have two strengths one for the name and the other for the breed of our dog and we have another one which is an end pointer which is going to store the edge of the dog and you see that this is initialized to no pointer one thing you should notice is that for our parameter taken constructor we are passing the string information here using string views to avoid copies with the std string view type you already know this because we learned about this but for this to work we will need to include a string view so let's do that and now we have our class and we can use it however we want so but before we do we need to put in the implementations for these functions one way we can do that is do that directly in the function here but i want you to see that you can also do that directly outside the class here i don't think i have shown you this but it is possible to do that so we're going to grab the prototype for our constructor and say the scope resolution operator and we're going to just paste in what we have copied which is the prototype here and we're going to go inside put in our body and in the body we're going to initialize these three guys so the name is going to be initialized to nem param and the bridge is going to be initialized to breed the param we can do that and the age is going to be dynamically allocated from the hip you see that it is a pointer so we're going to say ph equals new and because we're going to allocate dynamic space to store an end and we're going to put data in using our good old dereference operator we're going to say ph equals whatever ph parameter they passed and i think we should say edge here because it's not a pointer so we're going to say age i think this is going to do better age param this is probably going to be better and we're going to say age param okay so now we have our constructor n and it's going to allocate memory from the heap and we're going to", "78596.31999999999 - 78896.552": "that has just been allocated to our class here so this is our class and we can go in the main function and really use it however we want for example we can set up a dog object so we're going to say my dog and we're going to give it a name the name is going to be fluffy and we're going to put the breed in and it's going to just be a shepherd and we're going to put in the age which is going to be for example a 2. let's say our dog is 2 years old this is valid c plus plus code it's going to be setting up an object of our class here and we can world to see that this program is going to world without a problem so both is good but if we run the program we're not going to see anything but we don't really need to see our constructor here called because we already know about constructors what we want to learn about are these structures and these are spatial methods that are called by the compiler when your object dies let's set up a destructor and see it called when our dog objects die the syntax to do that is to use the tilde character here you're going to say the name of the class you're going to put an empty parameter list and if you want you can put a body and do whatever you want to do in the body of your destructor here but again we're going to move the entire definition of the destructor to the outside so let's go down and save that we're going to say the scope resolution operator we're going to say dog and we're going to put in our body and the first thing we want to do in our destructor is to release this memory that was dynamically allocated for us if we don't release it when this dark object dies we're going to link memory and that's really bad so let's do that directly in the destructor we can say delete and say ph this is going to release the memory that was allocated in the constructor here and we have access to this ph variable because the destructor is part of our class any member function of your class is going to have access to any member variable even if it happens to be private okay so we forgot our tilde character let's put that in here and this is going to be valid c plus plus code but to really see things happening here let's put in an sddc out statement we're going to say doug destructor called 4 and we're going to say the name of the dog let's say name and we're going to say the same thing in the constructor we're going to say hddcl and say dog constructor cold for and we're going to say the dog name going to use our member variable and now we have our thing in place we have the destructor declared in the class definition and this is the syntax again this is what we really want to learn about in this lecture we have the tilde character we have the class name and we put an empty parameter list let me tell you that it is not possible to pass parameters to your destructor if you do that you're going to get a compiler error the structures will always have no parameters in c plus plus here we have the definition of our destructor and it is going to release whatever memory we have dynamically allocated from the constructor here if we run this program we're going to see our constructor called as a result of this line here because we are constructing a dog object and we're going to see the destructor called when the main function is about to end let's put an stdc out state to mention the main function here and say done just to prove that we have hit the end of our main function here i think this is useful and we're going to build so let's do that we're going to build with gcc you're going to see that the world is good so we can clear and run or program let's hit enter here and clear and run rooster you're going to see that the constructor was called we are going to say done when the main function is about to end but before the main function ends we're going to destroy any stack data that we have in the main function and our dog object is on the stats so it's going to be destroyed as part of that process and the destructor for dog is going to be called and we're going to release our memory and we're going to say that dog destructor was called for whatever name we have assigned to our dog here so this is how destructors are called when your objects are killed and we didn't put in the correct name we said fluffy let's say fluffy because that's what i wanted and now you see that our destructor is really being called and releasing memory however we want but we can also go a little further and show you another example of a case where the structures are called and we're going to look at a function that sets up a local object of a dog we're going to see the dog constructed and we're going to see it destroyed when the", "78896.552 - 79196.71999999999": "we're going to say void some funk and it's going to be just some function to play with us we're going to move our dog declaration in some funk here and this is really it we're going to call this function and when we call it we're going to construct the object here when the function is about to end the compiler is going to call the destructor because it's going to destroy this object here and we're going to see the destructor called by that point the some funk function is going to be popped off the top of the stack we're going to hit the main function here and we're going to say done and the program is going to end let's call some funky name here so we're going to say some funk and we're going to world to really see this happening so we have worked successfully we can clear clear properly and run rooster we're going to see constructor called for fluffy the structure called for fluffy and you see done we have hit the main function and really finished executing our program here we can even see this through the debugger we're going to set up three break points one in the main function here before we call the some funk function we're going to set up another one in our destructor before we print the message here and we're going to put another one in the constructor when we are about to print this message here on line 20. after we set up these break points we kind of kill the terminal here and minimize a little bit let's kill these things here so that we have a clean ah we have a lot of windows here okay we have our editor here and now if we go to the tab here that says start or run we're going to be able to click the green button here to start our debugging session we are going to have a terminal here so let's bring that to the side so that we can see things printed out nicely let's do like this and now we have hit the break point in the main function we can step into the sum func function and we're going to do that using the step into button here let's click that we're going to jump into some funk now we have the option to step into but this is going to jump us into the logic of transforming the string literal here into a string view because if you see the constructor is going to take string view parameters we can actually see this let's try and hit the step into button you see that we are in the string view class and we don't really want this so let's step out and we're going to step over this so that we can hit the next breakpoint and you see the next breakpoint is in our constructor and this proves that the compiler is going to call our constructor here to build our object if we step over this we're going to print the message from the constructor and if we keep going we're going to get out of our constructor and you see where this is going to go this is going to go in the destructor because before we leave the some func function our dot objects is going to be destroyed so we're going to release our memory and we're going to branch the message from our constructor and if we hit next and a step out of this i think we can do that because this is logic we don't want we're going to try and step over this and now if we hit next we're going to come back in some funk and some funk is already going to be finished and if we hit next we're going to come back in main and we're going to print done and the program is basically going to be done hopefully you can see that the compiler is going to call our destructor after it leaves some funk here because it's going to be destroying the local object that we have inside some funk here so this is one case where the destructor is going to be called by the compiler and it is if you have a local object that needs to be destroyed when function scope finishes another case where the destructor may be called is if you pass a class object parameter by value so let's change some function here and make it take something by value so we're going to pass a dog inside and we're going to say dog param this is going to do okay now that we have changed some func here we can really do all kinds of crazy things with it for example we can set up our dog object inside our main function here so let's do that we can say dog and dog the variable name is going to be dog we can give it a name which is going to be fluffy it's going to have a breed of shepherd and we can give it the age of 2 like we have been doing all along we can call our function with the dog object here but be careful about what is going to happen here when we do something like this we're going to be passing by value and", "79196.71999999999 - 79496.40000000001": "needs to copy a dog object now we haven't really told our class here how to copy dog objects and we do that through constructors we call copy constructors we haven't really learned about yet but what the compiler is going to do by default is copy these things member by member so it's going to set up a doug copy object which is going to be initialized with empty strings and a null pointer here and then it's going to copy from our dog object that we have here it's going to take the name and copy that in the name member variable of our dark copy it's going to take the breed and copy that n in the second member variable here and it's going to take the age from our dog and copy that in the problem is going to come to this pointer here it's going to copy the address and it's not going to copy what it's pointed to and this is going to be a recipe for a disaster i don't really want to go through this right now but if we try to run this program it's not going to work like we expect for example if we pass fluffy here we're going to see things that we don't expect so let's try to build we're going to build with gcc and the bolt is good so what we expect is to have the constructor of fluffy here called and we're going to copy the dot object for use in some funk here and to set up this copy it's not this constructor here that is going to be called so it's not our constructor here which is going to be called so we're not going to see this called for the copy that we set up inside some funk another thing is because now these two dog objects are pointing to the same thing because what we just copied is the address as we see in our member variable here the two dog objects are going to be pointing to the same thing in memory and when we hit the destructor we're going to call delete twice and this is going to be a recipe for disaster our application could really crash you already know that deleting a pointer twice is really bad we shouldn't do this and we are doing this here because we are copying i realize this is a slightly confusing example but what i want you to know is that if you pass a class object by value like this the copy you have inside is going to cause for the destructor to be called when the function exits because the copy is going to be scoped inside the function here so let's take out this example because it really is confusing but i hope you know that and i am going to show you that another case where you might see the destructor called is when you call the destructor explicitly using the delete operator on your object so we can set up some func again let's do that some funk and we're going to repurpose it and inside we're going to set up a dag object so let's grab this and reuse that in our function here and we're going to say dog pointer so let's say dog pointer we're going to say p dog p underscore dog it's going to be equals to new dog and we're going to pass in what we need to initialize our dog object with this is going to create a dark object on the hip and it is going to be pointed to by p dog here now i want you to see that if we don't explicitly release the memory that we allocate through the new operator we're going to leak memory so we created an object on the hip here but we're not deleting that in some funk when some funk exits we're going to lose this pointer this variable because it is on the stack itself and we won't have any way to release this memory let's call some funk here and really show you this so we're going to call some funk and we're going to build let's use gcc for that the build is good we can bring this up a little bit and clear and run rooster we're going to see that the constructor for fluffy was called because of this new operator but we didn't see the destructor called and this is really bad so for the destructor to be called we need to explicitly release the memory in this function here and we do that by using the delete keyword and saying the pointer that is pointing to the memory that we want to release if we do this this is going to cause for the the structure of doubt to be called and if we run we're going to see our destructor called let's do that we're going to use gcc the bolt is good you can clear and run rooster now you see that the constructor is called full fluffy and we have the destructor cold this is really all i wanted to share with you in this lecture i apologize if you found it confusing but if you have any problem i am always available please do ask and i will do the best i can to help you out so the destructor is a special method which is going to be called when your object dies it is going to be called when an object is passed by a value to a", "79496.40000000001 - 79795.51199999999": "it's going to be called when a local object is returned from a function by value but this is going to be compiler dependent because some compilers are going to optimize this out and make it look like when you returned by reference so i don't want to go into this because this is subject to compiler optimization but other cases where you're going to have your destructor called is when a local stack object goes out of scope and when a hip object is deleted through the delete key world this is really all i had to share in this lecture i hope you found it interesting we are going to stop here in this one and the next one we're going to see the order in which constructors and these structures are called and you really need to be aware of this go ahead and finish up here and meet me there and this lecture i wanted to raise your awareness on the order in which constructors and the structures are called suppose we have our class which is dug here and we have the constructor which is doing its thing in the body here and we have the destructor which is releasing our memory and printing something out so suppose we have created a few objects of this class here and they have different names and they have the same breed and different edges as you see here and if we run this code in main what do you think will see printed from the constructors and the destructors if you asked me and i was learning about c plus plus i would say that the constructors are going to be called in order dog one dog two dog three dog four they are going to be constructed in this order and the destructors would be called in the same order but this is not true the destructors are going to be called in the reverse order as you see on the right here so we're going to call this constructor for doug d1 delegate2w3 doge4 which is exactly what i expected but you're going to see that the destructors are going to be called in reverse order so the object that was constructed last is going to be destroyed first as you see here and the object that was constructed first is going to be destroyed last and the compiler follows this order to make it easy for it to do things we can't really get into those details but for now we're going to head over to visual studio code and play with us a little more okay here we are in our working folder the current project is order of constructor and destructor calls here we're going to grab our template project pretty quick and we're going to put them in place the files i mean and we're going to open this in visual studio code like we have been doing all along this is going to open up our folder we can close the left sidebar here and let's clean up our main function we are going to bring in the class for dog from the last lecture this is exactly what we had there no change and we're going to include the string review library for this to work so we're going to include string view here and once we do this we're going to head over in the main function and set up a few objects of the dog class here but before we go there notice that we have a few htdc out statements in our constructor and destructor and we want to see the order in which they are called so we're going to set up four objects of our dog we're going to say dog dog one and we're going to say the name to be won and it's going to be a shepherd and it's going to be for example 2 years old why not we should say dog here and we are going to copy these four times here and we're going to call this dog 2 the other is going to be dog 3 and this is going to be dog 4 and i'm going to say the same thing here doggy two three and four the names are what is really important because we're going to see them printed out here but if you want you can change the ages let's make this a three let's make this a five let's make this a one why not for dougie for and now we're going to run our program if we run it we're going to see the constructors called in the order doggy one doggie 2 w3 dog e4 and the destructors are going to be called in the reverse order dogifur all the way to doggy one let's boil and show you that this is actually the case so the build is good we can bring up a terminal and really run this let's clear and run rooster you're going to see that dog constructor called for a doki one all the way to dog e4 and now we have the dagger destructor called from doge4 all the way to doge one and the compiler is going to enforce this order for calling constructors and destructors", "79795.51199999999 - 80096.64": "manage the memory of objects for example if duck one has been around for a long time and it has because it's going to be around before a dog one if you delete duck one after dog four here there might be other objects that depend on dog one so that's why the object that was created the last is deleted first because chances for other objects to depend on that last object are really slim and you can delete it without any problem but the object that was created first might have other dependencies and you're going to be deleting dependent object first before you delete that object i think this is the logic the compiler follows to really enforce this order here and you need to be aware of that and make sure that at any time in your c-plus plus application this is working to your advantage this is really all i had to share in this lecture i hope you found it interesting we are going to stop here in this one and the next one we're going to learn about the this pointer go ahead and finish up here and meet me there in this lecture we're going to learn about the this pointer and this is a special pointer that is maintained by c plus plus to really help you manipulate the current object and it is the current object for which a given method is being executed here is a simple example with our dog class and we're going to show some usefulness for the this pointer the first thing we're going to look at is the syntax for example here we might need to print the address in memory where the object was created and do that from the inside of the function and to do that we use the this pointer for example we can put out a message and we can do that through a statement like we have here we are printing dog dog name constructed at a given memory address and we use the this keyword to get the address of the character object for which a specific method or function is being called in this case it was the constructor of the dot object here we can also do the same thing for the other constructor and you see we are using the this pointer this is one of the uses you have for the this pointer again the this pointer is a special pointer that is maintained by the c plus plus system and it is going to be pointing to the current object that is being manipulated by the z plus plus run time and it's going to be manipulated through a special function of the class object that is being called this is the meaning here here is another use case for the this pointer it may be used to resolve conflicts when you have a parameter and a member variable that are named the same way for example here we are calling the set name function it has a parameter with a name doug name and it has a member variable called dog name so if you do a statement like we have on top here the compiler is going to be confused they're going to say dog name equals dog name and it won't really know which dog name you are referring to we can resolve this conflict by saying this and say pointer access notation and say dog name and this thing here is going to be the member variable and we're going to be assigning to the member variable from the parameter this is the meaning here and we can use the desperator to resolve such conflicts another use we have for use pointer is if we want to set up chained calls for example using pointers and we might need to do something like this so we have a dog pointer set up on top here and we can do something with our new object for example we can call a function called printful on a dog object after we print the information we're going to set some information on the doc and you see we are setting all of the information through one statement the way we achieve this our setters are going to be returning a pointer to the current object and we're going to be grabbing that return value and calling on it directly because it's a pointer and we are going to be using the pointer access notation so we're going to call set name set name is going to return a pointer we're going to use that pointer to say to the breed and set the breed is going to return a pointer we're going to use that pointer to set the age and after this entire line all the information is going to change about our dog and we can see that here and after we do whatever we want with our dog object we're going to release it from memory so this is another thing you can achieve using the this pointer and this is how you can set up these setters it is nothing complicated we have set name", "80096.64 - 80395.832": "we're going to return this okay and this is going to be a pointer or the memory address of the current object of the dog class we have the same setup for seti dog breed we return the dog pointer and we return this the same setup for set doug age we return a dog pointer and we return this we can do the same thing using references but our setup is going to be somewhat a little bit different we have our dog object here and we're going to do our change call here so we're going to say set name through the pointer because we have a dot pointer here but after that we're going to return a reference from the functions here so set name is going to return a reference we're going to go through that reference to set the breed set dog breed is going to return a reference and we are going to go through that reference to set the dog age and if we print the information now we're going to see that we have new information in our dog object and after we are done with our dog object we have to remember to release it from memory because it was allocated dynamically from the heap here is how you can set this up it really is nothing complicated we just have our setters and we are going to return a reference but before we return through the desperator we will need to dereference the displayer and get to the actual thing that is being pointed to that's why we have this star operator here and for the other setters we're going to do the same thing we're going to return a reference we're going to return a dereferenced version of this we're going to return a dog reference for set dog age and we're going to return a dereferenced this pointer because this is the reference we are returning here so this is what the this pointer is about now we're going to head over to visual studio code and play with us a little more okay here we are in our working folder the current project is the displayer we're going to grab our template files and we're going to put them in place and then we're going to open this in visual studio code by dragging and dropping here this is going to open our folder we're going to open the main cpp file and we're going to close the left sidebar here so that we have some more space to work with i am going to put in a version of our dog class it is pretty limited right now it just has a destructor and a constructor and a constructor and we have our member variables and we're going to tune this a little bit so that we can work with us however we want the first thing we want to do is to print the addresses of dug objects that we construct and destruct here and we're going to do that in our constructor so let's go to our hd dc out statement here and we're going to say add to mean the memory address where the object was constructed and we're going to say this so when we do this this is going to be the address in memory of the current object that is being constructed by our constructor here and we're going to say the same thing in our destructor we're going to say at and we're going to say the memory address where the current object is being destroyed from so after we do this if we go in the main function and for example set up a doug object we're going to say dark we're going to say dog one and we're going to give it the information we're going to give it the name which is going to be fluffy we're going to give it the breed which is going to be a shepherd and we're going to give it the age of two like we have been doing all along when we do something like this this is going to call the constructor because we are trying to set up an object and before the main function ends we're going to call the destructor and we're going to see things happening here let's say done so that we know that the code is actually running i'm going to say sddc out done here okay we have the setup done we can uh build and run the application we're going to use gcc to build and the build is good we can bring up a terminal to try and run the application and now if we run rooster we're going to see that dog constructor called for a fluffy at this memory location and the current object is this object here which is being constructed and we're going to have access to its memory through the this pointer hopefully you can see how powerful this is if we didn't have the this pointer the only way to get the address to this object would be to grab the address from the main function or from wherever we are setting up our object here but we have access to this address from the inside of the functions for the class and this is really cool so we can manipulate these addresses if we need to", "80395.832 - 80696.07999999999": "for this so suppose we need to set up setters for our class here so we need a setter to set the name the breed and to set the age here so let's set up our setters we're going to say setters and we're going to say void set name or let's be explicit set dog name that's going to be better and we're going to pass a string view we're going to say stds friend of you and we're going to say name program and we're going to put the bodies in our class here but i would encourage you to be consistent if you are doing this in real code we are learning here and we are taking some shortcuts so that we can do things simply but what we want to see now is what happens if we have a parameter named the same as a member variable so how do you set this name to the member variable called the name so if you have a case like this you're really going to be in trouble because if you say name equals name let's try this we should get a compiler error or a squiggly line because the compiler is not going to know which name are you using here is it the memorial is it the parameter it's not going to know and let's try to build and see what we get we're going to use the gcc and surprisingly gcc is taking this and it's probably knowing that we have a member variable named name and it's going to assign the parameter to that member variable so behind the scenes gcc is going to change this to this it's going to use this name equals name this is the syntax we want which is really not confusing but what we have on top here is going to be confusing and some compilers are not even going to take this let's leave this in and actually build it in with us i want to see that this actually works so we're going to weld successfully and if we go down in main and try to say dog one set dog name let's say pumbaa let's see what happens if we do something like this we're going to try and build again and gcc is going to take this and this is really cool so let's put in a function which is going to print information about our dog we can do that down here and it's going to return nothing it's going to be called print info and it's going to basically print the name of the breed and the age so it's going to say sddc out we're going to say the address where the dot object leaves i think that's more meaningful we're going to say this and then we're going to put a parenthesis and say the name i think we can put a an angle bracket here and say name and we're going to say the dog name we can go down and say the age or the breed and say the age and we're going to dereference the age member variable because it's a pointer we're going to say the reference ph here and i think this is going to be it now we can put a new line character std e ndm and if we go down now and say printable before we set the name we're going to say dub1 printful we're going to print the information about this dog and after we set the dog name we're going to go down and also say dog one principle you can play with these things and i really encourage you to do so so we're going to build this we're going to use gcc so the world is good we can clear and run rooster this is going to say the constructor was called for fluffy at the given address we're going to say the dog we're going to print the information and we're going to say it's a dog object at this address the name is fluffy and we're going to print the dog for the second time you're going to see that the name is still fluffy and we have a problem here why is that why is our object not being modified let's go up and see our set dog name function here so we're going to remove this and we're going to use the this pointer and we're going to weld again and let's clear now and run rooster and now you see that the changes are actually making sense so what is happening with the assignment here the compiler is assigning the value of the variable to the variable itself and this is really doing nothing and it is not what you expect i was fooled a little bit by the compiler because this was compiling but it's not going to do what you want when you call set doug name you probably want to take this name and assign that to the member variable name of this class but this is not what it's going to do let's build again and really show you this so it is a really good advice to practice and really try things out yourself we're going to run a rooster you're going to see that after we set the dog name here to pumbaa and we try to print the information the information is not going to be end the name is not going to be pumbaa for the second call", "80696.07999999999 - 80995.92": "doing nothing here this does nothing and you really need to know this if you want to affect your remember variable you will have to go through the this pointer and this is going to tell take the name member variable of the current object and assign the value in name the name parameter to that and that's going to set your name to whatever new name you passed when you called the set dog name function here so hopefully you really understand this now if we both are going to see that the pumbaa name has been applied let's boil again so we're going to clear and run rooster and we're going to see now that the name is pumbaa and there is some annoying thing we have in our constructors we don't have a space before at here and it is really annoying to look at here so let's build again and fix this we are going to use gcc the world is good we can clear and run rooster and now we have what we want so this is the second use case you might have for this pointer through setters let's use the parameter that is named the same as your member variables so we're going to set up all the other setters we're going to set up a setter for the breed we're going to say std strength view and it's going to be breed we can do that because now we have tools to really do this properly we're going to say this breed and we're going to say equals read this is going to do and we can set the age and we're going to say void set age dog age and we're going to pass in a value and we're going to go inside what is it called it's called ph i don't think it makes sense to call the parameter ph because it's not a pointer so we're going to go inside and just the reference of a pointer so we're going to dereference that and we're going to say this so we're going to go inside and say this ph equals h i think this is going to work and we need to reference this pointer because what we have as a member variable is the pointer so we need to go through the ugly syntax you see here and this is going to set our age so we can go through this and really change the information so we're going to change the breed here set dog breed let's go down and choose that and we're going to say wirefox terrier and we're going to go down and set the age we're going to say guilt 1 set dog age and we're going to say for why not so we change the information of our dog through our setters here and we're going to print new information let's build again we're going to use gcc for that the build is good we can clear and run rooster this is going to give us new information for the second print here so name is going to be pumba breed is going to be wirefox terrier and age is going to be four and we have the information for our dog object here okay now we have this and we want to see how we can set up chained calls using the this pointer and in this case we will be using pointers let's change our setters to return dog pointers we can do that and we're going to go down to say to dog breed we're going to return the dog pointer and we're going to go to set dog age and we're going to return a dog pointer now after we do this we will need to return these pointers and we're going to go inside and say return this remember this contains the memory of the current object so we can return this and fit that to a returned pointer so we can go down in all the other functions and really save this we're going to say return thus we return the memory address of the current object through the setters that we are doing here we're going to return this and after we do this we can change the setting we are doing here to b1 statement and we can comment this out i think we can do that and what we're going to say is dope one and we're going to say set dog name and we're going to pass in pumbaa but this is going to return a pointer now set dog name is returning a pointer to the current object and you can see that here this is what we are returning so we can go through this pointer and call some other functions for example we can say set dot breed directly and the visual studio code is going to figure out that what we are returning is a pointer and it's going to change our access notation here to a pointer axis notation and we're going to use this in one single statement so we're going to put in our breed and we're going to call the function to set the age okay you see that it uses pointer access notation and this is really cool so we're going to put in our four and you're going to see that this actually works and this is really cool if you don't want to do thanks in three steps you can give your users the option to do things in one step using returned pointers like this and this is really cool i use this all the time for my classes that i design in my applications", "80995.92 - 81297.192": "the world is good and we're going to clear and run rooster we're going to see that the information is n name is pumbaa breed is waterfox terrier and the age is for and we were able to do all these changes in one go so we can even change this to use references here we are using pointers so let's say that we are using pointers but we can also use references let's go on top here and say that this is using pointers and we're going to comment this out but before we do we're going to copy all this because we're going to need that and we're going to comment all this out and we're going to go down and say change calls using references and we're going to go down and put in our code and we're going to change our setters to return references instead of pointers we can do that so we're going to change the star here to an ampersand symbol here and this is going to do the magic so we have a dog reference returned from all these functions so because we are no longer returning a pointer returning this directly is going to give us a compiler error we need to dereference this pointer and get to what what is pointed to now the compiler will know that we are returning a reference to the current object and this is the syntax we can use to do this let's go down and dereference all the returned pointers and if we go down we're going to see that this is good already and we can go down and set up our chained call using references and we're going to go down and say dog one we're going to set dog name and we're going to pass in pumbaa what we have been doing all along now we're going to use the dot access notation because what we are returning is a reference and you're going to see that visual studio code is going to pick this up the breed is going to be wirefox and we're going to say set dog age and we're going to pass in our four and you're going to see that this is valid c plus syntax and if we print the information we're going to have new information applied to our dog object here we can weld and see that this is actually working you see the world is good we can clear and run rooster and we're going to see that information has been applied to our dog object so these are a few examples showing some of the usefulness for the this pointer we have seen that we can use the this pointer to print the memory address of the current object if we go down and look at our constructor and the destructor we are printing the address of the current object in our debug statement here and this is really cool we can use the this pointer to resolve conflicts in our setters for example we can use a parameter that has the same name as the member variable and it's not going to be really confusing and lead to bad results it's going to change the actual member variable and change it to whatever you pass as the parameter and this is really cool we can also use the this pointer to set up change calls for our function and we have seen that we can do that either through returning pointers like we are doing here and using the this pointer as a return object for our function here or we can use returned pointers to do this and if we do that we're going to be able to call our functions in one go like we are doing here using pointers or do the same thing using references like we are doing here this is really all we set out to do in this lecture i hope you found it interesting we are going to stop here in this one the next one we're going to learn about struct go ahead and finish up here and meet me there in this lecture we're going to learn about the struct keyword and this is another syntax you can use to create classes in your c plus plus program we have seen that we can already use the class keyword to create our classes i have to break it to you that we can also use struct to do the same so the syntax here is going to create a class called cat and it's going to have a member variable called string name the difference between struct and class is that for classes members are going to be private by default and when you do something like this and create class objects you want to be able to access the name here directly for example from the main function if you do that you're going to get a compiler error because class members are private by default but if you use struct members are going to be public by default and you will have direct access from the outside this is the only difference between class and struct otherwise you can use them interchangeably and they are going to do the same things we have been seeing for classes they really are the same things the only difference is that classes are going to have private member variables by default and struct will have public member variables by default but we can change this defaults by putting in our", "81297.192 - 81595.04000000001": "our class so for example here you see that we have changed our dog class to have a public member variable through the public keyword here and we can do the same for cat for example we can put in a public section and a private section and it's going to behave like classes we have been welding so far one common use we have for struct is when we have to set up classes that only have public member variables for example you can need to set up a point model in your c plus plus program and you can set up a class like this you can say struct point you're going to put in the member variables and they are going to be directly accessible from the outside and this is something you will see a lot out there so this is really all about struct we're going to head over to visual studio code and play with us a little more okay here we are in our working folder the current project is struct we're going to grab our template files and we're going to put them in place struct that's all project here and we're going to open this in visual studio code let's grab extract and drag and drop on top of visual studio code here this is going to open our folder we can now open the main cpp file and clean things up a little bit okay so we're going to set up a simple class called dog we're going to say class dog and inside we're going to have a member variable called name it's going to be an std strand let's say dog name or m name to mean that it is a member variable this is a syntax you will see a lot in c plus plus out there so let's use this from now on we're going to say m name and we're going to have another class let's put our semicolon we're going to use struct to set up another one and it's going to be called dog let's call this cat and we are going to go inside and set up our member variable we're going to say std strength m name and it's not going to have anything m so if we create objects of these classes and try to access them we're going to see the fundamental difference between structure and dog let's create a dog and we're going to say dog one and we're going to create a cat and we're going to say cat one and if we do dog 1 and try to access the m name member variable maybe set it to something else let's say fluffy we're going to have a compiler error because members of a class are private by default and we can't really do this so we are trying to access something that is private from the outside we're going to get a compiler error okay so we have a squiggly line here but if we try to do the same for a cat it's going to go through because cat is destruct and members of structs are public by default let's do that and really show you this we're going to say cat1 and we're going to say m name and we're going to give it a name and let's say johnny i am making this up i don't know if there is any cat named johnny but we're going to use this and you're going to see that we don't have any squiggly line we're going to build and see if gcc is going to take this it's going to take it the world is good we can bring up a terminal and run the program and we're not going to see anything because we're not printing anything from the main function here but if we want we can print this name of our cat we're going to say sddc out and say cat one name and if we build we're going to see that so the both should be good it is good we can clear and run rooster and we have johnny printed out and this is the name of volca and this is really the difference between class and strut members of classes are going to be private by default members of struct are going to be public by default but we can change these defaults for example let's make everything public we can do that no big deal here and we can move this a little bit to the right so that things are aligned nicely and we can do the same for struct okay so let's align this now if we do this we will be able to go in the main function and say dog name and change that and we're going to be able to see that if we print that out so let's go down and say stdc out and say dog1 name and print that out and if we build now we're going to see the name of our dog printed out okay well this is good we can bring this up and clear a little bit and run rooster we're going to see fluffy our dog name and johnny our cat name so this is really all about classes and struct they are the same things but the only difference is the defaults that come with these things but the common use we have for struct is when we want to set up a class that only has direct member variables and we don't intend to put methods into that class a good example of this is the struct off point so suppose we want to model points in our c plus plus program so we can do something", "81595.04000000001 - 81897.512": "two coordinates x and y we're going to say double y and from this point on we will be able to create point objects and print them out however we want so for example we can go down and say point point one and from this point we can go in and say 0.1 and say x and assign a value to x let's put in a 10 and we're going to go down and say point 1 y and we're going to give it a value let's put in 55.5 why not and we can do whatever we want with this point for example we can set up a function which is going to print a point we can do that let's say void print point and we're going to pass the point by value or we can even use references because this is going to be an object const point reference i think this is going to do and we're going to go inside and print the information we're going to say hddc out point and we're going to put the coordinates on we're going to say x is going to be point x and y is going to be point y why not and we're going to put in our closing square bracket and we're going to say stdndl to put a new line character after our print here now we can go down and say print point and pass on point one and if we do that we're going to build and we're going to do that through gcc you see the both is good now if we print we should see the information about our point and we see point x 1 y 55.5 and we see point x is 10 y is 55.5 we can go down and change the information about our point for example we can copy this and go down and change x to 40.4 and y to 2.7 why not and if we print the information about our point we're going to see that we have new information and we're going to print point one and therefore world we're going to see the new information so the build is good we can clear and run rooster now you see new information in our point so this is really the difference between class and struct the only difference is going to be in the defaults and struct is mostly useful if you want to set up classes that only have public member variables and you don't really want to use functions or methods in that class and we have an example of that here and if you have a case like that you will use struct your code is going to be much easier to read and understand from the perspective of other c plus plus developers we are going to stop here in this lecture and the last one we're going to learn about the size of objects go ahead and finish up here and meet me there in this lecture we're going to learn about sizes of class objects and try to think about it what are we going to see if we try to print the size of our class here called wrapper inside we have two member variables which are of and type and we have a member variable which is of std string type what do you think we'll see when we print the size of this wrapper object here try to think about it so what c plus plus does it's going to only account for the size of your member variables so it's going to add to the sizes of these guys in memory so we know an end is going to take four bytes in memory so we're going to have eight bytes for these two ants and we're going to have an unspecified amount of memory for a strength because a strength is internally implemented as a class and it stores its data as cost car pointers so we have really a pointer and the size of an object doesn't really account for thanks you are referring to using pointers it may count to the size of the pointer itself but it's not going to count what is pointed to and in the case of string for example we really want to know the range of things that we are pointing to so we're not going to have correct information with hdd string here but in general the size of an object is going to be the sum of the sizes of its member variables the functions are not going to be counted then the functions are just helper functions that live somewhere in memory but they're not going to be accounted for in the size of your object another reason you might think functions are not accounted for in the size of the object is that really functions are affiliated with the class itself functions are not affiliated with class objects the class is going to be the blueprint from which we're going to generate thousands of objects if we want but the functions or the methods are going to be associated to the blueprint itself so it really wouldn't make sense to associate the size of those functions in memory to class objects now that you have this idea let's head over to visual", "81897.512 - 82195.28": "more okay we have saved that the size is mostly going to be the sum of the sizes for the member variables but this is not always correct because of a phenomenon we called boundary alignment binary alignment is a thing most compilers do when they have member variables of different types and member variables that have the size of four bytes in memory are going to be stored at memory locations that are multiples of four and because of this phenomenon we might have gaps between our memory if we have variables for example that are of two bytes in memory and four bytes in memory and we're going to have gaps inside and the size of the object is going to be slightly off the sum we might do for the sizes of our object i realize this may be confusing we're going to head over to visual studio code and we're going to see a few examples okay here we are in our working folder the current project is size of class objects we're going to grab our template files pretty quick and we're going to put them in place and we're going to open our project in visual studio code by dragging and dropping here we have our main cpp file we can close the left sidebar and we can clean the main function here we're going to set up a simple class let's call this dog why not we have been using dove so let's use this again we're going to put our closing semicolon we're going to put a public section and it's going to just contain a constructor and we're going to say dog and we're going to use the default and we're going to put in a private section and in here we're going to put in a size t and say this is the leg count of the dog why not let's say we are modeling this okay so now we have our dog class in place we can create objects of this dog class we're going to say dog dog one and if we do this we are interested in knowing the size of our dog class here so we are going to say stdc out size of dog and save that and uh fingers crossed we're going to see the size of our dog object here and try to guess what we're going to get in the slides we have seen that the size is mostly going to be the sum of the size of the member variables and let's print the size of size t here because size d is our only member variable so i think it's going to be helpful to see its size printed out so we're going to have some context if we do that we're going to say size of size t and we're going to save that and we're going to build this program let's do that we're going to pass this through gcc you see the both is good and we're going to bring up a terminal and run this see what happens okay we see size of size t is eight and the size of our dark object is eight and this is really cool because we see that the size of our class object is really the size of our member variables that we have in here let's set up another member variable and really show you this so we're going to have arm account okay so we are just messing with us to learn i don't aim for this class here to make some sense practically we just want to see how the member variables affect the size of our class object now we have two member variables and we're going to try and world we're going to use gcc to do that and we're going to clear and run rooster now you see that size of doug is 16 and this is really proven that the size of an object is only accounting for the sizes of the member variables it's not going to count the functions that we have here so if for example we had a function that says printful and we have another one that says do something this is not going to change the size of our object because functions aren't accounted for in the size of our object here so let's build and really show you this the world is good we can clear and run rooster we see that we have the same sizes the size of dog is 16 the size of size t is eight we can even use object names here for example we are using the class itself but we can use dog one here and we're going to get the same information let's both and we're going to clear and run rooster and you see that we have the same size so if we change this thing to put in a pointer we're going to see something else let's put in an end pointer and let's say ph like we have been doing all along and see what we get and we know that the size of a pointer on my system let's print that out so that we have no doubt let's for example say size of end pointer is going to be size of", "82195.28 - 82497.43999999999": "to pass this through gcc and the both is going to be good we can clear and run rooster we're going to see that we have 24 because we have two member variables that are going to be eight bytes in memory of size t they are of type size t and we have a pointer which is going to have a size of h in memory but we don't care what this pointer is pointing to if for example this pointer is pointing to something really large we don't care we're just going to account for the end pointer here and this is really phenomenal because if for example we tried to set up an sdd string object and by now you should know that std strand itself is implemented as a class in c plus plus so it's really a class and we can print its size so let's set up a string object here we're going to say std strung and we're going to say name and we're going to initialize this with hello world okay we're going to see something really strange here so if we print the size of name here we're going to say size of name and we're going to print that let's see what we get we're going to run and we're going to see the block is good and can clear and run roaster we're going to see that size of name is 32. let's change the text inside our string and see that we change accordingly because this can really be confusing let's say i am the king of the universe why not and we're going to build again let's see what we get fingers crossed this is going to blow your mind you see we have the same size for name even if we are changing the text in here so what is really happening the strength is storing our text here as cost card pointer and what we have is a pointer inside and what we probably have inside is a member variable which is a pointer like we have here so what we will be accounting for in the strength class is the size of the pointer but it's not the size of what is pointed to okay so the car pointer may be pointing to thousands of characters in memory but as long as the compiler is concerned it's just going to use the pointer member variable and it's going to account for it in the size of your object hopefully you can understand why the size of our string objects is going to be the same regardless of how large is this strand this is really something you need to understand otherwise this is going to throw you off as you design your c plus plus applications and this is really all i had to share in this lecture the size of your object is mostly going to be determined by the member variables you have and the size is going to be the sum of the sizes of your member variables i would like to welcome you in this new chapter where we're going to be learning about inheritance and inheritance is a feature that c plus plus provides to allow us to build classes in terms of other classes and what i mean here is that we can build complete hierarchies of classes that depend on other classes for example if we think of a person as a type we can have different types of persons we can have a doctor a doctor is a person we can have a physician a physician is a person we can have an engineer an engineer as a person we can have really all kinds of persons and we can capture these kinds of relationships in c plus plus using inheritance for example here we have an inheritance hierarchy we can set up a person type in our c plus program and put in whatever member variables we need to define a person for whatever purposes we are building our c plus plus application for once we have this type we can build other types that depend on this person for example we can build an engineer type which is really going to embody the person type inside so what we will be doing is really setting up a layer of a person type and in our engineer type which is going to depend on person we will boil the novel layer on top of that and really reuse that person type without having to rebuild this from scratch hopefully you can see that this is going to improve code reuse we can also reuse this engineer type and well the other types on top of it for example we can have a civil engineer we can have an electrical engineer we can have all kinds of crazy engineers modeled in our c plus plus program using the inheritance and this is going to be really cool so this is what we are going to be exploring in this chapter looking at the facilities that c plus plus provides to capture these kinds of relationships in our c plus plus programs please note that inheritance is a really big feature and it is a", "82497.43999999999 - 82795.83200000001": "programming c plus plus object oriented programming is a paradigm or a way of thinking about programming that uses objects and the most basic defining feature of object oriented programming in c plus plus is classes that we have learned about using classes we can define things for example we can set up a car we can set up a house we can set up a spaceship we can do all kinds of crazy things with classes and ziplocs plus inheritance is going to build on top of classes and allow us to build classes that depend on each other and will the complete inheritance hierarchies that are going to make our design much easier to look at and understand and work with okay so this is what we are up against in this chapter learning about inheritance and really exposing you to as much as possible to let you use inheritance in an easier way in your c plus class programs we are going to start in the next lecture and try out inheritance for the first time go ahead and finish up here and meet me there in this lecture we're going to try out inheritance for the first time in this course but before we do that let's remind ourselves of what inheritance really is inheritance is a feature we have in c plus plus to be able to build new classes in terms of the classes we have predefined and the new classes are going to be stealing features from the already pre-existing classes if i can say it like that and the more classes we build in terms of others we're going to end up with what we call an inheritance tree which is basically going to go from the top to the bottom with the most fundamental class on top and the derived class at the bottom here we have a simple example for example we can have a person class and this class may be defining the basic features of a person but based on that personal class we might want to derive other classes that build on top of this person class for example we might want to define an engineer and a doctor and we know that an engineer is also a person so they are going to inherit some features from the person class the same goes for the doctor class it is going to inherit some features from person but all these derived classes are also going to add their own features to the person class siplus plus allows us to build these kinds of relationships here is another simple example we have a vehicle class to the top of our inheritance hierarchy and below this class we might derive a track class which is also a vehicle we might have a minivan we might have a truck we might have a pickup truck we may really do all kinds of crazy vehicles which are going to inherit the basic features from the vehicle class and add their own specialization on top of the vehicle class so this is the basic idea behind inheritance in c plus plus so the examples we're going to do in this lecture so here is a simple example of what we're going to do in this lecture we're going to set up a person class which is going to be our base class it is going to be defining two member variables which are going to be of std string type we're going to have a last name for the person and the first name for the person we are going to derive from this class and set up a player class the player class is going to inherit these features from the person class so it is going to have a last name and a first name built into it but that's going to be our base or our starting point we are going to add to this base and add another member variable from player and we're going to be having the player class which is really a person but it is going to add things to person to customize on what we can do with a player that we wouldn't originally be able to do or have with a person class this is the basic idea okay now that we know this we're going to set up our personal class which is going to be our base class it is going to have our two member variables first the name and last name we're going to have a bunch of constructors and we're going to have a stream output operator to be able to print this on the console and see our information here nothing special but now that this class is done we can build other classes on top of this class so what we can do for example we can derive a player class so the syntax is what you see here we say class player we say column column and then we say public and specify the class that we are", "82795.83200000001 - 83096.23199999999": "this class is going to be person or in other words we're going to be deriving from the person class and we're going to be doing that publicly okay for now i don't want you to worry too much about this public keyword we're going to be learning this in steps just know that this is the syntax you use to derive from another class now the moment we do this the player class is going to have the person information embedded inside but we will also have the ability to customize or add other things at the level of the player class this is what we do we have a private member variable and it is going to specify the game at the player place we're going to have our own set of constructors we can really build player objects but they are going to have a person part inside that is going to store information about this player person you notice we don't have a member variable here for the first name we don't have a member variable here for the last name but that information is going to be baked into this player object and this is really how inheritance helps us out we can derive from classes and build on top of them without having to redo the fundamental work to build our base classes we can just build on top of them and really do things faster and more efficiently okay so here are a few things you need to know about the public inheritance that we just did and we are saying public inheritance because of the syntax we used here public person this is doing public inheritance and we're going to see what this gives us so with public inheritance derived classes can access and use public members of the base class but the derived class can't directly access private members from the base class i want you to let this sync end what this means from the player class we can't directly access the private member variables we had in person remember our first name and last name are private to person and we can't directly access them in any deriving class that is doing public inheritance okay so in our player class if we try to access the first name and the last name we're going to have compiler errors because we can't directly access them but not to worry here we can still go through the public getters that we have in the person class to access the private member variables from the base class and that's what we're going to do in this lecture here because we don't have access to more powerful tools we're going to learn about in the next few lectures the same is also going to apply to friends of the derived class they are going to have access to private members of the derived class but they don't have access to the private members of the base class if you try to access the private parts of a base class from a friend of the derived class you're going to have a bunch of compiler errors okay now that you know this we're going to head over to visual studio code and play with this a little more and really drive this home here we are in our working folder the current project is first try on inheritance we're going to grab our template files and put them in place let's do this and we are going to open this in visual studio code pretty quick by dragging and dropping here let's do that properly and we're going to have our main cpp file we can clean this up a little bit and we're going to add our classes the first class we're going to add is the person class so we are going to create its header file and let's do the cpp file i am going to grab the code i have lying on my drive for the header here i am going to put the class in we are including the classes we're going to need we need string and io stream here because we're going to be outputting thanks through the output stream operator and down here we have our two member variables we have first name and last name they are of std string type and we have a bunch of constructors here a default constructor and one that takes two parameters we are taking them by copy here this is bad we should at least pass them by reference here let's correct this pretty fast and we're going to make the second one a reference as well let's do this and we have a destructor which is going to do nothing because we really aren't doing any dynamic memory allocation here we're going to head over to the cpp file and put in the code for that we're going to include the person and we're going to do our constructors put in the", "83096.23199999999 - 83396.4": "going to pass our parameters by reference again let's do this and our constructor should be done now we have a person class that we can use to derive other classes and use this class as a foundation to build other classes to visualize this again our class person is going to be the base class for our player class so if we build a player class it's going to have a person part of it which is going to be the foundation on top of which we're going to build notice that in player we don't need to set up last name and first name they are going to come from our personal part of player all we need to do in player is set up the game member variable to make him a full player who can have the game they happen to be playing this is the idea here okay so now that we know this we're going to put in our player class we're going to create the files for it let's do player dot h we're going to put this in and we're going to do player that cpp we're going to put him and we are going to hop over to the header file and put in our code the class is going to be player and it is going to be inheriting from person this is the syntax again we say colon colon we say the kind of inheritance we want to do in this case it is public and then we say the class that we are going to be inheriting from from this point on the player class is going to have a person part of it and we are going to prove this in a minute when we run this code here notice that we can build player objects by just passing in the game parameter here which is going to be used to initialize our member variable let's also make it a reference because this is good practice it is going to avoid copies you can even use string views but that's going to be your choice we are going to hop over to the cpp file and put in our implementation and this is going to complete our setup for the player class which is going to be inheriting from our person class here we can actually head over to the main cpp file and include the player class let's do this we're going to say player and we can create player objects let's look at the code again for a player we have a constructor which is going to take a string parameter we can use this to create a player and specify the game they are going to be playing but for now we don't have enough tools to put in the data that would initialize the member variables in the base class which is person here if we go back to person we're going to see that we have the first name and the last name but in our player class these member variables are going to be inherited because a player is inheriting from a person this is the syntax to do that but even if the player class has a person part inside of it we can't really access private members from person from a player object we're going to see a few ways we can get around this and one of those is to go public methods from the person class to access private parts of the person class this is going to give us access to these member variables if you go down in our stream output operator you're going to see that we are using these getters here the parameter is a player objects that we want to print out but to get access to the names we are getting the first name and the last name through our getters here before we really explore this any further i think it is a good idea to go in the main cpp file and create a player object so we're going to do that we're going to say p1 and we're going to specify that they play basketball why not okay so we have our player object and we can really do all we want with that for example we can print the information about this player object if you remember in player we have a stream output operator which is going to print all the information and here we have a problem because this guy is taking the data by reference and this is not a reference this is a temporary object that we are passing here so we could go back and change this to take a string view parameter let's go back and do that we're going to include a string view here in player and we're going to change our parameter to be std string view by value and we're going to do that in the cpp file let's do that we're going to say std string view and this should take care of our problem here you see that the problem goes away now that we have this guy we", "83396.4 - 83695.12000000001": "player and i put the information out okay so now that we have this we cannot try and build our program we're going to use gcc our favorite compiler and you're going to see that we have a problem undefined reference to player destructor let's go back in the header and see that we have a destructor but we probably didn't put a destructor in the cpp file so let's do that or because we're not doing any dynamic memory allocation we can even completely take out this destructor and we're just going to use the one the compiler generates for us this is going to be much easier to handle in our code so we can build again with gcc okay the world is good we can run this program and let's see if we have a powershell window we don't we're going to bring up a new one and we're going to run rooster we should see information about our player so player the game is basketball the names are mysterious person because that's the default data we inherit from a person if you go back to person you're going to see that the default data in first name is mysterious the default data in last name is person and it is what we see printed out here in our powershell window when we print information about our player object another thing i want you to see is that we can actually really prove that any player object is going to have a person part of it backed in and that's going to be storing the information that is modeled into our person class and we can use a debugger to do that for this to work i am going to put a break point here on line 8 which is printing things out this break point is going to be hit after our object is set up and we can really see the data inside this guy here so what we're going to do we're going to hit this run tab and we're going to use g plus plus we're going to use the debugging tools that come with gcc because this is our favorite we're going to hit the green button here this is going to start our debugging session a binary is going to be built and it is going to be plugged into our debugger and we're going to hit a break point here now if you look on the left here you're going to see a title that says locals we're going to expand this and we're going to see that the p1 object actually has a person part of it and you see that visual studio code is being helpful here it is saying that this is the base class and if we expand we're going to see that we have our member variables we have first name and last name and this is a player object that we are looking at don't forget that and on top of our person part we also have our own member variable which is the game that we play and it is right here hopefully this proves to you that any derived class object is going to have a base part embedded into it and that's going to be the foundation on top of which the derived class is going to be building its own tank this is the basic idea here okay now that you've seen this we're going to kill our debug session and we're going to see some of the things you need to be careful about when doing public inheritance like we are doing here the first thing i want you to see is that you don't have access to private parts of the base class if you go back to person here let's kill this so that you're not confused if we go back to our personal class we're going to see that our first name and last name are private so they want to be accessible to any class that does public inheritance like we are doing here they are just going to be private they are going to be part of the class but the derived class would have access to them this is the idea here and if we go in our output stream operator and comment out what we have here and try to directly access these member variables let's do that i am going to copy the code here and put that on top and we are not going to go through the getter methods from the base class we are going to try and access m first name let's go back and look at the names for the member variables it is first name and last name let's use that we're going to say first name you see that through intellisense but trying to access that is going to give us squiggly lines you see that we have this in our autocomplete but we have squiggly lines we can't access these if we try to compile our program let's do that again we're going to use gcc and we are going to get compiler errors and the compiler", "83695.12000000001 - 83997.44": "first name is private within this context again the meaning is that first name is private to the base class and we have no business accessing that in a derived class which is the player class here this is the meaning so we can't really access that okay i realize this is a global function but even if we try to do that from a member function let's do that from a constructor we're going to try and say first name okay i realize the access we are trying to do from the output stream operator is really not a good example because this is not a member function it is a global freestanding function so we can try and change the first name and last name from the constructor for example and we're going to see that this is not going to work either so we can take this out and we're going to remove our block comma so we're going to take out what we just did here and we're going to uncomment our good code here which is using getter member functions from the base class and we're going to try and change the first name and last name from the base class and change those into our constructor of the derived class we're going to try and change for example the first name and make it john and we're going to take the last name and change that to snow let's do that and let's go back and make sure we have the correct names and you see that we have squiggly lines we can't really do this because these are private members of the base class and we can't access them from a derived class they are part of the player class which is a derived class but we don't have access to them we can't modify them or do anything we can't read from them we can't write from them this is the message here if we try to build our program we're going to use gcc to do that we are going to get compiler errors and uh let's see the compiler error we get again the error is that first name and last name are private to the base class and we have no business accessing them from a derived class like we have here so if you need any kind of access to a private member of the base class you will have to go through something that is public and a good example is getter methods which are going to allow you to change things so for example if we want the ability to change the first name and the last name we can set up a bunch of setter methods let's do that we're going to say setters and we're going to say void set first name and we are going to pass an std strength view let's do that we're going to say string view here fn for first name this is going to modify our class so we are not going to mark this as a custom member function and we're going to say first name equals fn this is going to do we are going to set up a setter for the last name set and we're going to pass a string view here and we're going to say ln for the last name again this is not going to be a cast member function so we're going to say last name and we can pass in ln as our new name here now that we have these end we can take out these things we have in the constructor i think the job for this is done and this is going to give you compiler errors and we can go in our main cpp file and change the names for this person here for example we can say p1 set first name we're going to pass john and we can also set to the last name we're going to say p1 set last name and we're going to pass snow and this is going to do if we build and run this program we're going to see that the world is going to be good this is the first step and if we run we should see the information printed out we want to join snow printed out and the game should be basketball let's clear and run rooster we're going to see that the data is in here the name the names are jon snow and we have our game to be basketball here but notice these are base methods and we are calling them from a derived object and this is living proof that the public members from the base class are going to be inherited and usable from a derived class that does public inheritance like we are doing here and this is really the main message you can inherit publicly and have access to public stuff from the base class and use them in your derived class but private data is going to still be private to the base class you can't use that in a derived class this is the message here and this is really all i wanted you to see in this lecture the big thing is to", "83997.44 - 84296.32": "inheritance and if you do this the player class is going to be derived from person and it will have a person part baked inside and we can build on that foundation and for example put in our own member variables and do all kinds of crazy things public stuff from the base class are going to be inherited and usable from a derived class we just saw that by setting up a bunch of setters that live in the public scope of the base class and they were usable from the outside because they will be inherited as public in a derived class so we can really call these methods and use them from the outside like we are doing here but private data from the base class is not going to be accessible and usable from a derived class and we saw that by setting up this piece of code in the constructor of player this is going to give us a compiler error saying that first name and last name are private to the base class we are going to stop here in this lecture in the next one we're going to learn about another kind of access specifier we have in c plus plus and that is protected so go ahead and finish up here and meet me there in this lecture we're going to learn about the protected access specifier you can use in your c plus plus class and we're going to be reusing the same example from the last lecture we're going to have a person class which is going to act as our base class and we're going to be deriving from this person and creating a new class called player the player class is going to have a person part baked in and we can use this as a foundation to build other fans in player class for example we can set up our own member variables and do all kinds of crazy things and this is the setup we used in the last lecture we set up a person class and our members were private as you saw here but in the last lecture we saw that private member variables are not going to be accessible and usable from derived classes that do public inheritance and sometimes we want members from the base class to at least be accessible and usable from a derived class but still be inaccessible from the outside and we can achieve this using the protected access specifier so for example we can change the access specifier of our member variables from private to protected and at the moment we do this we will be able to access for example read from and write into these member variables from derived classes so for example we will be able to modify these guys from a constructor of the derived class and we thought that that was impossible from the last lecture but still we want to be able to use these from the outside of our derived class which is person here so we're going to still do public inheritance like from the last lecture but now that our member variables in the base class are protected we will have the ability to do whatever we want with them in the derived class and when we say in the derived class we mean from any method from the derived class for example we can go in our constructor here and then set data into the member variables from the base class and that's going to work as we're going to see in a minute now that you know this we're going to head over to visual studio code and play with this a little more okay again our member variables from the base class are going to be protected okay so we can really say that here let's say protected and at the moment we do this they are going to be accessible and usable from a derived class so from the derived class we will have the first name for example so from the derived class we will have our members baked then we will have a last name and the first name and because they are protected in the base class and we are doing public inheritance we will be able for example to set data into these member variables from a derived class and that's going to be really cool now that you know this we're going to head over to visual studio code and play with us a little more okay so here we are in our here we are in our working folder the current project is protected members we're going to grab the code from the last lecture and reuse that because that's going to have our inheritance hierarchy already set up we will have our person and player class and we can reuse them we will have our person and player classes and we will reuse them without needing to completely set them up from scratch that's going to save us a few seconds so we're going to put them in here and we are going to open this little guy in visual studio code by dragging and dropping here and we will have our", "84296.32 - 84596.872": "base class it's going to have our member variables which are going to be private from the last lecture we will have a player class which is going to be inherited publicly from the player we will have a player class which is going to be publicly inheriting from person and we have our main cpp file which is going to set up a player object and try to use it and we're going to see how this goes in this lecture so what we want to do is to change the access specifier in the base class and make that protected we can do that we can say protect it and this is going to change a few things about this class what this is going to do if you do public inheritance from this person class you will have the ability to do whatever you want with these member variables from a derived class you will have the ability to write into these member variables and change the data that we have inside you will also have the ability to read from them and that's something we couldn't do from the last lecture and this may come in handy sometimes another thing you should know is that these members are still not going to be accessible from the outside so from the standpoint of the main function for example here they are going to behave as if they are private because they want to be accessible from the outside they will only be accessible and modifiable from derived classes that do public inheritance this is really important to understand now that we have this we can really do all kinds of crazy things for example we can go in our constructor of player and comment what wasn't working from the last lecture and this is going to work now so let's uncomment this and we're going to see that the squiggly lines are going to go away and if we build a player object using this constructor we're going to see that we're going to have jon snow in even if we don't set using the setters from the base class so we can take these out and if we print information about this player we're going to see the game to be basketball and the names are going to be john snow because we are setting up this in the constructor of player that's no longer that's no longer going to be the data we get from the constructor of a person object which was here in the base class let's try to build and run this program so that you can really see this i just used clan here but it is also going to work no big deal here the build is going to be good we can clear and bring up a powershell window we can use to run this program we're going to say rooster and you're going to see that player is going to be having the information the game is going to be basketball the names are going to be jon snow and we are setting this data from a derived class and we have the ability to do this because these members are now protected in the base class so they are accessible and usable from a derived class now that we have this ability we can really change how our class at least the derived class works we're going to change it to have two more parameters and we're going to pass the first name and the last name and pass this data back into the base class by setting the data in the body of the constructor this is going to work so let's add our parameters we're going to say std string view and this is going to be first name param and we're going to put in another one which is going to also be a string view parameter and it's going to be last name param we can say that and we're going to hop over in our implementation let's grab what we just added because we will need to put that in our cpp file we are going to go in player.cpp and we're going to add this data we're going to put that here we can close the left sidebar to have some more breathing room and then we're going to not do an initializer list here because this is really going to be useless we are changing data in the body anyway so what we can do is say game param or a game and we're going to say gamipuram i am really sorry i am not following the same convention for the naming of my member variables but we can change this later so let's say first name we are going to pass in first name ram and for the last name we're going to say last name param and that's going to do now we have the ability to go in the main cpp file and create player objects and specify the first name and the last name and this is going to be much more flexible so let's go back to the constructor and see the order of our", "84596.872 - 84896.64": "we can come here and say first name is going to be john and the last name is going to be snow and if we build and run we're going to see the information printed out here and now we have the flexibility to be able to specify this in a constructor and this is going to make the job of building our objects much easier and we can forward this data back into the base class using the protected mechanism that we just learned about in this lecture and this is really cool so let's build we're going to pass this through gcc and the world is going to be good we can clear and run rooster we're going to see that the data is passed back to the base class this is working really well okay so this is really all i wanted you to see in this lecture we can set up protected member variables and they are going to be accessible and usable from any derived class that does public inheritance but they want to be accessible from the outside so if you try and for example say p1 and say first name and try to change that to something else let's say daniel for example you're going to have compiler errors because this is not going to work so let's try and build and show you the compiler error okay so protected members are not accessible from the outside they will be just accessible from derived classes or to be more specific they are going to be accessible from the members of the derived class and by members i mean member functions because that's where you will be accessing and modifying stuff so let's go back to the main cpp file and remove this and this is really all i wanted to share with you and i hope you found this lecture interesting we are going to stop here in this one and in the next one we're going to zoom in on the syntax here we are using to derive from other classes we just did the public inheritance here but in the next lecture we're going to see that it is possible to actually do protected and private inheritance and we're going to see what this means in the next lecture so go ahead and finish up here and meet me there in this lecture we're going to learn about base class access specifiers and in case you didn't know we have been using base class access specifiers in this chapter all along and to really understand this let's look at our player class which is inheriting from person and we are doing public inheritance the public keyword here is a base class access specifier and it is going to control how accessible our base class members from a derived class and we have three options okay so if we do public inheritance like we see here in our player class anything that is public in the base class is also going to be public you see m1 here is also public in the derived class anything that is protected is going to stay protected and anything that is private in the base class is also going to stay private in the derived class try and take a moment to look at this again the member access specifiers we have in the base class are going to stay intact if we do public inheritance again anything that is public in base is going to be public and derived anything that is protected in base is going to be protected and derived and anything that is private in base is going to be private in derived this is one kind of inheritance we can do in c plus plus but we can also do protected inheritance and the syntax to do that you just use the protected keyword here you say class player column column and specify that you want to do protected inheritance and then you specify the base class you want to inherit from the moment you do this anything that is public in the base class is going to be protected in the derived class anything that is protected is going to stay protected anything that is private is going to be private and in one way you can see that we can use these base class access specifiers to constrain the access specifier in derived class but we can't make the access specifiers in derived class more relaxed we can only make things more constrained or more restricted for example the m1 member variable was public but now we have made it become protected by using the protected base access specifier here okay so now you know that we can do public and protected inheritance but it is also possible to do private inheritance and you do that", "84896.64 - 85198.96": "specifier the moment you do this anything that is public in the base class is going to become private in the derived class anything that is protected in the base class is going to become private in the derived class and anything that is private is going to stay private in the derived class and again you see that this is going to constrain thanks things that were public are now private in derived and we can't really do anything with them from any other class that might derive from our player class so this is the setup we have okay to sum this up through the base class access specifier we can control how relaxed or constrained is the access to base class members from the derived class and this is really important to understand if you want to say as relaxed as they are in the base class you can use public inheritance if you want to constrain a little bit you can use protected inheritance and things are going to be inherited as protected except for the private data in the base class if you want things to be super constrained you can use the private inheritance that we just learned about and everything in your derived class is going to be private and you can use this if it makes sense for the application you are designing and you can use these kinds of features if they make sense for whatever application you are designing with c plus plus one thing you should know though is that regardless of the base class access specifier we use private members of the base class can never be accessible from a derived class so anything that is private is going to stay private and you have no way to relax things a little bit that's not going to work you should really know this now that you know these kinds of inheritances we can do in ziplus plus we're going to head over to the next lecture and play with them a little more in this lecture we're going to play with the base class access specifiers we learned about in the last lecture in other words we're going to play with public protected and private inheritance in visual studio code so let's review a little bit what we talked about in the last lecture we say that we can have public inheritance and the syntax to do that is what you see here and at the moment you do this what was public in the basic class is going to be public in the derived class what was protected is going to stay protected what was private is going to become private in the derived class in other words public inheritance is really not going to change the accessibility of the member variables we have in the base class we're going to inherit the data as it was with the same access level we had in the base class this is a defining feature of public inheritance in c plus plus we can also do protected inheritance and what this is going to do is to make protected the highest access level we can have in the derived class so anything that was public in the base class is going to become protected anything that was protected is going to stay protected because that's the highest level we can do now and anything that was private in the base class is going to be private in the derived class we say private in the sense that it is going to be private to the base class so you can't really use m3 from the player class in this case if you're trying to do that you're going to get a compiler error okay we can also do private inheritance and the syntax to do that is what you see here and now private is going to be the highest level we can do in the player class in terms of the members that we get from the base class so anything that was public is going to become private anything that was protected is going to become private anything that was private to the base class is going to stay private to the base class this is what we mean here but now m1 and m2 just became public to the player class if anybody else tries to derive or inherit from a player these things are not going to be accessible and this is in some way the player class being selfish it is saying i am going to get everything i can from my parent class or my base class but i am going to make it all mine nobody else can take this and this is the kind of setup we can achieve with private inheritance okay so now that we have this in mind we're going to play with us in visual studio code we're going to set up a bunch of classes we're going to set up a personal class we're going to be inheriting from we are going to set up a nurse class which is going to do protected inheritance and we're going to set up an engineer class which is going to do private inheritance and we're going to really play with this and see how this plays out in real c plus plus code so let's do this here we are", "85198.96 - 85497.192": "project is base access specifier a demo we're going to do a demo on this but before we do that we're going to grab our template files and put them in place and we are going to open this little guy in visual studio code by dragging and dropping here this is going to give us a good starting point we're going to have our main cpp file we're going to clean it up and we're going to set up our base class which is going to be the person class so let's put this in from scratch we're going to add our files we're going to say person page and we're going to say person.cpp we are going to hop over in our header file and put in our code nothing special so far we have an include gourd we have our person class it has a bunch of member variables we have the full name which is public we have the age which is protected and we have the address which is private to this class here this is going to be our starting point we also have a bunch of constructors we have a default one we also have another one which is going to take all the data we can use the constructor person object and here we are passing a cost string by reference i think we can fix this and pass a string view this is going to be better let's say string view and we're going to change the first parameter here to be an std string view by value this is going to be much better okay we have our class we can hop over in the cpp file and put in our implementation we are going to change the constructor a little bit and make sure we are taking an std string view by value and if you wanted to type all this code you can get it from the resource section of this lecture i am going to attach all the source code and you can download and use this however you want to really make your learning experience as pleasant as possible so we have our constructor here it is going to forward the data into our member variables the full name is going to go into our full name member variable we're going to grab the age and the address and we're going to store all this information we also have an output stream operator which is going to be printing all this information here it is going to go through the getters because we have a person object passed as a parameter here and this is going to work we can go in the main cpp file and include our person class and create an object of it we can do something like person person one and we can pass the data that our constructor expects we can pass in the full name the age and the address so let's do that we're going to say the full name daniel gray why not and the age is going to be 27 we can put in whatever we want and we're going to put in the address we're going to say blue sky streak you can say two three three for example and say the number of the house to b56 why not this is a possible address for a person so we can say person one or we can use htdc out to print this out because we have an output stream operator for our person class we can do this we're going to say person one and we're going to put him out and if we build and run this program we're going to see that this is going to work hopefully and we have a problem because we don't have a semicolon at the end of line 6 here let's fix that we're going to run this task to build with gcc the builder is going to be good we can bring up a powershell window and we're going to use this to run our program if we say rooster we're going to see that we have the person printed down the full name is daniel gray the age is 27 the address is blue sky street 233 and the number of the house is 56 so this is a possible implementation for the person class but we are really not interested in setting up a prison class and doing things with that we are interested in inheriting from the person class and learn about different kinds of base class access specifiers we can do so we're going to set up a player class which is going to inherit publicly from the person class let's do that we're going to put in our player we're going to put in the header file let's say player not person and we're going to say player.h we're going to put in a cpp file we are going to hop over in the header of player and put in our class let's close the left sidebar here so that you can really see everything we have an include guard in we have the class player declared it is going to do public inheritance from person and what this is going to do is that anything that is public in person is going to stay public in player anything that is protected is going to stay protected in player and anything that is private is going to stay private so we want to be able to access private data from a person object for example we can't access", "85497.192 - 85795.76": "it is private but we can use the full name and the age from the derived class let's make sure we have a cpp file and before we try things out so let's hop over to the cpp file and put in a possible implementation we are going to include the person and player because we're going to be using these and we are going to set up a constructor which is not going to do anything for a player we also have our output stream operator which is going to print the data it is going to be using the getters we have in the base class and we have access to them because we are doing public inheritance so they are going to be public and we can call them from the outside like we are doing here notice that this is an outside player object and we are calling our public members on it and this is going to work we also have a destructor and which is really not going to do anything but we're going to keep it in here because it's not going to hurt so now what we want to try out is to see if we can access thanks from the base class the first thing we have in the base class is the full name and i think we can actually copy these blanks or we cannot just use them m full name mh and m address we're going to try and use them in the derived class so let's try and say m full name and change the full name for example to be daniel gray or jon snow and we're going to change the age to be 55 why not and we're going to try and access the address let's see what we called our address member variable it is m address we can grab that and use that in our class if we try to access that we're going to get a compiler error because that's going to be private to the base class you notice that if we even try to put some junk data we're going to have a squiggly line because this is not accessible here and visual studio code is going to say that this is not accessible because it is private to the base class so we can access m full name because it was inherited as public so this is going to be okay we can use age because it was inherited as protected we can use it in a derived class but we can't use the address because it was inherited as private and it is private to the base class so this is not going to work even if we try to call biola code we're going to get a compiler error let's try to do that so that you can really see for yourself okay so we have a compiler error and this was declared in the base class as private this is what the compiler error is saying so we shouldn't really be doing this the derived class has no business modifying a private member of the base class this is the message here so we're going to comment this out and say that this is going to give you a compiler error but we are also going to create a player object and try to access these guys and see how accesses from the outside so we're going to go in the main cpp file and we're going to include player dot h and we're going to create a player object we can put in a separator and say a bunch of dashes here this is going to do i think this is going to work and we're going to create a player object we can say player and player and not put any parenthesis here this is going to call the default constructor that we have in our player class and we can try to use this but before we do let's try and build and see that this is going to build just fine we're going to work with gcc let's do that we're going to see that the world is good we can try and access stuff from this player object we can say player and say m full name you see that this is accessible we can actually change this to samwell jackson we can do that but if we try and say player mh we're going to see that this is not accessible here because this was inherited as protected if we go back to person we're going to see that the age is protected so it will be accessible in derived classes just like we did in our play method of the player class but we can't access the age from the outside of a player object because that's not going to be accessible from the outside this is a defining feature of the protected access level so this is not going to work even if we try to build we're going to get a compiler error along the lines of this is not accessible in this context and it was declared in the base class so we can't really access it from the outside this is the compiler error here so we're going to comment this out and say that this is going to give you a compiler", "85795.76 - 86095.512": "can't even have a chance accessing a private member of a base class from a derived object in the main function like we do here so if we try and do player and say m address this is not going to work okay so if we try to change this for example to some junk data this is not going to work we're going to get a compiler error because this was declared private in the base class and it is private to the base class you can't really access it from the outside you can't even access it from a derived class so let alone access this on the outside in the main function so this is not going to work it is going to give you a compiler error but we're going to weld and show you the compiler error because we are learning here so we're going to get a compiler error that says m address is private within the context where we are trying to use it so we can't really use it from the outside here again this is going to give us a compiler error let's say that here and this is really what i wanted you to learn about public inheritance anything that is public in the base class is going to be public in the derived class anything that is protected is going to stay protected and what that means it will be usable in the derived class but you can't use that from the outside and anything that is private in the base class is going to stay private so you can't use that from the derived class and you can't even use that from the outside like we are doing in the main function here this is not going to work okay so now that we have this in place we're going to set up another class that is going to do protected inheritance and that's going to be our nurse class so we're going to put this in let's put in a nurse header file this is going to be nurse.h we're also going to put in nurse.cpp okay so we're going to head over in the header file and put in the code for our nurse class we're going to say cluster nurse and say protected to mean that we want to do protected inheritance and what this is going to do anything that is public in the base class is going to be protected in the derived class which is our nurse class anything that is protected is going to stay protected anything that is private is going to stay private to the base class this is what we mean here okay now that we have this end we can put in the implementation for our nurse class and we're going to have a constructor and we're going to have our output stream operator and we're going to have a destructor which is really not going to do anything because we don't have any dynamic memory allocation in our class we are going to try and build this code to see that it is going to work we have a squiggly line in the main cpp file but it was because of the line 15 here and it has been commented down let's see if we can build this program okay you see that the world is going to be good and we are able to call thanks from our output stream operator you see we have an earth operand we are able to call this gateful name and get age member function because they are now protected in the nurse class but we are able to call them from the outside because this operator is a friend of our nurse class here i want you to say this some of you are going to ask aren't we using an object and calling a method using the dot operator this qualifies as calling thanks from the outside and yes that's true but this method is really like a member function in that it has access to private and protected data from our nurse class and the reason is it is a friend of the nurse class here that's why we are able to do something like this but what i really want you to see now that that doubt is cleared is the kind of access we have to thanks from the base class we will still be able to use m full name here because it was inherited as protected so we can use it from a derived class we can say m full name jon snow this is going to work because this was inherited as protected now it is protected in the eyes of the nurse class this is what we mean here so this is okay this is going to work we can get the age we can use that and we can say john's and we can say 23 for example this is going to work because this is protected but we can't use the address if we do that we want to be able to change it we will get a compiler error because this is private to the base class this is the same thing we saw in the last lecture this is going to give us a compiler error if we try to build this program let's try and build it to really prove this the body is going to be good", "86095.512 - 86395.28": "uncommented and trying to build the program let's do that we are going to get a compiler error and the compiler error is going to say let's go up and see if we can get this message it's going to say m address is private within this context where we are trying to use it and that's line 17 of the nurse class if we go there we're going to find the offending line here so we're going to comment this out and say that this is going to give us a compiler error okay so you shouldn't do this now that we know things from the inside let's see how things fair on the outside we are going to hop over to the main cpp file and include our nurse class and we're going to create a nurse object we can go down and say stdcl and we're going to put in our dashes and we're going to create a nurse object i think we have a default constructor for a nurse we're going to say nurse 1 and we're going to basically try and do the same things we did for the player object from the outside if we try to access the full name now it's not going to be accessible because it was inherited with protected access level so if we do nurse and say m full name you're going to see that autocomplete is not here this is a good sign that this is not accessible from this place if we say davy jones we're going to get a compiler error and if we try to build we're going to get a descriptive compiler error at least i hope so let's build we're going to see that with world with errors and if we go up we're going to have our error nurse was not declared in this scope did you mean nurse one yes we met nurse one sorry for that we're going to build again thank you gcc for pointing this out we are going to get another kind of error and if we look at our error here we're going to see that m full name is inaccessible within this context because it is a protected member of the nurse class now it was inherited as protected and we can't access it from the outside we can access that from the inside because it is protected but if we try to access it from the outside we're going to get a compiler error and this is a defining feature of protected inheritance even things that were public in the base class are going to become protected in the derived class so this is the message here and this is going to give us a compiler error okay so if we also try to access nurse 1 and say m h this is also going to give us a compiler arrow let's try to put in an edge here let's put in 51. you're going to see that we're going to get the same kind of error let's really try these things out and learn about every possible way we can set up these things if we look at the error we're going to see that image is protected within this context so we can't really access it so this is the compiler error we get and i hope you know that if you try and access the address you're also going to get a compiler error because that's private to the base class so we can't even use that from a derived class like nurse here that's not going to work let's say that here we have a compiler error and we're going to set up another class which is going to inherit privately and see how that works out the class is going to be engineer we're going to see that the error here goes away so let's create our engineer class we're going to put in a header file that's going to be our engineer.h we are also going to put in cpp okay so we're going to hop over to our header file and put in our engineer class we're going to say engineer and say that we want to inherit privately from the person class this is the syntax here and this is going to do private inheritance and what this means is that anything that is public is going to become private to this class anything that is protected in the base class is going to become private to this class and anything that was private in the base class is going to stay private we won't have access to that whatsoever in the derived class directly we are going to hop over to the cpp file and put in our implementations we're going to have a default constructor for engineer which is not going to be taking any parameter we're going to have our output stream operator which is going to still work because it is a friend of the engineer class so all these things that were inherited to be private are going to be private to the engineer class and any friend of the engineer class will have access to that that's why we are able to call get full name get age and get address here and get these things to work okay now that this is out of the way we can try and access our thanks", "86395.28 - 86695.28": "things we did in our nurse header we're going to copy the code because we are trying to access the same member variables and we're going to see how this fairs in our engineer class this is going to save us a few seconds if we try to access the full name this is going to work because it is private to this class if we try to access the edge this is going to work because all these guys are now private to this class here but if we try to access the address this is going to give us a compiler error because address is private to the base class if we go back to person we're going to see that this is the case and if you try to inherit from this class in any way you're not going to be able to change this access level this member variable is always going to stay private to the base class and no derived class will be able to modify or read from this in any way so this is the setup we have here if we try to build we're going to get a compiler error let's first take this out and show you that this is going to build just fine without this line here and i am going to build again and show you that if we bring that in we're going to get a compiler error so the build is good we can go back in our engineer class and bring in the offending line we can uncomment this and if we want we're going to get a compiler error let's make sure you see the compiler error here so the world was finished with errors and if we go up we're going to see that we have an error here and the error is going to say m address is private within this context and the context is what we have at line 17 in the engineer class so we can go there and find the offending line and we're going to comment this out and this is going to give us a compiler error now you know this but this is how things are going to work from the inside but we also need to look at how things fare from the outside let's go back in our main cpp file we are going to include our engineer class and we are going to create an engineer object we can go down and say sddc out and put in a bunch of dashes to separate on thanks and we can create a engineer object and that's going to be engineer one and if we try to access the full name that's not going to work because it is now private to the engineer class if we say engineer one and try to say m full name and try to change the name in any way and say for example olivier godson i am making this up i don't know if this name exists but the point is that this is not going to work it is going to give you a compiler error because m full name is now private to the engineer class it was inherited to be private to the engineer class and if you try to do this you're going to get a compiler error let's try and work with gcc to really show you this and the world is going to be finished with errors and if we go up we're going to find our error full name is inaccessible from within this context and the offending line is at line 27 of the main cpp file if we go there we're going to find our line and we're going to say that this is going to give us a compiler error so let's say that and we can't even access the age and the address member variables the age is also going to be private to engineer but the address is private to the base class so that's not going to work either so we can't really access that from the outside because it is now private to the engineer class so let's go down and really show you that we're going to go down and say engineer one and say mh if we try to do that that's not going to work that's going to give us a compiler error and if we try to build we're going to get a compiler error along the same lines as what we just got here the book is going to finish with errors and if we look at our error we're going to see that mh is protected within this context so we can't use it at line 28 of the main cpp file this is going to give us a compiler error let's do that we're going to say that here and if we try and access the m address member variable that's not also going to work because this is even more restricted for access it is private to the base class so we can't access it from a derived class directly we can't even access that from the outside so you should really know this so if we put in some junk data here and try to build this is going to give us a compiler error that says that this is not accessible from the main cpp file like we are trying to do on line 29 here so we're going to get an error and the error is going to say m address is private within this context and the", "86695.28 - 86995.832": "file we're going to take this out and we're going to say that this is going to give us a compiler error this is really all i wanted you to see in this lecture and before we wrap this up let's try and build again and make the error go away because i don't like to leave you with code that has compiler errors and the book is good and this is really all i wanted you to see in this lecture that you can do all kinds of inheritances in your c plus plus code you can do public inheritance you can do protected inheritance you can do private inheritance and we had a chance to look at all these scenarios in this lecture here the message is the same as we saw in the last lecture if you do public inheritance anything that is public in the base class is going to stay public in the derived class anything that is protected is going to stay protected anything that is private is going to stay private and this is really misleading in a way the private data from the base class is not going to be private to the derived class it's going to stay private to the base class so if you try to use this in any way from the derived class you're going to get compiler errors because you can't access that even if it is part of you player has a person part of it but it can't access private members from the base class you should really know this we have seen that we can also do protected inheritance and that's going to constrain events to have the highest level of access to be protected so anything that is public is going to be stripped down to protected access anything that is protected is going to stay protected anything that is private is going to be private to the base class you should really make this super clear we can also do private inheritance as we saw and this is going to strip down the highest level access to be private so anything that is public is going to be constrained to be private anything that is protected is going to be inherited as protected to the player class but anything that was private in the base class is going to stay private to the base class even the player class won't have access to this member directly if we really need access to private data from the base class we might go through public getters or anything we get from the base class but we can't access m3 directly and use it from the derived class that's going to give us a compiler error this is really all i wanted you to see in this lecture and i hope you find this interesting we are going to stop here in this lecture in the next one we're going to try and zoom in on private inheritance and show you some things you really need to be careful about so go ahead and finish up here and meet me there in this lecture we're going to zoom in on private inheritance and we're going to see that the class that does a private inheritance is really selfish here is a simple structure we will be using in this lecture here we will set up a person class which is going to act as our base class we are going to inherit from this class privately and create an engineer class and what this is going to do it's going to take everything from the class person and make it private to the engineer class so the m1 member variable which was public in the base class is going to be private to the engineer class this is what we have here the m2 member variable which was protected is going to become a private in engineer that's what we have here and the m3 member variable which was private to person class is going to stay private to person in the eyes of engineer this is the situation we have here so the problem is going to really show up when somebody else tries to inherit from engineer because m1 and m2 are now private to engineer they will be inherited but still inaccessible to the civil engineer class here m1 and m2 will be private to the engineer class but m3 will be private to the base class which is person so hopefully you can see the message that if a member variable is private it can't be inherited in any way it doesn't matter which kind of inheritance you do so starting from engineer which has made m1 and m2 private to itself it's no longer possible to forward these guys down in the inheritance hierarchy another way to look at this is to see that the engineer class is really selfish it is saying i am going to take everything i can get from my parent classes because i am inheriting privately but nobody else will be able to take things from me", "86995.832 - 87298.64": "to myself so even if civil engineer is doing public inheritance that's not going to give him any access to these member variables which are now private to the engineer class hopefully you can really see this and private inheritance is going to really constrain what you can forward down to other classes that are going to be inheriting from you this is the message i am trying to convey here okay so here is the same example in code we have our person class it's going to have our member variables we're going to have the full name the age and the address they are going to have public protected and private access we are going to inherit from person and create our engineer class we are going to privately inherit from person and this is going to take everything we get from person and make it private to the engineer class and one exception is going to be what was already private to the base class which is our person class here this is going to still stay private to the person class regardless of what kind of inheritance you do from person but any other thing if we have any member variable which are public or protected or even if we have some member functions which are public or protected everything is going to be private to the engineer class because we have done private inheritance here so if we inherit from engineer and do any kind of inheritance we are going to do the most relaxed kind of inheritance which is going to keep the kind of access we had in the base class but this is not going to improve anything everything is going to stay private to the engineer class and the civil engineer is really not going to have any access to any member variable or member function that is inherited from the engineer class and we are going to see this in a minute when we hit visual studio code so again if a class is doing private inheritance it's really another way to say this class is selfish it's going to take everything it can from the parent class but it's not going to forward nothing to downstream inheritance classes and this is the setup i really want you to understand here and only do private inheritance when you want this kind of behavior now that you know this we're going to head over to visual studio code and play with us a little more here we are in our working folder the current project is closing in on private inheritance we're going to zoom in on this and really understand the effects of doing private inheritance we're going to grab the code from the previous lecture and we're going to grab the engineer and the person class these are going to be our starting point here make sure you grab the dot vs code folder if you are using vs code with this course that's going to give you the basic settings we need to do our c plus plus program i am going to copy these guys down and put these in our current project and again make sure you have the main cpp file the person class and the engineer class and these are going to be our starting point so we're going to open this little guy in visual studio code by dragging and dropping here we're going to look at our main cpp program we are not going to include nurse because we don't have this included here and we can really take out everything we have in the main function we're going to be adding our own thing here we also don't need the player class here we're just going to be using person and engineer let's look at the person class it is going to have the member variables that we expect we are going to have a public member variable the full name a protected member variable mh and a private member variable m address here we are going to create an engineer class which is going to privately inherit from person so it is going to make everything private to itself the engineer class is going to have a person part in at but the member variables we get from the person class are going to be stripped down to private access level except for the member variables which are already private in the base class and that happens to be the address so it doesn't matter which kind of inheritance you do the m address member variable is going to still be not accessible to inheritance classes this is going to still be private to the base class which is the person class here so the full name is going to be stripped down to private access level in engineer the edge is also going to be stripped down", "87298.64 - 87597.68": "be private now to the engineer class and any class that tries to inherit from engineer is not going to have access to these guys so if we do any kind of inheritance from engineer we want to have access to full name we want to have access to mh because these are going to be private to this class here this is the setup we want to understand in this lecture so what we're going to do we're going to set up a new class which is going to inherit from our engineer class and it is going to do public inheritance and we're going to see how this works we're going to create a civil engineer class which is going to inherit from engineer so let's do this we're going to create a header file for our civil engineer class and we're going to create a cpp file we are going to head over in our header file and put in the class it's not going to be anything sophisticated we're just going to have in our include guard we're going to create a civil engineer class which is going to publicly inherit from engineer but remember everything was made private to the engineer class so even if we're doing public inheritance the full name member variable is going to be private to engineer the age is going to be private to engineer and engineer won't have any access to these guys but before we really play with that we're going to put in our implementation in the cpp file so let's put in the code here we're going to put in the implementation and we're going to have our constructor in place but notice what happens on our output stream operator the output stream operator is a friend of the civil engineer class so it should have access to anything we have in our civil engineer class but notice what is happening here the get full name method is not working because it has been made private to the upstream class which happens to be our engineer class and we can't really access them even if we know that they are really part of the interface of the person class we have them as public members of the person class but when the engineer class did private inheritance it made everything that is not private to person private to itself so these gators are going to be private to engineer when the engineer does private inheritance the member variables which are public and protected all these things are going to be stripped down to private access level so they are going to be private to engineer and any kind of inheritance you're going to do is not going to change that they are going to be inherited as private to the engineer class that's why we can't even call them from a function which is a friend of our civil engineer class and we know that if you mark something as a friend it's really going to have access to anything you have including private members but we can't call any of the members from the engineer class because everything is now private to the engineer class this is what i want you to see if you do private inheritance this is going to really strip down anything from the upstream class and make that private to the class that is doing private inheritance this is the message here and again if you go in any method of the civil engineer class and try to do any kind of access for example calling the get full name method is not going to board well we're going to see that this is inaccessible here if we try to access m full name for example change this to be something else let's say daniel gray this is not going to work if you try to access mh and change it to 45 for example this is not going to work we already know that the address is private to person so we shouldn't really try to access it because it is inaccessible regardless of any kind of inheritance you do but the members that were public from person can't be accessed from any class that is inheriting from person even if we know that these things are public or protected in the person class and this is really what i want you to see if we try and build our program we're going to get a bunch of compiler errors saying that we can't access these guys from our civil engineer class we are going to use the gcc compiler here because it is our favorite and we're going to see our compiler errors here okay so we're going to get a bunch of errors let's go up and see all of them we're going to get an error saying that getfullname is inaccessible within the context of the c4 engineer header class at line 13 we are calling this method", "87597.68 - 87897.28": "error here saying that the getfullname method is not accessible from line 13 of the civil engineer header okay it is really the same error but if we go down we see that we get a bunch of other errors we have m full name which is not accessible we have m edge which is not accessible we can't really do these kinds of things from the civil engineer class because all these are going to become private to the upstream class that did private inheritance so let's take this out and show you that even if we can't access these guys they are still part of our civil engineer class and we're going to use a debugger to do that i am going to take out these things or i can comment them out and say that they are going to give you compiler errors i think this is going to be more descriptive so let's say compiler error and access to the edge is also going to give you a compiler error and we're going to go down and show you that we're also going to have the same problem in our output stream operator so if you really want your output stream operator to work here what you can do is put some public members in the engineer class and make it give you access to the members that were eclipsed to private access in this class here for example you can return the full name you see that we can access that here you can return the age but you still don't have access to the m address member variable because this is private to the person class but i really don't even want to do this because doing this kind of design is sign of bad design in the first place so if you need to do those kinds of getters and forward them down to inheritance classes why not change the design in the first place and not to do private inheritance here for example if you change this inheritance to protected or public these members are going to be directly automatically forwarded down to any inheritance class so just know that you can put in public getters that are going to give access to the full name and age but you still want to be able to access the address member from the inheritance class because this is the design you achieve by marking something as private in the base class if you want the address to be forwarded down you might change the access level we have here and maybe make it protected or public so this is the ideas i really want you to grasp i am going to comment out the offending code here because i want you to be able to build this program and see that even if we can't access this get full name and get address members from inheriting classes they are still part of our interface we just can't have access to them because of the choices we have made in upstream classes so what i am going to do i am going to go in my main cpp file and i am going to create an engineer object i will also include civil engineer here let's do that and i am going to create an engineer object and i am going to create a civil engineer object and i am going to just say done here and i am going to put the break point on line 12. we are going to use a debugger to really see that engineer objects and the civil engineer objects still have a person part of them we just can't access the interface that was eclipsed by the engineer class so we are going to hit the run tab here and we are going to start our debugging session by clicking on the green button here we are going to build our program and if the build is good we're going to plug the binary that was generated into our debugger and we are going to hit our break point in a minute once we hit our break point we are going to look at the local variables we have in the main function we're going to see them on the left here if we expand we're going to see that we have an engineer one object and we have a civil engineer one object if we look at our engineer we're going to see that we have a person part of this which is our base class and if we look at civil engineer it's also going to have a base of engineer so any civil engineer is also going to be an engineer but the engineer part of the civil engineer also has a person part of that you should really see this information and the main message i want to convey here is that all these objects have a person part of them we just can't access that part in objects of our inheritance", "87897.28 - 88196.95999999999": "we have made let's close this off now that you have seen this and again we are really working on this inheritance hierarchy the base class is person and it's going to have these member variables but if we do private inheritance from the person class anything that is not public is going to be eclipsed down to private level access so any other class that is going to inherit from our engineer class now is not going to have direct access to these members because they are going to become private to this class here and that's the experience we have if we try to use any of this methods and members we get from engineer this is not going to work because they are now private to the engineer class this is the message here so the get full name get age methods are not going to work if we try to use the contract count member which comes from the engineer class that's not also going to work if we look in our header and try to use any of these members we're going to get compiler errors because all these guys are now private to the engineer class this is really all i wanted to share in this lecture let's head over to the cpp file and comment this out again because i don't want to leave you with these compiler errors i hope you found this lecture informative and fun we are going to stop here in this one in the next one we're going to see that we can actually resurrect some members back in scope if they were eclipsed by the kind of inheritance we did from an upstream class go ahead and finish up here and meet me there in this lecture we're going to explore how we can resurrect members back in scope so what do we mean here suppose we have our trusty inheritance tree here we have a base class person the engineer class is going to do private inheritance and it's going to really be selfish and say i am going to take everything i can from the upstream person class but i am going to make everything my own and nobody inherited from me will have access to these guys for example m1 and m2 are going to be private to the engineer class starting here when the engineer class does private inheritance so any other class for example civil engineer which is inheriting from the engineer class in any way won't have access to the m1 and m2 member variables so suppose for some reason that we have this kind of setup here but again we want some members to be accessible to other downstream classes suppose for example we want the m1 member variable to still be accessible to downstream classes while we have done private inheritance c plus plus is really weird in a way it is going to work hard to really prevent you to do thanks and that gives you a back door you can go through to allow the same thing you were trying to avoid in the same place it is the same kind of logic we have here it allows you to use private inheritance to prevent downstream classes to access to anything you get from upstream classes but then again it allows you to change that and relax the access to downstream classes for example we can change the access of m1 and m2 make it more relaxed make it public or protected if we wanted that so let's take a look at some code because i know that these things can really be confusing okay we are going to start from a person class which is going to have a bunch of member variables we will also have a bunch of getters that are going to return all these member variables and we are going to do private inheritance from person in an engineer class this is going to strip down access to the members we get from person to private level access for example they get full name member function the gate age the gate address member functions are going to be private to the engineer class now but for some reason you might want to resurrect them to a more relaxed access level and you do that using the using keyword so the first thing you need to do is to choose the section in which you're going to be putting these using statements for example because we put them in a protected section all these guys are going to be resurrected with a nexus level of protected if we put them in a public section they are going to be resurrected with a public access level and they are going to be accessible from inheriting classes one thing you should know is that you can't resurrect", "88196.95999999999 - 88495.832": "upstream class for example we know that our m address member variable was private to the person class so we can't really resurrect that in an inheritance class if we do that we're going to get a compiler error and hopefully this is going to drive the point home that private inheritance is really really serious and that it's going to strip down access to private level access in an inheritance class and any downstream inheritance class will never be able to resurrect those member variables to a more relaxed access level so because everything here is inherited as private by default any downstream inheriting class will never be able to resurrect these guys for example to public or protected scope this is the message here and you can use this kind of design if you want that but personally i don't like to do this because it's going to make your code much more hard to read and understand if you want these guys to be public or protected why not make them public or protected in the first place and really not use private inheritance that's going to be much more direct to see and understand and your code is going to be easier to work with for you in the future or for some other developers that will get to work on your code in the future so this is the message here you can use this feature to resurrect members back to a relaxed access level and now that you have an idea about this we're going to head over to visual studio code and play with us a little more here we are in our working folder the current project is resurrecting members back in context we are going to completely reuse the code from the last lecture because it's going to give us a good starting point we can copy everything except for the binary here we don't need that in our current project we're going to put in our starter code and we're going to open this little guy in visual studio code so we're going to have our code we're going to have our main function and we're going to have all these objects created here i'm really not sure if we're going to need this yet so let's take this out and we're going to look at our personal class it is going to have our members here and we are going to have a bunch of getters which are going to be returning these member variables and we have a constructor here which is really going to build a person object nothing complicated here we have an engineer class which is going to privately inherit from person and we know that this is going to eclipse everything that is not private in the person class to private level access so everything is going to be private to the engineer class now but sometimes we don't want to do that for example if we go down in our civil engineer class we're going to see that the get full name and the getage methods are going to be private to the app stream engineer class and that's going to break the code for our output stream operator and it's not going to work because we want to have access to get full name and get age and that's also going to kill access we had on the get address method which would give us access to the address member that we have in our person class let's make sure we are looking at person i am confused here we have a lot of pieces of code here where is the person header it is down here so we have the get address method which is going to return the address we want to have access to that in our civil engineer class to be able to print all this information if we also want to print the contract count we can go in our engineer class and put in a method which is going to return that so we can say end and say get contract count and this is going to be a const member function because it's not going to be modifying our object we're just going to return a value we're going to return the contract count and we can go in our civil engineer implementation file and change this to say operand get contract account we can do that okay we have this method now we want this to work this is going to work because we are doing public inheritance from the civil engineer class but we want this to work we want to get full name get age and get address to work here and we can use the using feature to resurrect these members to an access level which will allow our civil engineer class to pick them up so we can go in our engineer class and set up for example a public or protected scope we're going to use protected because we want these to only be accessible from inherited classes for example so we're going to say protected and we're going to say using this is the syntax we're going to say person and we're going to say get full name we're going to say", "88495.832 - 88796.64": "this and we are going to say using person and say get address i think we have that method here the moment we do this we're going to go in our civil engineer class you're going to see that it is going to work now because what we just did is resurrect these members to have protected access level in the engineer class so the inheritance classes are going to look at this and see that they have a protected access level in the engineer class and they are going to be forwarded down to any inheritance class we could also change this to public this is also going to work they are going to be inherited as public and hopefully you can see that any member that you resurrect it's going to take the excess level of the section where you resurrect it if we resurrect them in a public scope they are going to be resurrected with a public access level if we resurrect them in a protected scope they are going to be resurrected with protected access level and this is the message here now if you happen to have a bunch of overloads in an upstream class for example suppose we have a bunch of add functions in the person class we can go in and put in let's do that we can go down and say double or ent let's say and that's going to be much simpler we can say add and say end a and say ent b and say ent c we're going to have three things that we are adding this is going to be a const member function it's not going to be modifying our members in any way so we're going to return a plus b plus c this is something we can return from a member function here and we're going to do an overload of the add member to do the addition of two parameters so we're going to only have a and b and i think we can use a and b in the first overload here that's going to be much easier to follow so we have one that adds two parameters and we have another one which is going to add three parameters if we privately inherit from person these guys are going to be stripped down to private level access in the engineer class and they want to be accessible from in any other downstream class so for example if we head over in our civil engineer class and try to say add 10 to two for example we're going to get a compiler error because we don't have access to this but we can also resurrect these ad members in our engineer class so let's go there and we're going to set up a public section in this class here and we're going to say using person add this is going to resurrect all the overloads that we have in our upstream class and this is going to be the case because we resurrect only based on the name of the function and the same name for a member function can be shared by many overloads so if we do this kind of resurrecting we are doing for the add member function from person we are going to get all the overloads if we go in civil engineer we will be able to use the member function taking two parameters we will also be able to use the one that takes three parameters they are all going to be resurrected here this is the message i want to convey if we do this you're going to see that this is going to work and our code is going to just world fine let's build and see if the build is good actually we're going to pass this through gcc the world is going to be good so everything is working just fine and the message i really wanted to convey is that it is possible to resurrect members in a more resurrected access level if you are inheriting using a really constrained base class access specifier for example we are inheriting using a private access specifier this is going to eclipse everything we get from the upstream class to private level but if you think that's too much and you have a few members that you would like to put in a more relaxed access level you can use this resurrecting feature and it is going to make things accessible in downstream classes if that's what you want in your program and again i hope this drives the point to home that ziploc plus is going to sometimes work really hard to prevent you from doing one thing and then again give you a back door you can go through to do that same thing this is the same thing here we are doing private inheritance but we aren't allowed to kill or relax the effects of private inheritance", "88796.64 - 89097.36": "access level and you can use this if it makes sense for your code again i don't like this personally because it's going to make code confusing if other developers see that you are doing private inheritance they are going to expect everything from the app stream class to be private to the class that is doing private inheritance and if they see that they can use this thanks that should be private by default and downstream classes this is really going to confuse them and it is going to cost them more minutes to look at your code to really understand what is going on so if you really want this dance to be accessible in downstream classes why not do public or protected inheritance in the first place this is my argument here but it is going to be your choice my job here is to make you aware of the possibilities that you have in the ziploc plus programming language okay the last thing i want you to see in this lecture is that if there is something that was already private in an app stream class you can't resurrect that if you try to do that you're going to get a compiler error this is also going to drive the point home that you can also resurrect member variables so far what we have only resurrected was all member functions and we can also resurrect member variables so we're going to try and resurrect the m address member in the engineer class and let's see how this works out so let's go in our engineer class we can go in our protected section we can do this really in any kind of section we're going to say using and we're going to say person and we're going to say m address you see that this is not going to be available in autocomplete this is going to be a sign that this is going to give us a compiler error and if we're trying to do that we're going to see that we're going to get a compiler error the message here is that if something is already private in a nap stream class you can't resurrect it it is it claps down forever and hopefully this drives the point home again that private inheritance is really serious for example in our civil engineer class we can't resurrect something that was already eclipsed to private level access by the engineer class let's go in our personal class and see if we have any other member function we can play with we're going to put in a member function that says do something we're going to say void do something and it's going to be constant it's just going to say hello we can do something like this we are learning and this method is going to be eclipsed down to private level access because we are doing private inheritance from person let's go back in our engineer and comment this out because it is going to give you a compiler error if you build you're going to get a weird compiler error i think i should really show you this because we are learning here so we're going to try and build our program anyway we're going to pass this through gcc and we're going to see the kind of compiler error we get and we are going to see that there's no member std this is a problem we just introduced in our class here i think to solve this problem we can just put our definition in the cpp file we can do that we're going to grab this and we're going to put the definition in person.cpp because we have io stream included in there this is going to make our code work much better let's do this we're going to say void and say person and we're going to say sddc out hello this is going to fix our problem here and the only problem we will have will be in engineer where we are trying to access things that are now private to the base class why do we have this weekly line here let's take out this and try to build really make sure that this problem is not existent and it was a visual studio code messing with us so we're going to bring this in and the world and we're going to see the kind of compiler error we get here this is what i am trying to make you see you see the bullet is finished with errors if we go back we're going to see that string person m address is private within this context we can't really resurrect it if we do this we're going to get this compiler error here this is the message you shouldn't really try to resurrect something that is already private to an upstream class and that's what we are doing here we are trying to resurrect a member which is private to person and this is not allowed in c plus plus if we do that we're going to get a compiler error okay so but what i want you to see here is that a public member which was in the base class was also eclipsed down to", "89097.36 - 89396.96": "we try and resurrect the do something method in our civil engineer class we're going to get a compiler error so let's try and do that we're going to put a public section why not and we're going to go down and say using person and it say do something we have this method here but if we do this we're going to get a compiler error because this method is now private to the engineer class and why is it private to engineer well engineer is doing private inheritance that's going to accept everything to private level access by default so this member is private to engineer we are inheriting from engineer in civil engineer and this is going to be already private to engineer and we can't resurrect this back so if you eclipse something using private inheritance you want to be able to resurrect that to a more relaxed access level in downstream classes this is the message i am trying to convey here so this is also going to give us a compiler error and if we try to build our program we're going to see that let's pass this through gcc we are going to see that's the world finished with errors and if we go back we are going to get some kind of error that says that do something is private to some class it is inaccessible within this context this is the message we get from this particular compiler we are using but the bottom line is that you shouldn't really try to resurrect something that is already private to an upstream class and this is what we are doing here you shouldn't really do that let's comment this out and get a code to compile again so the web is good and we are all fine here this is really all i had to share in this lecture i hope you found it interesting we are going to stop here in this one the next one we're going to explore how constructors work with inheritance go ahead and finish up here and meet me there in this lecture we're going to zoom in at how derived objects are built and we're going to zoom in on the constructors that we have been ignoring on purpose so far so here we have the inheritance hierarchy we will be using it is what we are familiar with at this point we have a personal class which is going to be our base class we have an engineer class which is now going to be doing public inheritance because we have seen enough of private inheritance our engineer class is now going to be nice and say i am inheriting from person but i also want my downstream classes to have access to the cool stuff i am getting from person this is how our engineer class is behaving now we are also going to have a civil engineer class which is going to publicly inherit from engineer but what we want to focus on here is what we get from base classes so the engineer class is going to have a person part of that but it is also going to build on top of that and add an engineer level and customize what kind of person it is so if we inherit from engineer and that weld our civil engineer class the first link to be built by c plus plus is the person part of this it is going to build an engineer level of this and then we are going to add a civil engineer level to add the customizations that the civil engineer class is adding and a c plus plus is going to do this using constructors by default we are going to be using default constructors if we don't specify a way for the basical structure to be called c plus plus is going to call the default constructor to build your base objects so if we set up something like this and try to run a program we're going to get output like this we're going to see that the person default constructor is going to be called first and notice that we are building a civil engineer object so the default constructor from the most base class is going to be called then we're going to be building an engineer layer on top of the person stuff that we get then we're going to build a civil engineer layer on top of the engineer stuff that we have already got and the compiler is going to do this using the default constructors by default so we're going to call the default constructor for person first we're going to call the default constructor for engineer and then we're going to call the default constructor for civil engineer to complete the construction of our object the object will be complete at this point and we will be able to use it later on in our program here and hopefully this is going to drive the point home that you should really really always provide to the photoconstructors for", "89396.96 - 89695.04000000001": "call these default constructors in unexpected ways especially if your class is part of an inheritance hierarchy for example if somebody tries to build the civil engineer object and you don't have a default constructor for a person the compiler is going to try and code that and it's not going to find that and it is going to throw a compiler error as we are about to see in a minute okay so the message really in this lecture is that the most base part of your class is going to be bolt so for example for our civil engineer class we're going to build the prison port first then we're going to build the engineer park and then we're going to build the civil engineer part of that and then we're going to finish the construction of our object this is the message here now that you notice we're going to head over to visual studio code and play with this a little more here we are in our working folder the current project is default argument constructor with inheritance we are going to reuse the code from the last lecture because that's going to give us the classes that we need to play with what we want to do in this lecture and that's playing with default constructors let's put in our starter code and we're going to open this little guy in visual studio code let's do this so we're going to have our classes we're going to have the main function which we can play with and we are going to look at the person class and make sure we have a default constructor we are not going to default it this time because we want to have a body we can put our output statements in so in this case we're going to go in the cpp file and put in a default constructor we're going to say person and person and person here and this is going to be our constructor we're going to say stdcl defaults constructor for person called okay so the personal class is done we have a default constructor that works as we want and we're going to go to our engineer class and we're going to change it to do public inheritance i think this is going to be much easier to deal with now and we're going to remove all these resurrection we were doing here from the last lecture because this is no longer going to be needed and what we really want is to look at our default constructor which is really in here already let's look at the implementation all we really need to do is put in sddc out and say default constructor for engineer called and we're going to hop over to the civil engineer class and see if we have a default constructor and we do have it and we're going to go to the cpp file and say sddcl default constructor called for civil engineer so this is going to basically do what we want and what we really want to see is how or the order in which our constructors are going to be called if we build a civil engineer object as we have seen here the person part is going to be built first so this is going to call the constructor from person and because we are not doing any kind of customization on which constructor is going to be called the compiler is going to call the default constructor by default so we're going to build the person port first and we're going to see the default constructor for a person called after that we're going to build the engineer part of us and this is going to call the default constructor for engineer and after that we're going to weld the civil engineer part of us and that's going to call the civil engineer default constructor this is what we want to see if we build a civil engineer object so we are going to hop over in the main cpp file and actually build the civil engineer object we're going to say civil engineer and we're going to say ce1 we can do that and we're going to see what happens let's try and build this program we're going to build that with gcc the book is going to be good we could run it let's bring up a powershell window we can play with we want to bring up a powershell window we can clear and run rooster and you're going to see that default constructor for a person called the first constructor for engineer called default constructor for engineer called this is what we want to see and hopefully this proves that the compiler is really going to build a civil engineer object in parts the compiler is going to see that it is a derived object and it's going to see all the classes that this is deriving from so it is going to build the most base part first after that it is going to build other layers until it reaches the", "89695.04000000001 - 89996.31999999999": "engineer objects again if we put another statement out here i'm going to say hello in here and we're going to say sdd-endl and i am doing this so that i just have a point where i can put my breakpoint some ides are not going to like it if you put a breakpoint at an empty line so that's why i am doing it here and i am going to try and debug and really show you that we have an engineer and a person part in us i have shown you this before but it doesn't really hurt to repeat this because debugging is really cool it's going to give you more information than you could ever ask for we're going to hit our break point here and if we look in our locals we're going to have our civil engineer object which is in scope now and you see that we have an engineer part of us and the engineer has a person partner so what the compiler is really going to do when it is building a civil engineer object it is going to build the most based part of us so it is going to build a personal part after that it is going to build an engineer layer on top of that and then it is going to world the servo engineer layer and that's what we see in our output when we get to run our program here if we go back we're going to see that we still have our binary we can still run it let's bring up a terminal window we can use to run this we're going to run rooster and we're going to see the order in which our constructors are called this is really cool now that we have just debugged this program you can take out this hello line because it's really useless and this is really what i wanted you to see constructors are going to be called in your inheritance hierarchy starting from the most basic going down to the most specialized one so we're going to call the most best constructor which is person and we're going to keep going until we reach the most specialized which is a civil engineer here to build our object and our object is really going to be build up in layers this is the message i am trying to convey here this is really all i had to share in this lecture i hope you found it interesting we are going to stop here in this one the next one we're going to see that we can actually actively call a base class constructor from our derived class and that's going to add much more flexibility in how our objects are built we are not going to call the default constructor we're going to be calling our own constructors and have much more control on how our derived objects are set up in the world go ahead and finish up here and meet me in the next lecture in this lecture we're going to see a way we can instruct for custom constructors to be called when our derived objects are being built and set up in the last lecture we saw a figure like this we had an inheritance hierarchy that went from person to engineer and to civil engineer and we saw that if we set up a civil engineer object a personal part is going to be built first an engineer part is going to be built on top of that and the civil engineer part of that is going to be built and then we're going to have the construction complete for our civil engineer object but in the last lecture we saw that this was calling the default constructors and sometimes you don't want this you want your objects built in a specific way for example through a bunch of parameters that you pass to your constructor what if you want this kind of setup this is what we are going to learn about in this lecture and what we want to end up with is something like this we will be able to build a person object by passing in a bunch of parameters we can pass in the full name we can pass in the age i think this is the age we can pass in an address we can build an engineer object by passing in this kind of information we can pass in the name the age and the address but we can also pass in the contract count i think this is the new member variable we had in our engineer class but we're not going to stop there we can also build the civil engineer object and we can pass in the information again a civil engineer is also a person so we're going to be passing the information that is going to initialize the person part and that happens to be the name the age and the address but a civil engineer is also an engineer so we're going to pass information that portrays to the level of an engineer and that's going to be the contract count and we're going to pass the information to initialize the civil engineer part of this object and that's going to be the road strength and hopefully from this you can see that we need a way to forward all this information to the constructor where this information is needed for example if we are building a", "89996.31999999999 - 90295.512": "the name the age and the address to the person part of us so we need to parse this to our personal constructor in a way we need to pass the 31 here to our engineer constructor because this information is going to be stored at our engineer level and we need to store the road strength information into the civil engineer part of us because that's where this member variable is declared hopefully you can see the need to call custom constructors which are not to default these custom constructors are going to allow us to forward information when building our objects like we are doing here in the main function so let's see how we can do this some of you might think uh-huh if i am building an engineer object i can just grab the information and pass that to my base class and that is simple right so we can grab all this information we can grab the full name the age and the address and pass that to our base class using the syntaxes we have here if we are doing public inheritance we're going to have access to these guys anyway so we can say full name equals full name mag equals age and say m address equals address except for the address is actually private to the person class and we can't do something like this if we try to access the address member variable from the base class and modify it we're going to get a compiler error that says that the address is actually private to the base person class we can't do this so this is not going to work okay some of you might think uh-huh what if i try to use an initializer list and do something like this so i can say m full name and pass in my information i can say mh and put in my information i can say m address and put in my information and then initialize the member variable that actually belongs to the engineer class that we are trying to build an object for here and hopefully this is going to work except the compiler is not also going to accept this the reason is with initializer lists you can't initialize a member variable that doesn't belong to the class that you are trying to build an object for so for example here we are trying to initialize m full name mh and m address but these member variables don't belong to the engineer class that we are trying to build an object for so we're going to get a compiler error here this is not going to work it is not engineer's job to build or set up this member variables so this is not going to work okay so how are we supposed to forward information from derived classes to base classes not to worry here we can still use initializer lists but we are going to use constructors whose job is going to be to initialize these member variables so if we are building an engineer object and we have information that really belongs to the person part of us we're going to call the person constructor to actually use this information to build the personal part of us and we're going to be calling the person constructor in our initializer list here and after we do that we're going to initialize a member variable that actually belongs to us in our initializer list this is going to forward information from derived classes in this case the engineer is the derived class and the information is going to be forwarded to the person constructor which is our base class this is how this is going to work okay now that you know this we're going to head over to visual studio code and play with us a little more here we are in our working folder the current project is constructors with inheritance we are going to grab the code from the last lecture because that's going to be our starting point and we're going to paste this in our current project we are going to open this little guy in visual studio code by dragging and dropping here and this is going to give us our starter code we're going to have a person class an engineer class and a civil engineer class and this is basically going to set up the hierarchy we have here and what we want to achieve is to be able to call our own custom constructors when we build our object in layers information is going to be coming from a civil engineer object and we are going to initialize the person part of us with relevant information we're going to initialize the engineer part of us with relevant information and we're going to initialize the civil engineer part of us with relevant information this is what we want to achieve okay for that to work we need to not call default constructors we want to", "90295.512 - 90596.0": "to grab the information and forward that in our member variables for example in person we have a constructor which is going to take three pieces of information and it is going to pass this information into our member variables we need to apply a few changes here for example our third parameter is passed as a cost strength member type we are going to change this to be std strength view because this is going to save us on copies let's say string view here this is going to work and this is going to forward information in a way we want we're going to change our third parameter to bhtd string view let's say string view here we're going to say std string view this is what we have in our header we're going to be having the same signature for our function here and what is wrong we have m full name mh and we have m address here let's try to build and see if the error goes away sometimes visual studio code is playing games on us if we get a compiler error we're going to try and fix that you see that it is visual studio code playing with us the code is just fine here so we have our constructor for person it is going to forward information using our initializer list here we're going to look at our engineer class if we go there we're going to see that we don't have any constructor which is going to grab information in any meaningful way and put that in our class so we are going to put in a constructor that looks like the one we have in our person class so we can just grab this i like copy and pasting because that's going to save me a few seconds so i am going to put my constructor here only it is not going to be called the person it is going to be engineer and i am going to add a construct count member and this is going to be an integer here to keep things simpler and we are going to put an implementation of this constructor in our engineer class we can go down here and put that in front of other constructors let's look at the order we have in our header because i like to be consistent the default constructor is first so this constructor is going to be second and we're going to say that it belongs to the engineer class using a scope resolution operator here and we are going to put in our initializer list now what we want to do is to call the constructor for person to initialize a person part of us and then we're going to grab the information from the contract count and we're going to forward that in our own member variable the way we're going to achieve this we're going to call the person constructor and we're going to pass in the full name we're going to pass the age and we're going to pass the address and then we're going to initialize our own member variable which is contract count i think let's go to the header and look at that we're going to see that our member variable is contract count so we're going to say contract count and we're going to say contract count param we're going to name this differently because we don't want issues with naming here so let's name our parameter here param this is going to not confuse the compiler and once we have this end we can just put in the body which is going to be empty because all the initialization is now done in our initializer list here so if we do this we're going to see that the compiler is going to be happy with our thing here we're going to go down in our civil engineer class and we're going to grab the constructor we have an engineer because we're going to be using this as a starting point we're going to copy it and go in our civil engineer class we're going to see that we don't have a customer constructor we're going to put this and we're going to name this civil engineer and we're going to add a speciality member that we want to initialize so we're going to say std string view because we want to forward string data we're going to say std string view here and we're going to say speciality and we are going to put the implementation of this in our cpp file for a civil engineer we're going to put this below our default constructor let's grab this i lost the desk somehow so we're going to copy and we're going to paste down here we're going to say that this constructor belongs to the civil engineer class i'm going to use our scope resolution operator and after this we're going to put our initializer list in civil engineer we will call our engineer constructor", "90596.0 - 90895.28": "we're going to pass in the full name we're going to pass in the age we're going to pass in the address and we're going to pass in the contract account which we will get from our constructor from civil engineer but we will also initialize our specialty member variables so we're going to say m speciality and we're going to pass the spatiality information here and this is going to initialize our then we're going to put in an empty body and our information is going to be properly forwarded to our base classes so if we build the civil engineer object proper information is going to be forwarded to the engineer part of us and the proper information is going to be forwarded to the person part of us now that we have this in place we can put in our htdc out statements to let us know which constructor was actually called to build authen we're going to say that it was our custom constructor that was called let's say that here we're going to say customer constructor called for civil engineer we are going to go to our engineer class and also say the same thing let's go to this cpp file for that and we're going to put in our htdc out statement and we're going to say custom constructor we can copy this to be consistent with what we had in our constructor default constructor i should say and we're going to say custom constructor called for our engineer class we're going to go back to person and we're going to go to the implementation file and we're going to copy the message from our default constructor and we're going to put this in and say that the custom constructor was called for person here so now that we have these guys in we can go to our main cpp file and include the classes they are included here we can try to create a person object just like we saw in the slides and we're going to try and build this program and see which constructor is called to set up this person object this shouldn't be rocket science by now we know that our custom constructor is going to be called because we are passing three parameters which should be forwarded to our member variables through this initializer last so let's build with gcc and make sure this is what we expect we're going to use our compiler here the bolt is going to be good as you see here and if we bring up our powershell window and run rooster we're going to see that our custom constructor is called let's bring up the main cpp file so that we can see our thing we are passing this information here and we are printing our person object and we're going to see that the full name is jon snow the age is 27 and the address is winterfell called and all this gibberish we have here our constructor is really being called okay so this is working we can also set up an engineer object and see that the information is being properly propagated to the person part of our engineer object because engineer is inheriting from person we are passing the information for the full name the age the address but we are also passing in the contract count which should be used to initialize the engineer part of us so we are going to run the task to build with gcc the build is going to go through successfully and we can bring up our powershell window and run the program again we're going to see that we're going to branch the information for person custom constructor for person called but what we really are interested in here is seeing that the custom constructor for person is called for building our engineer object and then we call the engineer constructor and again this falls in line with what we saw in the last lecture the most based constructor is called first and then the must specialize constructor is called last in this case we are just setting up thanks in such a way that our custom constructors are called and we do that from our engineer class by calling the base constructor explicitly using the syntax that we have here in our initializer list after we have the base constructor called we are going to initialize our own member variables and that's what we see and in this way the information for the current class will be initialized properly and this is what we see here i think this is a little bit misleading because we still have the information from the person objects that we bought printed out here we can comment this out", "90895.28 - 91195.44": "through gcc to build our program the build is going to be good we can clear and run rooster and we're going to see that the custom constructor is called for a person to set up the person part of us and then another layer of engineer is going to be set up in our object to initialize the contract count member variable part of us and we're going to have the information here so if we print the full name we're going to get daniel gray the age is going to be 41. the address is going to be the gibberish we expect here and the contract count is going to be passed in successfully and this is really cool we can also comment this out and set up a civil engineer object we can do that okay so let's go down and put this in place we're going to create a civil engineer object we can close up the left side bar here to have some more breathing room we're going to build a civil engineer object we're going to pass in full name age address contract count and a speciality which i think we expect from our civil engineer custom constructor here that's going to be an std strength that's what we are passing in here i should say that's going to be a string view but we can pass in string data just like this and the string view is going to take so what we're going to see here we're going to see the person constructor called the person custom constructor i should say we're going to see the engineer custom constructor called and after that we're going to see the civil engineer custom constructor called to pass and forward all this information in related parts of our civil engineer object let's build and see that this is actually going to even compile the book is going to be good we can clear and run rooster and we're going to see that this is exactly what we expect the custom constructor for person is going to be called after that the custom constructor for engineer is going to be called and then the custom constructor for a civil engineer is going to be called and this really falls in line with what we expect if we are building a civil engineer object and the civil engineer class happens to be inheriting both from engineer and from person we're going to have the person part of us world first and because of this we're going to see the person constructor called but in this lecture the rio focus is getting our custom constructor called so the person custom constructor is going to be called after that we're going to call the custom constructor for the engineer part of us and that's going to set up the engineer specific member variables in our object after that we're going to set up another layer of civil engineer in our object and this is going to initialize the member variable that belongs to the civil engineer part of us in our object so this is really the main goal in this lecture showing you that you can set up fans in such a way that your custom constructors are called when setting up your object in layers as you see here okay now that we have this working i want you to see that there are some bad ways to do these things and some people are actually going to try to set things up in that way the first bad way is to try and initialize our member variables in the body of the class if you do things like this again this is going to work because full name and age are going to be inherited publicly from the person class so the code here is going to work but we have no way to initialize the address member variable because it is private to the person class so if we try to access that we're going to get a compiler error let's try this out in code and see the actual compiler error to try this out i am going to comment out the good code here and i am going to copy and put in something that is going to be problematic as we saw in the slides i am going to paste in my constructor here i should close my powershell window here and i am going to take out my initializer lust because we're not going to be using that here and we're going to just grab the data and use that to initialize our data in our member variable here so we're going to grab the full name and say m full name equals full name we can do that we're going to say mh equals h that's the information we get we're going to say m address and you see that we don't even have that in autocomplete so we're going to pass the address we're going to be stubborn and ignore these squiggly lines and we're going to say m speciality and we're going to grab the speciality and pass that in but you see that line 26 has a bunch of squiggly", "91195.44 - 91497.12000000001": "and the reason is the m address member variable is invisible and not manipulable from a civil engineer class again the reason is that the address member variable is private to the person class so the civil engineer class has no business initializing this in the body this is not going to work so if we try and build this we're going to pass this through gcc we are going to see that the world is going to finish with errors and if we go up we're going to probably see the error person m address is private within this context and we have no business accessing that in the civil engineer cpp file at line 26 this is what we see here and this is the offending line we shouldn't really be doing this if we comment out this line this is going to work but our member variable is going to be left with a junk value and this is really not good because our address that we worked so hard to set up in our parameter here is just going to be ignored so this is bad you shouldn't really be initializing your member variables like this especially if you have an inheritance hierarchy in your classes so we're going to comment this out and say that this is really bad it's going to give you compiler errors and some of you are going to say okay this is not working but what if we try to use an initializer list directly let's see if that actually works we are going to set up another constructor here and we are going to set up the data in our initializer list we're going to say let's say m full name and pass in the full name we can do that let's try this out we're going to say mh and we're going to pass age we can do that and we're going to grab the address and we're going to pass an address here and after that we're going to say m spatiality and we're going to pass in our spatiality information what if we do something like this but you're going to see that we have squiggly lines here and the problem with this way of doing things is that the civil engineer class has no business initializing thanks that belong to the person class in the initializer list your initializer list only has the capability to initialize the member variables that belong to the current class and m full name mh and m address don't belong to the cipher engineer class that's why we're going to have a compiler error if we try to set up things in this way if we're trying to build the program we're going to get a weird compiler error we're going to see that the build is going to finish with errors and it is going to say expected initializer before m full name and we need a column column here sorry for this so this is not the error we expect but you see that the moment we do this we have a bunch of squiggly lines on full name age and address and let's build and see the problem we have and we're going to build with errors as we see here if we go up we are going to see our errors civil engineer does not have any field called m full name we're going to see that civil engineer doesn't have any field called mh and civil engineer doesn't have any field named m full name or m address here that's the problem we have no business initializing these member variables that don't belong to the civil engineer class in the first place so this is also not going to work the best bet we have already is to call the best constructor and let that initialize the member variables that belong to our upstream class in the inheritance hierarchy for example in our civil engineer constructor here we need to call the engineer constructor to initialize the engineer part of us and we're going to be forwarding the information the full name the age the address and the contract account the engineer class is in turn going to call its base constructor to forward the information about the full name of the agent the address and it is going to initialize its own member variable m construct count and the information is going to be passed in correctly and if we try to build our class now we're going to see that everything is going to work and i really wanted you to be aware of this because the moment you understand this you're going to set up your inheritance hierarchies in a way that is going to make sense and you're not going to be getting all these weird compiler errors this is really all we set out to do in this lecture showing you how you can set up your own custom constructors in your own inheritance hierarchy and at the moment you do that you're going to get your classes called in the order that", "91497.12000000001 - 91795.12": "in layers the base constructors are going to be called in a way that you expect and your objects are going to be built in a way that you can print them and see the information that you expect set up in your object if you want you can also use a debugger to see the information in your thumb so we're going to set up a breakpoint here and we're going to bring up our debugging tab we're going to hit the green button to start debugging this program the binary is going to be set up once the vote is good the binary is going to be passed in our debugger and we are going to hit our breakpoint in a minute let's wait for this so we have hit the break point at line 20 and if we expand our civil engineer object in our locals we're going to see that we have an engineer part of us we can expand that and see that we also have a person part of us if we look at person we're going to see that the full name is we can see john travolta which is what we are passing here we can also look at our age the age is 51 as you see here and we're going to also have information about our address if we expand this we're going to see that the address is this gibb brush that we just put in tiny dog 42 stret and number 89 we can see this information here and you can really expand and see all these things that make up our object for example we can see the information about the contract count which is 31 and it is what we are passing when we build this object here and the speciality happens to be road strength as we see in our locals here you can really see all these things we are going to stop here in this lecture in the next one we're going to explore how copy constructors work in our inheritance hierarchy so go ahead and finish up here and meet me there in this lecture we want to explore how copy constructors work with our inheritance hierarchies and we will still be using the same example we have been using in this chapter we will have this inheritance hierarchy and we will still be using the same example we have been using in this chapter the base class is going to be person we're going to be inheriting from that publicly to create an engineer class and we will be inheriting from the engineer class publicly to create the civil engineer class and with this we want to be able to copy construct objects and the code we want to be running is something like this we have an engineer object we want to be able to create another object from this engineer object using the syntax here and from what we already know this is going to call our copy constructor the funny thing is this is going to work by default even if you don't put in your copy constructor the reason is the compiler is going to insert a copy constructor for you and things are going to be copied in a way that you expect because none of our classes is using dynamic memory allocation so everything is just going to fall in place and it is going to work but if you happen to need to set up your own copy constructor we're going to see how you could do that in this lecture and we're going to start by the base class we're going to set up a copy constructor for the person class and this is nothing complicated we just pass our parameter by reference this is going to be our source object and we will be copying the data from our source object to initialize the member variables in the current object that we are copying here again this is a copy constructor which will be copy constructing from the parameter that we pass by reference now how do we do the constructor for the engineer class which happens to be inheriting from person try to think about that one way to do things is to set up things like this and this will be just initializing the engineer layer of our class but nothing is going to be initializing the person part of us and this is bad this is going to call the default constructor to initialize the person part of us and we will just be left in with junk data that is initializing the person object by default and all the data we have in our parameter engineer object is just going to be lost for the person part of us so we don't want to do this this is bad design you shouldn't do this some of you are going to say but what if we call the best constructor we have seen that we could do that right but remember this is a copy constructor what we have on the left is an object and it happens to be that if you set up a syntax like this with the copy constructor the compiler is", "91795.12 - 92095.44": "object and a copy from that object to initialize the person part of us so this is going to be creating a temporary copy object containing the same data we have in our engineer object so to some extent this is going to work but the problem we still have is that we are using the m address member variable directly from an engineer object and from what we already know this m address member variable is private to the person class and we have no business accessing this from an engineer construct so this is going to give us a compiler error but you know that it is possible to set up a getter in the engineer class that is going to return this address and you can call that together here and get this thing to initialize your data this is going to work but this is really weird you shouldn't do this this is bad design there is a better way i am going to show you but before we look at that wave let's try and summarize the problems we have with this way of doing things this is not going to be reusing the copy constructor we have worked hard to set up in person so this is just going to be called duplication another thing is that the m address member variable is private to person so if we try and use it like this we're going to get a compiler error again it is possible to set up a getter that could return that and we could use that getter in this place but this is bad design we are really forced to set up a getter that is possibly only used in this place that's bad design we don't want to do something like this another thing is that this is going to create a temporary copy of person from which we will be copying to initialize the person part of us we don't want to be making that copy because we hate copies in c plus plus code so the best way to do this is to set up your copy constructor in this way we are going to say person and directly passing our engineer object the compiler is smart enough to see that we are passing an engineer object to initialize a person object and what the compiler is going to do is really smart suppose our engineer object is made up of two layers the inner layer is going to be containing the information about the person part of us and the outer layer is going to be containing the engineer part of us okay so this is the setup we have so the compiler is going to see that we are passing in an engineer object to initialize a person object and what it is going to do is really smart it is going to strip off all this engineer part if i can describe it like this we're going to strip off all this engineer part that we have in our engineer object and we will be just left with the person part that we passed then to initialize our person object and this is really smart and it is going to work so again the syntax is what you see here we say person we pass in our source object and then we can initialize the member variable that belong to the engineer part of us we will be initializing contract count and this is going to work now that you know this we're going to head over to visual studio code and play with us a little more here we are in our working folder the current project is copy constructors with inheritance we will be reusing the code from the last lecture so we're going to grab everything from that except for the binary and we're going to copy that and put that in our current project let's do this and we are going to open this bad boy in visual studio code by dragging and dropping here and we will have our starting point we will have our person class the engineer class and the civil engineer class and we will just be doing public inheritance to make things easier here so engineer is going to publicly inherit from person and civil engineer is going to publicly inherit from engineer and this is everything we had from the last lecture nothing special but what we want is to set up copy constructors in such a way that we will be able to build objects from others for example if we leave in our engineer object i think this is what we used in the slides we're going to have our engineer 1 object we want to be able to create a another engineer let's say engineer two and above that from engineer one the thing that might be puzzling to some of you is that this is going to work out of the box even if we didn't really put in a copy constructor but the thing is the compiler is going to insert a copy constructor for you but that constructor is going to be memberwise copy so it is basically going to be copying thanks memberwise it is going to", "92095.44 - 92397.04": "one and copy that into engineer two and we are basically going to have the same data from engineer one in engineer two let's try and print engineer two can do that we're going to say and two and we're going to put this out and we are going to run the task to build with gcc that's what we want here and you're going to see that it is going to work out of the box if we bring up a powershell window and run rooster we're going to see that we have the data in here we have engineer full name daniel gray that's the data we have in engineer one but notice that we are printing engineer two here the age is going to be 41 and the address is going to be exactly what we had in engineer one and you're going to see that the constructors are going to be called to set up engineer 2 and the custom constructor for a person is going to be called the custom constructor for engineer is going to be called and this is exactly what we expect here but what if we want to set up our own copy constructor and the need to do that might arise if we happen to be doing some dynamic memory allocation in our classes suppose maybe person class has some dynamic memory allocation it has some pointer member variable and in the personal custom constructor we are doing some dynamic memory allocation to initialize that pointer we may be doing the same thing at the engineer level or the civil engineer level and that will force you to set up your own copy constructor and we're going to see how you could do that in your classes we are going to start with the person class we're going to go on top and set up a copy constructor in front of our destructor here we're going to say person and we're going to say const person reference source this is the syntax you use to set up your copy constructor you already know this from a previous chapter and we're going to put in the implementation for this we're going to go in the cpp file before the destructor or we should go after our custom constructor it doesn't really matter where you put this and we're going to put in our scope resolution operator let's do person here and we will just be copying the data from the source person so we're going to put in our initializer list and we're going to say m full name we're going to grab the name from the source person we're going to say source m full name we're going to initialize the age we're going to say mh and we're going to grab the age from the source person so mh here and we can go to the next line so that we see the entire thing here and say m address and we're going to say source and say m address this is going to set up our constructor and down below we can put in our body this is going to work but this is everything we have seen so far this is nothing new the syntax to set up your copy constructor you just pass it by const reference if you don't pass by reference here you're going to get an endless chain of copy constructor calls if this is confusing to you please go back to the chapter on classes you're going to see everything about this and this is really all we need to do here to have a copy constructor for a person now let's do things at the engineer level we're going to go to our engineer class and we need to set up a copy constructor the syntax is going to be the same we're going to say engineer and we will be constructing from a cost engineer object we pass as a parameter here so we're going to say cost engineer by reference and say source and the problem is going to be how we implement this thing we're going to copy this and go in our engineer cpp file we're going to put our copy constructor after our customer constructor and we're going to put in our scope resolution operator we're going to say engineer and we're going to put in our body let's go below and put that in if we do things like this this is just going to initialize our engineer with junk data we don't want that but some of you might say uh-huh i don't know how to call my base constructor but at least i can initialize my contract count okay let's go back and see if we have this member variable here yes it is called contract count we can say contract count here and we are going to initialize this with source contract count this is going to work but this is going to call the default constructor of person to initialize the person part of us and let's go back in our main cpp file and see what we are using to try things out we are building an engineer object from another let's try this out and see if our copy constructor is called here so we're going to say custom copy constructor called for engineer we're going to put in the message and we're going to say custom copy constructor and we're going to build our code let's build we're going to pass", "92397.04 - 92695.512": "build is going to be good and let's see what happens we're going to clear and run rooster we are going to see that the constructors are going to be called to set up person one but we see that the copy constructor for engineer is called and what i want to do to really make this super clear is put a separator between these two guys to really know what is happening here i am going to put in a bunch of dashes just like this i am going to put in my new line character and i am going to bolt again the bolt is going to be good as you see here we can clear and run rooster now we are going to see that the default constructor for person was called to set up the person part of us in our engineer copy constructor and the reason is we are not doing anything to call the custom copy constructor from person and let's go back in person and make sure we are printing proper information to really see this when we get to do this right we are not putting in any message here so we should do that we are going to say custom constructor or custom copy constructor called for person but this is not called you see that we are calling the default constructor and this is going to initialize our person part with junk data if we print engineer two here you're going to see that the full name is none the edge is zero and the address is none so we are basically getting the default data we have in our person object let's go back and really show you that the default full name is going to be none the default address is going to be none of the edge is going to be 0 by default and this is what we get because in our copy constructor we're not doing anything to get our customer constructor in person to be called okay so this is not going to work this is bad we don't want to do something like this but let's comment this out and show you another way we might try to do things and we are going to copy our copy constructor let's go down and do this we're going to put in another copy of this but we don't want to just initialize our contract count member variable instead we want to do something else we're going to put a comma here and we're going to say person some of you might be thinking what if we call the base constructor directly we can do something like this we can say person and we can say source m full name we can do that we can say source mh and some of you are going to say source m address let's do that source m address and we're going to build the person object and use that to initialize the person part of us we are basically going to be calling the other person constructor that we have which takes three parameters this constructor here this is what we are trying to call in our copy constructor but as we saw in the slides this is going to have a bunch of problems this is going to be creating a temporary person object that we are going to be copying from to set up the person part of us but another problem we have which is actually going to cause a compiler error is that we don't have access to the m address member variable from an engineer constructor and this is going to give us a compiler error let's actually try and compile this program to really show you this we are learning we should really see as many compiler errors as we can so the world is finished with errors and if we go up we're going to see that our error is the m address member variable is private to the person class and we have no business accessing that in the engineer cpp file at line 27 in our constructor here and this is going to be our offending line we can't do this one could go in our person class and set up a public getter method which is going to be inherited by engineer and we could call that to return the address let's actually do that to show you that you can do that so we are going to go in and put in a public method which is going to return the address we actually have that here so we can call that we can say source get address this is going to work this is going to set up our thumb let's try to build because i think a visual studio code is messing with us here okay you see the both is good it is visual studio code which wasn't understanding our code here and if we run our program we're going to see that things are going to work exactly as we expect let's actually run the program here we're going to clear and run rooster we're going to see that now the information is being forwarded properly but we are setting up a temporary person copy which we are copying from to then forward the data to the person part of us this is not good design and what we really want is the setup that is going to allow us to call the copy", "92695.512 - 92995.44": "up in our base class here let's go back to person and see that if we go up we're going to see that we have a copy constructor we really worked hard to set up we wanted to reuse this in our engineer class and that's what we're going to see here so this is working but it is not optimal and we should really try to reuse our code as much as we can so what we're going to do is set up a mechanism that is going to reuse the copy constructor we have in person and all we need to do to get that to work we can say person and then call the copy constructor of person by directly passing in our source object notice that we don't need to set up a temporary person object we will directly be copying from our engineer object but this is going to do the slicing we saw in the slides again if we have two layers on our object the inner layer is going to be the person part of us and the outer green layer is going to be the engineer part of us what the compiler is going to do the compiler is going to see that we are actually passing again an engineer object to initialize the person part of us here and it is going to say that we just need the red part we don't need the green part here the compiler is really smart so it is going to slice off the outer engineer layer and only leaving the green person part and it is going to use that to initialize the person part of our engineer object and this will be reusing the copy constructor we have in our person object then this is really cool this is the optimal way to set up your copical structures if you have an inheritance hierarchy so let's try and build the code again we're going to pass this through gcc to see if this actually works the bullet is going to be good we can clear and run rooster we're going to see that the copy constructor is going to be called for person to set up the person part of us and then the custom copy constructor for engineer is going to be called to set up the engineer part of us and if we look at the information we have in the main function you're going to see that it is the same data daniel gray for the full name ages 41 address is this gibberish here and the contract count is 12 it is exactly what we passed here and our copy constructor is working now that we have this working we can safely reuse the same ideas in our civil engineer copy constructor we can head over in our civil engineer and set up the copy constructor so let's do that we can close the left sidebar here so that we see the entire thing we are going to say civil engineer and we want to set up a copy constructor so we're going to say cast civil engineer here and we will be passing this by reference we're going to say source and we're going to put the implementation of this in our cpp file we can hop over there and go below our custom constructor we can put in our constructor here we're going to say civil engineer and put in our scope resolution operator and we're going to go down and put in the body and in our initializer list we're going to call the copy constructor from engineer because remember civil engineer is inheriting from the engineer class so we are going to call the engineer copy constructor we're going to pass in source and again this is going to slice off the civil engineer port and only use the engineer part of us to construct an engineer object from this sliced of engineer object we get from our copy constructor here and this is really cool after that we will initialize our contract count member variable oh it is m speciality if i remember correctly and we're going to grab a source m speciality and we will use that to initialize the civil engineer part of us here let's go in and say that the custom copy constructor is being called here and we're going to say custom copy constructor called for a civil engineer what did we do here we said engineer let's do engineer this is what we want and we're going to say engineer here properly sorry for this but this is no big deal and now that we have this in place we can actually build civil engineer objects and copy constructed them we can comment out the engineering stuff we have and we can just put this in a black comment and we're going to copy construct civil engineers how cool is that we're going to set up a civil engineer let's do that and this is going to be a civil engineer and we're going to say daniel gray we're", "92995.44 - 93296.0": "going to specify the speciality to be road strength this is something i just made up i don't even know if this kind of speciality exists and we will set up another civil engineer object called n2 which we are going to be copy constructing from and we will see what happens when we copy construct this thing here we should call our copy constructor in civil engineer and the things should propagate up all the way to the person part of us and we're going to see what happens let's build this code we're going to pass this through gcc as we always do the budget is going to be good so this is good news we're going to clear and run rooster and we're going to see that the custom copy constructor is called for person the custom copy constructor is going to be called for engineer and the custom copy constructor is going to be called full civil engineer and you see that things are really propagating all the way to the person part and we are calling and reusing our copy constructors and this is really cool if you go down you're going to see that the information is printed out correctly the full name is daniel gray which we have in engineer one the age is 41 the address is all this gibberish the contract count is 12 and the speciality is road strength and we are properly reusing our copy constructors in our inheritance hierarchy this is really all i had to share in this lecture again the syntax you should be using to set up your copy constructors is what we see here this is going to be reusing the code we have in our upper classes in our hierarchy we will be avoiding the temporary copies we saw when we called the other constructor directly and this is much cleaner it is reusing code we have in other classes we are going to stop here in this lecture in the next one we're going to see that it is actually possible to inherit base constructors go ahead and finish up here and meet me there in this lecture we're going to explore the fact that we can inherit base constructors and use them in our derived classes we will build we're using the same hierarchy we have been using so we will have the person class and we will be inheriting from this person to create an engineer class and that's what we're going to be using to learn about this concept here so the personal class is what we know from the previous lectures we have a bunch of member variables here we have the full name the age and the address and we have a bunch of constructors now we have a default constructor a custom constructor and a copy constructor that we set up tirelessly in the last lecture now what do we mean when we say that we can inherit a constructor well based constructors are not inherited by default and what we mean by that is that by default it is really not possible to get derived classes to use base constructors to set up things but it is possible to tell the compiler to use the base constructor to set up our own objects for example we can put our statement here saying using person column column person this is going to tell the compiler when welding engineer objects don't use your own constructor set up a base like a constructor which is going to only initialize the base member variables and the compiler is going to see this statement and it is going to generate a constructor for you that looks something like this so it is going to be engineer it is going to be taking in the full name the age and the address and it is going to be forwarding the work to initialize your object to the person class and this is all this constructor is going to do hopefully you can see that this is called inheriting a base constructor because all this constructor is really doing is initializing the base member variables it's not initializing any member variable that belongs to the engineer class so the engineer part of us is going to be basically empty containing junk data that we get by just calling the default constructor and we will only be initializing the data belonging to the person part of us this is really what i want you to see again the syntax is what we see here this is going to tell the compiler to generate a constructor that is only going to initialize the base member variables but this constructor will be callable and usable from the engineer class okay so this is really what we mean by inheriting constructors one thing you should know is that the constructor is going to be inherited with whatever access specifier it had in the base class so if", "93296.0 - 93595.12000000001": "it's going to be inherited with public access so we will be able to use it from the outside and world engineer objects if it was in a protected scope we want to be able to use it from the outside if it was private we won't even be able to use it from a derived class you should really know that so it is going to be inherited with whatever access specifier we had in our base class now that we know this let's see some things you should really be careful about the first is that copy constructors are not inheritable if you try to do that you're going to get a compiler error but you won't usually notice this because the compiler is going to insert copy constructors for you anyway this is going to become a problem if you are doing some dynamic memory allocation and you're going to get pointers copied this is really bad if you don't know about this please go back to the chapter on classes and you're going to see all the story about shallow copying and deep copying we talked about these things another thing you should know is that inherited constructors are really based constructors and what we mean by this is that they will only be initializing the base member variables because they are based constructors they have no knowledge of derived member variables that's why they only initialize base member variables again as we said the constructors are inherited with whatever access specifier they had in the base class and it is possible to set up your own constructors on top of the inherited constructors and you can use these things another thing i should really tell you is that inheritance constructors is going to make your code really confusing it is a technical possibility but i strongly advise against using this in your code because it is just going to confuse people people are going to see for example an engineer constructor and they are going to think that that constructor is going to even initializing the engineer member variables but it's not going to do that because it is a base constructor it's only going to be initializing the base member variables and that may lead to some confusion or even really bad problems in your code so don't use this it is just going to make things confusing but i wanted you to be aware of this and if you see this kind of setup in classes out there you will know what they mean this is just going to inherit a base constructor and use it to build objects now that we know this we're going to head over to visual studio code and play with us a little more here we are in our working folder the current project is inheriting based constructors we are going to steal code from the last lecture and we will be using the main cpp file the person class and the engineer class this is just going to be enough for our purposes here we're going to go back in our current project and we're going to put this in and we will open this in visual studio code by dragging and dropping here this is going to give us our thumb and let's go to person and see that we have our constructors and we have a default constructor we have a custom constructor and we have a copy constructor one thing you should know is that copy constructors are not inherited so you will need to set up your copy constructors explicitly if you want to use them know that they want to be coming from the upstream class you should know that okay so this is the message here now let's look at our engineer class the engineer class is publicly inheriting from person and it has a bunch of its own constructors but what we want to do is to take out all these constructors and we're going to take them out i think we can uh yeah we're going to take them out let's do that and we're going to go in our cpp file and also take out all these constructors here we're going to comment them out i think we can take out all these bad code we got from previous lectures and we're going to just comment out our constructors we're going to close them all with a blog comment and what we are going to do in our class is say using person person we're going to say using person person this is going to inherit the constructors from person and now that we have this in place the compiler is really going to generate a base like constructor in our engineer class in other words we're going to have a default engineer constructor which is just going to not initialize anything we are going to have a custom constructor which is going to take three parameters but it is going to be an engineer constructor and let's prove this we're going to go in our main cpp file and we're going to take out everything we have here and we don't have a civil engineer file so we shouldn't really include that and we are going to create an engineer object we can say and one using the default constructor we can try and print that out and you're going to", "93595.12000000001 - 93896.40000000001": "visual studio code we can try and build this we're going to pass this through gcc and we are going to set up a powershell window we can use to run and see things and we're going to see that the default constructor for person was called to initialize this guy and the data is really junk data we have in person so what the compiler is really doing behind the scenes is to generate a bezel-like constructor at the engineer level and it is going to call the base constructor to initialize the person part of us so the data is just going to be junk data we have in person and you're going to see that the contract count is going to be zero this is just a default constructor which is just going to grab whatever default data we have in our object you see the contract count is zero if we go back in person we're going to see that the full name is none which is what we see here the age is zero and the address is none this is a default constructor but we can even explicitly pass in the data and that's going to also work so we can pass in the full name to be daniel gray we can pass in the edge to b23 for example and we can pass in a junk address let's say something like this and you see that this is going to work even if we don't have any engineer constructor that takes three parameters let's go back and you're going to see that all our constructors are commented out but this is working because we told the compiler to generate a base like constructor for our engineer so it is going to also have in an engineer constructor that looks like this constructor here which takes in three parameters and this is really cool and this is really crucial to understand so again we are going to set up a constructor for engineer so it is going to be an engineer constructor but it is going to be taking three parameters just like the person constructor here and this is the message i really want to convey here so if we run this code you're going to see that it is going to work it is going to call our baseline constructor for engineer and we're going to have the data forwarded and but you're going to see that the contract count is not going to be taken into account so it is going to still contain some default data if we try and pass that in we're going to see that we're going to get a compiler error because now we have no such constructor that takes four parameters the only one we have is one that is generated because of this statement here and this is going to be a baseline constructor which is just going to take three parameters just like this constructor here and another thing i don't think i made clear enough is that this is going to bring in all the constructors you have notice that we just put in this statement but it is going to grab all these constructors we have except for the copy constructors which are not inherited in c plus plus so you should really know this if we build this code we're going to get a compiler error because the compiler wants to know what to do with the 45 parameter that we have here but let's build and really show you this you need to see this compiler error with your own eyes let's go in so the world is finished with errors and we have an error saying no matching function called to this constructor which takes four parameters if we take this out we're going to see that this is going to work this is going to use the compiler generated constructor as a result of this statement we have in our code now if we will we're going to see that this is going to work okay the build is good can clear and run rooster we're going to see that we have the full name to be daniel gray we have the h2b23 we have our address which is really some junk data and the contract count has no data in it is just the default data we have in our member variable here we have no way to initialize this from a base like a constructor but not everything is really bad news if you don't want to be limited by the constructors that are generated by your compiler as a result of inheritance you can set up your own constructors for example we can uncover our engineer constructor here and bring it out of our comment we can do something like this we can go in the implementation file and also bring this out of our comment section and now we will be able to use this constructor which is going to take the fourth parameter here and do something with that now if we go back in main the code with three parameters is going to work it is going to use the compiler generated constructor but if we pass the contract count to b4 this is also going to work because it is going to be using our own constructor here if we build the code we're going to see that it is going to work just fine let's use gcc to show this you're going to see that the world is", "93896.40000000001 - 94195.68": "and run rooster now our contract count is taken into account this is really cool this is really all i wanted you to see in this lecture that you can let the compiler generate the baseline constructor using the syntax we have in our header here this using statement can really show up anywhere but it is going to inherit the constructor with whatever access specifier the constructor had in the base class and you should really keep these points in mind especially the last one that inheriting constructors is going to make your code confusing people are going to notice that they can call constructors that are really not going to be initializing derived member variables and this may cause serious problems in your code we are going to stop here in this lecture in the next one we're going to explore how inheritance works with these structures so far we have been ignoring the structures we are going to focus on them in the next lecture so go ahead and finish up here and meet me there in this lecture we're going to focus on how destructors work with inheritance and suppose we have an inheritance hierarchy like we have been using all along in this chapter so our base class is person we have the engineer class which is publicly inheriting from person and we have a civil engineer class which is inheriting from engineer publicly so when we create a civil engineer object we have seen that the burst part is built first so we are going to build the personal part of us we are going to build the engineer part of us on top of that and we are going to build the civil engineer part of us on top of that so the constructors are going to be called in this order we will call the person constructor first engineer constructor after that and then a civil engineer constructor after that to set up our civil engineer object the thing i want you to see in this lecture is that the structures are called in the reverse order to that so the most specialized destructor is going to be called first then we're going to destroy the engineer part of us and the person part of us is going to be destroyed last so we are going to construct things in this order from the base part to the most specialized one and then we are going to destroy thanks in this order so these structures are going to be called in the reverse order than the constructors that's the message i want to convey here and we're going to set up a simple example to play with us we're going to create a civil engineer object and we're going to see the order in which these things are called and let's head over to visual studio code and actually do this here we are in our working folder the current project is inheritance and destructors we are going to be reusing the code from a previous lecture i don't think the last lecture is a good example because we don't have a civil engineer class so we are going to go to the lecture before that and use the code from our lecture or the copy constructors with inheritance that's going to give us all the classes we have person engineer and civil engineer and we need that in this lecture here so let's grab all these things we're going to copy them and put them in our current object which is inheritance and the structures and we are going to open this in visual studio code and it is going to be our starting point here so we have person engineer and civil engineer let's see what we are doing and the main cpp file we can take out all the junk here or we can leave in the civil engineer object we are creating here and we're going to see how the constructors and the instructors are called we're going to go to person and make sure we have a constructor and we have a bunch of constructors and let's go to the cpp file and see that we have messages in our constructors this is really what we expect but we want to also put a message in the destructor let's say sddc out and say destructor for person called this is going to do we're going to go in our engineer class we're going to see that we have a bunch of constructors we have a destructor here we're going to hop over in the cpp file and make sure we take out the bad code here because we don't really need that we only need good code and we make sure that we have output statements in our constructors to know when they are called looks like we are good we're going to put an sddc out statement in our destructor for engineer or engineer called this is going to do and we are going to hop over in our civil engineer class we're going to have a bunch of constructors we're going to have a civil engineer", "94195.68 - 94496.872": "we can go in the cpp file and make sure that we have output statements in our civil engineer constructors looks like we are good here we can take out all the bad code we don't need and we are going to put a message in our destructor here so let's do that the the structure called for civil engineer i think this is going to be good enough let's go back and make sure we have the same messages here for engineer and we have a destructor for person called message and we're going to try and run the code and see how constructors and destructors are called this is the order we want to make sure we understand if you want you can even use a debugger to follow things but i am not going to do that here i am just going to weld and show you the output statements hopefully that's going to be proof enough that things happen in the order that i just described in the slides the build is good we can clear we can bring up a powershell window and then clear and we're going to run rooster we're going to see that the constructor is going to be called for person for civil engineer and you're going to see that things are going to happen from the must-based constructor to the most specialized constructor so we are going to call person engineer and civil engineer but you're going to see that the structures are going to be called in the reverse order the most specialized the destructor is going to be called the first then we're going to call the distractor for engineer then we're going to call the destructor for the base class so things are going to be happening in reverse order we will build thanks starting from the base and then finish by the most specialized class which is doing the inheritance and then we're going to call the destructor for the most specialized class first and then the destructor for the most based class is going to be cold last you should really make sure you understand this because sometimes your things are going to be depending on this order and you need to understand this and this is really the main message here that the structures are ridiculed in the reverse order than the constructors we are going to stop here in this lecture in the next one we're going to see that we can actually reuse names in our inheritance hierarchy and we're going to see how that works out in the next lecture so go ahead and finish up here and meet me there in this lecture we're going to see that we can reuse names in our inheritance hierarchy and what we mean by that is that we can have a parent class for example and have a child class inheriting from the parent class and have exactly the same names for the member variables and types or the same signatures for functions for example in the parent class you see that we have a member function called printfur it is going to be printing some information we can have a function named exactly the same in the child class and c plus plus is going to allow this we can also do the same things for member variables for example we have m var which is of type and we have exactly the same thing in our child class and c plus plus is going to allow this now the problem is if you create an object of child which method will be called if you call printvar now what c plus plus does is it is going to override or hide things you have in the base class if you happen to set up exactly the same thing in a derived class so for example the members in our child class are going to hide the members we had in the base class and if we call these methods on a child object we are going to get the versions in the child class called if we call these methods on a parent object we are going to get the parent version called and we're going to see the data in the parent class printed out this is the message here it is possible to use the same names in both parent and child classes and if you do that things in child classes are going to hide or override what we had in the parent class this is the message i want to convey here and here is a simple example to drive home how you can use these things for example we can create a child object using this syntax here and if we call a method on the child object this is going to call the method in child but it is possible to force the compiler to call the version in the base class and you're going to see this syntax used somewhere in your code out there so the syntax is to say the object name you put it up you say the name for the parent class and then you call the method using the scope resolution operator here and this is going to hold the method in the parent okay now that you know this we're going to head over", "94496.872 - 94796.552": "a little more here we are in our working folder the current project is reused symbols and inheritance we are going to just grab the template files because we are going to be building things from scratch here and we're going to put in our files no big deal here and we can open this in visual studio code this is going to give us a bare minimum main cpp file we can clean it up a little bit and we're going to set up our parent class let's do that pretty fast we're going to say parent and set up the header and we're going to set up the implementation cpp file we are going to set up the header file and this is going to do everything we want we have a constructor which is really defaulted here so let's say default and we cannot default the destructor can we default it let's do this and see what happens and we don't really need to do anything in the cpp file we can leave it empty this is not going to hurt anything and with this we can create parent objects let's do that we're going to say we're going to hop over to the main cpp file and include current and make sure that we can use that and we're going to create a parent object let's do that we're going to say parent p1 and say p1 print values we can do that and we can work and run this program i think it is going to work just fine okay the build is good we can clear or we can set up a powershell window and a clear and run rooster this is going to say the value in parent is 100 which is what we have by default here we have a simple member variable which is of ant type it is protected because we want it to be inherited and we have a bunch of constructors here we have a constructor which is going to take a value but we're not going to use that here the default is just fine you can use that if you want and we have a member function which is going to print the value in parent now that this is working we can set up a child class which is going to be inheriting from the parent class here so let's do that we're going to set up the child header file child dot h and we're going to set up a cpp file for that that cpp so we are going to put the data in the header file again it is nothing complicated it is just a simple class which is going to be inheriting from parent and we are going to have our own member variable which is going to eclipse what we had in the parent so the names here must be the same m a member of r if we go in parent it is m member for and what we have in child is going to eclipse what we had in the parent class in other words if we print the member variable in child we're going to see 1000 printed out here we want to see 100 that we have in the parent printed out hopefully this is going to drive the point home that if you have members named exactly the same what you have in your derived classes is going to eclipse or hide what we had in the parent class this is the message here but even if this is the case c plus plus allows us to specify that we want to grab the data in parent from a child object for example in our show values method we can print the value in child directly using m member war but we can also specify that we want the value in the parent class because even if this is a child object it has a current part of it so we can access the data in parent and print that if the data happens to be accessible from our derived class and that's why we set up our member variable to be protected for it to be accessible in our derived classes this is going to allow us to print something like this and this is going to really work now that we have this in place we can go in the main cpp file and only include the child we can do that and we're going to create a child object or we can just take out everything here and adjust putting the code we can use to play with this things we can create the child object and on this child we can print for we're going to see that the data is going to be printed out but we can also use this syntax to print the data in the parent part of us and we're going to see that the data is printed out we can also show the values and make sure we see this from a member function of the child class this is going to call this member and we're going to get to the value in child and we're going to get the value in parent printed out on the console now that we have this we can actually try and work this we're going to use gcc to do that we're going to see that we're going to finish building with errors what is the problem here we have an undefined reference to child destructor we didn't put in a definition for the child destructor so let's go there", "94796.552 - 95097.76": "going to say equals default and the compiler is going to generate one for us and now if we build we're going to build with gcc again the bolt is going to be good you can clear and run rooster and we're going to see that the value in child is 33 because we passed that in explicitly and this is going to call the constructor we have in child that happens to be this guy here and you see that we are really keeping things simple we are not calling the base constructor here the compiler is just going to call the default constructor we have in parent here and this is going to just work the main message here is that you can set up member variables and member functions named exactly the same way in the parent class and in child classes and what you have in your derived classes is going to hide what we have in our current classes so if we call a method on a child object for example like we are doing here this is going to call the method in child but we still have the ability to call data in the parent part of us and this is what we do here i would like to welcome you in this new chapter where we're going to be learning about polymorphism and polymorphism is the setup we can do in our c plus plus programs to use a base pointer and manage derived objects suppose we have an inheritance hierarchy like we have here we have shaped as our base class and we can inherit from oval and create a circle class imagine that we can create all kinds of crazy shapes that inherit from shape in our simplest path program for example we have a rectangle class we have a triangle class we have all kinds of crazy shapes now if we have this inheritance hierarchy here is something we might want to do we might want to set up a base pointer that is managing a derived object and set up code like this for example we say shape pointer and i set up a pointer variable here and use this pointer to manage a circle object that we dynamically allocate for on this line here we can also do a shape pointer that is managing a rectangle we can set up a shape pointer that is managing a novel object we can really set up a base pointer that is managing any kind of object we support in our inheritance hierarchy now some of you are going to ask a few questions one of them is going to be is this even legal c plus plus syntax and the answer is yes because if circle is inherited somehow from shape a circle is really a shape and if rectangle is inheriting from shape it is a shape and if we try to assign a circle to a shape we're going to see that that's going to work so this is valid c plus plus syntax and we can do the same thing using references as we see here we can set up a reference that is going to be managing a circle object that we have through circle one we can set up a reference to manage a rectangle that we have in shape two we can set up a reference to manage an awful object we can really do all these things now some of you are asking why would we want to do something like this now try and think about your inheritance hierarchy here and try to think about what if you want to draw this kind of ship for example if you didn't use polymorphism you would need to set up all kinds of crazy methods to draw each kind of object and we have no way around this because these are different types if you have a method that takes a novel and you pass in a circle that's going to give you a compiler error but with polymorphism we can set up a single method which takes a shape pointer or a shape reference and we can pass in all kinds of crazy objects whose class derive from shape so for example we can pass in the address of the circle and this function is going to draw a circle we can pass in the address of a rectangle this is going to draw a rectangle we can pass in the address of a novel and this is going to draw a novel hopefully you can see how this is useful we can even do this using references so if we pass in a rectangle this is going to draw a rectangle if we pass in a circle this is going to draw a circle you get the idea this is one of the benefits of using polymorphism again polymorphism is about using base class pointers or references to manage derived objects in our inheritance hierarchies another benefit of polymorphism is to allow us to be able to store different kinds of objects in a single collection remember an array can store objects of different types if you say tap an end array and try to store in a string or a double you're going to get a compiler error because that's not allowed so if you have an array that is going to store circles you can't put in a novel you can't put in a rectangle you", "95097.76 - 95395.44": "that because an array by design is going to store objects of the same type but we can avoid this limitation using polymorphism again we can set up an array that is going to store base class pointers and we can store in all kinds of crazy objects whose class derived from this base class here so here we can store in a circle object we can store in a novel we can store in any kind of object that is part of our inheritance hierarchy with the base class as shape and this is going to work and this is going to be using polymorphism for example if you look through this collection calling the joe method for the first element this is going to call the draw method on the circle for the second element we're going to call the draw method on a novel and this is going to be really cool this is something we can achieve with polymorphism and i want to back up a little bit and talk about what is really meant by polymorphism polymorphism really means multiple forms and in my opinion what this means is that the base class pointer or base class reference can take multiple forms at one point it might be managing a circle at one point it might be managing a rectangle at one point it might be managing a novel object so it is a basic pointer but it can take multiple forms because it can be managing multiple kinds of objects whose class are part of our inheritance hierarchy this is what we mean by polymorphism so again the idea is that we can use the base class pointer or reference to manage all kinds of crazy objects in our program and this is going to have many benefits as we are about to experience in this chapter here i am really excited to be explaining this to you this is one of the most powerful features in c plus plus we are going to start in the next lecture and show you that you don't get polymorphism by default in c plus plus and what you get is static binding go ahead and finish up here and meet me there manage derived objects in our c plus plus program hopefully this is going to give you a clear idea on why we might need to do this so let's look at our classes that we're going to be using here we're going to set up a shape class which is going to be representing our shapes this is going to be our base class that's the basic use for this here it has a simple member variable which is going to store the description for our shape it is also going to have our draw method which is really not going to draw anything it is just going to say the description for our shape here once we have this shape we can create other shapes from it for example we can create a novel class which is going to be representing a shape like this it is going to have two member variables one is going to be mx radius the other is going to be m y radius this may represent the radiuses for our oval here for example the x radius might be something like this the y radius might be something like this and this is how we're going to be representing this shape here we also have a draw method which is going to print the information about this shape here it is going to say the description that we're going to be inheriting publicly from shape but it is also going to say the radius information for this shape it is going to give us the x radius and the y radius here and we have a bunch of constructors here we have a default constructor which is really not going to do anything we also have a constructor that is going to be taking two parameters to forward the data in our member variables here this is the kind of class we're going to set up in our program we also have another derived class from oval and this is going to be a circle class it is going to be a specialization on oval in which both x and y radius are equal so the x radius is going to be something like this and the y radius is going to be something like this and both of these are going to be equal so this is going to give us a circle shape we also have a draw method which is going to print the description and the radius we can really pick any radius we can pick the x radius we can pick the y radius they are really going to be the same because they are equal for our circle shape we also have a simple constructor which is going to take the radius and we are going to be using this radius to forward the data to our oval part of us and we're going to be setting this as both x and y radius this is the setup we have here okay now that we have our inheritance hierarchy we're going to try and use it and really explore the idea of static binding in c plus plus inheritance hierarchies so here we are trying to create simple objects of our classes we have a shape", "95395.44 - 95697.832": "have a circle object we are going to go through a base pointer and try to manage our objects here in our first line we're going to set up a shape pointer and we're going to store in the address of shape one and what we would want in our c plus plus program is that if we call the draw method on this shape pointer we would want the shape draw method to be called because we have a shape object stored in our base pointer here or in other words we are using a base pointer to manage this object in memory down here we store a novel object in our shape pointer or in other words we're going to be using this base pointer to manage an actual oval object in memory and the setup we want is that if we call the draw method on this shape pointer now we are going to get the oval draw method to be called this is the setup we want and down here we have another example where we are using this base pointer to manage a circle object we are going to store the address of the circle object in this base pointer this is how we do this and when we call a draw method on this base pointer we want the circle draw method to be called so with polymorphism what we really want is to call a method on the base pointer and get the most specific possible method called on our pointer this is the setup we want but this is not what we get by default in c plus plus if we happen to do this and run our program as is now with the current knowledge that we have on the first line here we're going to get the shape draw method called this is what we want but on the second example here we will see that we see the shape draw method also called and on this line we will also see that we get the shape draw method to be called this is not what we want and this is static binding so what is happening here is the compiler is looking at the type of the pointer and it is using that to decide which draw method to call so the compiler is so the compiler is basically saying i have a shape pointer so i am going to call the joe method on the shape class down here it is going to see that it also has a shape pointer and it is going to call the draw method on shape and down here it is going to see that it has a shape pointer and it is going to call the jaw method on the shape class this is what static binding is all about the compiler is going to resolve the joe method statically and what that means is that the compiler is going to look at the type of the pointer that we have and it is going to use that to decide which joe method to call in our inheritance hierarchy so this is the default and it is called static binding in c plus plus we also get the same behavior if we try to use a base reference to manage our actual object in memory here we have the same kinds of objects we had in a previous slide and we are using a base reference to manage our object and what we really want is that if we go through a base reference to call our draw method we will get the most specific draw method called so if our base reference is managing a shape we will get the shape draw method called if our base reference is managing an alpha object we want the oval draw method to be called here and if our base reference is managing a circle object we want the circle joe method called here this is what we want but again the compiler is just going to look at the type of the reference so for the first line here it's going to say i have a shape reference so i am going to call the shape draw method that's what we're going to get here on the second line here it's going to say uh-huh i have a shape reference so i will call the draw method of the shape class that's what we're going to see here by default and on this line here it is going to say i have a shape reference so i am going to call the draw method on the shape class and this is the behavior we get by default and this is static binding in action okay so now that we have seen what static binding is all about let's re-examine the idea of why we need polymorphism and i am going to give you a simple example here suppose we have a bunch of shapes we manage in our programs and we want to draw all these shapes if we want to draw a circle with the current setup we have we would set up a draw circle method if we want to draw a novel we would need to set up a draw over method and this will call our circle draw method and this will call our oval joe method this is going to do what we want but try to think", "95697.832 - 95996.08": "program we will need to set up 100 such methods and this is a mess i don't think you want to do something like this and we have another simple case that i want you to consider suppose we want to store all these objects in collections and we're going to use an array to try and drive this point home here if we want to store these guys in collections we will need to set up different collections because as we have it now we can't store different types in an array so what we would need to do now is to set up an array for circles and set up an array for ovals and do more collections for different kinds of shapes that we support in our program and if we want to draw them we have no choice but to set up different kinds of loops and each of these loops is going to be looping on each of these collections here hopefully you can see that this is by design we don't want to do this we want to set up something that is really easier to manage in our program and polymorphism was and polymorphism and c plus plus was designed to exactly solve this kind of problem what we really want in our c plus plus programs is to set up one draw method for example we can give it a base pointer and it doesn't matter which kind of object we pass it when we call this we will get that method to be called at run time when we actually need to draw this shape if we pass in a circle this is going to draw the draw method on a circle if we pass in a novel it will call the draw method on our oval object if we pass in a rectangle for example it is going to call the draw method on our rectangle object this is what we want we also want the same kind of setup if for example our functions are taking reference and this is what we're going to get this is what we want with polymorphism and this is really going to improve on the design that we had earlier when we needed to set up a specific method for each shape and we would end up with hundreds of draw methods and that's really bad it's not manageable this is also going to solve our problem with collections we really need to set up one collection which is going to be taking into account all the ships that we manage in our inheritance hierarchy so the setup we do is something like this we're going to set up an array that is going to be storing pointers to shape and we can store in the address of a shape we can store in the address of a novel we can store in the address of the circle because if you really think about it a circle is a shape a novel is the shape and the shape is the shape so this is going to work and when we get to loop through this collection and call the draw method for the first item here we will call the draw method on the shape for the second element here we will call the joe method on the oval object and for the third element here we will call the draw method on our circle object and we will draw a shape a novel and a circle with just one loop and this is really cool this is the design we want now this is not the default behavior we get in our c plus plus classes if we set up an inheritance hierarchy with our draw methods what we get by default is static binding but we will see how we can get dynamic binding or polymorphism in the next lecture for this one we're going to explore static binding and we're going to head over to visual studio code and play with us a little more here we are in our working folder the current project is static binding with inheritance we are going to grab our template files this is going to be our starting point here we're going to put in these files and i am going to put in our classes to save time if you want you can download these classes from the attached resource section on this lecture you're going to find them and you can use them as a starting point this is going to save us a few seconds because we don't really want to type these classes you already know how to create classes if you made it this far in the course so i am going to drag this and drop here to open in visual studio code and this is going to give us a good starting point here we have a base class which is our shape class it is going to have a simple member variable which is going to be the description one thing i think we need to improve on this is to use a string view to pass our parameter here so let's include string view we can include that here we're going to say include string view because we are using modern c plus plus and we're going to change this to be an sdd string view by value we can do this okay so we have our class here and we have a draw method which is really not going to do anything special it's going to just print the description here and we're going to see it printed out on the output stream", "95996.08 - 96296.232": "an implementation of our constructor and we have a destructor we're going to fix our parameter here to make it an std string view let's look at our oval class it is going to be deriving publicly from shape and we have a bunch of member variables here two to be exact one is going to be the x radius the other is going to be our y radius we have a constructor here which is going to be taking three parameters two parameters for the data for our radius here and we have a third parameter which is going to store our description data we're going to also change this to bstd string view and this is going to do we have a draw method which is going to be printing the description and our radius data and this is really it we don't need anything fancy here let's look at our oval cpp file it is going to have the implementation for our constructor and our destructor here we just need to change the type for our description here and make this an sdd string view let's do this and we will look at our circle class which is going to be inheriting from publicly it won't have any member variable because it's just going to forward the data to the over portoverse it doesn't really need to do any other specialization but what we need is a method which is going to return the radius because we want to print that here so we can head over in our oval class and set up a protected section which is going to give us these methods here so i'm just going to put them in here to save on some time it is protected because we want this to be usable in derived classes but we don't want this usable from the outside this is the setup we can achieve by making these guys protected here get x rad is going to return the x radius get y rad is going to return the y radius they are const because we don't intend for this to modify our object and if we go in our circle class this is going to work now we will be able to print our information on our circle object and we will see on our output stream if we look at the implementation of our circle class it is nothing complicated it is just going to take the double radius and it is going to forward the data to the oval part of us and our description here will need to change to take into account that we want to use std string view here so let's change this to bhd string view we can do that and we are going to head over in our cpp file and change that as well std string view you can do that and now our classes are really complete we can head over in our main cpp file we can clean that up a little bit and we're going to remove what we don't need here we are going to include our classes so we're going to include shape let's do that we are going to put in oval let's do that oval dot h and we are going to put in circle and we are going to create objects of these classes and try to print their information so we're going to set up a shape called the shape one we're going to set up a novel called oval one we're going to set up a circle called circle one and we're going to see what kind of information we see if we try to call the job method again in shape the draw method is just going to say that we are calling shape joe in alvo we are going to say that we are drawing an oval and we're going to say the description and the radius in circle we're going to say that we are calling the draw method on the circle object and say the description and the radius here this is the information we want so we are going to try and build this program using gcc our favorite compiler you can really use any compiler you have your hands on but we are going to use gcc here because it is our favorite and we're going to have a bunch of errors what it is that we have here what is it that we have here let's go in shape header at line 4 and see what we have and we have a j here that we don't want let's take this out and we're going to build it and we're going to pass this through gcc and the bolt is going to be good we can bring up a powershell window to run our program let's run rooster and we're going to see that shape draw was called drawing shape one you see we have just created shape one here and we are printing its information we are going to call the oval drill method and we're going to print the information on that you see that it is over one here and we're going to put out our radius data x radius is going to", "96296.232 - 96595.832": "going to be 3.5 and this is our information we are also going to call the draw method on our circle object this is what we get and we're going to say we are drawing circle 1 and the radius is going to be 3 3 this is our information here but we don't want to go through direct objects to manage our data here what we want is to either go through base pointers or base references so we are going to set up a shape pointer let's do that we're going to say shift because that's our base class and we're going to say shape ptr to represent our pointer and we're going to store in the address of shape one we can do something like this and that's really see what is happening we're going to comment out our calls to draw methods here and we're going to see what happens so if we say shape ptr and call the draw method we can do that let's try and build our program we're going to pass this through gcc you're going to see that it is going to work and it is going to do what we expect if we run this program here you can clear and run rooster we're going to see that shape draw was called and we are going to be drawing shape one here this is what we expect but if we go down and say we don't want to call the draw method here we are going to store in let's say shape ptr and we're going to store in the address of our over one object and we want to call the draw method here now if you do this as we saw in the slides what we really want is to get the draw method on our actual oval object called and if we will for example drawing things on the screen we would draw a novel this is what we want here but this is not what we're going to get you're going to see that we still get the job method from the shape class called and it is going to and it is going to say drawing over one let's try and build this program and i really want you to see this so the builder is good we can clear and run rooster you're going to see row even if we are storing again a novel object so this is the default behavior we get and this is static binding that we get by default in our inheritance hierarchies so what the compiler is really going to do here it's going to look at the type of the pointer that we have here it is going to say i have a shape pointer so i am going to call the jaw method on the shape type that i have in my pointer here and we are going to see that this is calling the draw method on our shape and this is not what we want in most cases we are going to see that we get the same behavior if we store an a circle object let's do that we're going to say shift pointer and we're going to store in the address of our circle one and then we're going to call our draw method on our shape pointer again this is going to draw a shape it's not going to draw a circle that we really are managing with our base pointer here and some of you must be thinking why are we able to store circle pointers for example in a shape well a circle is a shape according to our inheritance hierarchy if we take a closer look again here you're going to see that oval is going to be inheriting from shape and the circle is going to be inheriting from oval so from what we learned in the last chapter oval has a shape part in it and the circle has a novel part in it which in turn is going to have a shaped board in it so from this understanding it shouldn't really be surprising that we are able to manage a novel object with a shape pointer or the fact that we are able to manage a circle object using a shape pointer this is why we are able to do something like this okay so i hope this is super clear but again we are not getting the default behavior that we want but we will see how we can achieve that in the next lecture for now i really want you to understand what static binding is all about and it is the fact that the compiler is going to look at the type of the pointer here and use that to decide which method it is going to be calling in our inheritance hierarchy the compiler for example is going to see that we have a circle object stored n at lineup 25 here but when it wants to decide which joe version to call it is going to look at the type of this pointer here and it is going to use that to decide which draw method to call and in this case it is going to call the shape version because the type of this pointer is shape okay so i really hope this is super clear here we are going to", "96595.832 - 96896.48": "manage our objects using references for example if we go through a shape reference let's do that we're going to say shape reference and say shape ref and we are going to store in shape one for example let's do that and we want to call the draw method on ship reference let's do that so let's call the joe method and you're going to see that we will get the shape method called and this is really making sense because we have a shape object managed by this reference here so if we build our program let's do that we're going to pass this through gcc you're going to see that we get what we expect the build is going to be good we're going to clear and run rooster and we see shape drill called this is what we want but if we use this reference to manage derived object for example let's put in over one we can do that we're going to see that we don't get the most specific draw method for oval here called we will still get the method for a shape called let's build and show you this this is static binding again okay the build is good we can clear and run rooster we're going to see that shape draw it is drawing we don't get the ovo draw method called we get shape drill method again the compiler is going to look at the type of this reference by default and it is going to use that to decide which draw method to call if we even put in a circle we are going to get the same behavior let's build with gcc the bolt is good we can clear and run rooster we see that shape draw is called and this is really not what we want okay so this is static binding and it is the default behavior we get if we have an inheritance hierarchy with the same method spread across each derived class we're going to get the shape version called even if what we are really managing with a shape pointer or a shape reference is a derived object i really want you to understand this now let's see why this is really badly designed by default in c plus plus if you happen to need to pass ship parameters to functions for example we might do something like this we might need a function to draw a circle we might need a function to draw a novel and if you happen to have 100 objects you can draw in your program you have no choice but to set up 100 drawing methods or functions this is really bad design you don't want to do something like this so what you would do in your program for example is go down and say drawing and you would say for example draw circle and pass in a circle and say draw oval do we have a draw or full function let's see yes we have that we can go down and say draw oval and pass in our oval one this is going to work just fine but hopefully you can see that this is bad design if you have a lot of shapes in your program this is going to quickly become and manageable and you don't want to do something like this what we want is to be able to only have one method and get to the c plus plus runtime to resolve which one is called at runtime when we get to pass our actual objects and we will only have one function which is going to take into account hundreds of shapes that we might potentially have in our c plus plus program this is going to be much easier to manage and we will actually be able to achieve this in the next lecture so stay tuned for that another problem with us is if you happen to need to store these shapes in collections if you need to set up something like this you will have no choice but to set up different collections for each type for example we might set up a collection for a circle a collection for oval and here we are just using arrays to model our collections this is really bad design if you happen to have 100 shapes in your program you will set up 100 such collections and the only difference is that they are just different types and this is really bad design because even if they are different types they are related and they are all shapes in our c plus plus program and what we really want is to set up one collection which is going to take into account all these kinds of shapes that we might have in our c plus plus program and we will be able to achieve this again in the next lecture but the whole point of this lecture was to show you static binding that we get by default with our inheritance hierarchies static binding may be bad if you really are managing a lot of related objects in your c plus plus program and all these objects have the same method that each derived class is specializing but you want the most specialized method to be called on the actual object that you are managing with a base pointer or a base reference hopefully this is super clear i apologize this lecture turned", "96896.48 - 97195.512": "to make this super clear and everything else we do in the reminder of this chapter is really going to fall in place so make sure you understand this and if you have a problem do you ask me i will do the best i can to help you out this is really all i had to share in this lecture i hope you found it interesting we are going to stop here in this lecture in the next one we're going to show you how you can achieve dynamic binding using virtual functions in c plus plus go ahead and finish up here and meet me there in this lecture we're going to see how we can achieve dynamic binding or polymorphism using virtual functions in our inheritance hierarchies in the last lecture we had a hierarchy like this where the base class was shaped we had an overclass which was publicly deriving or inheriting from shape and we had a circle class which was publicly inherited from over and the problem we had was that if we happen to be managing oval or circle objects using shape pointers or shape references we don't get the correct methods called if we call the draw method on our base pointer or base reference and this was really bad and this is something we want in practical c plus plus programs i am here to tell you in this lecture that you can just achieve that by doing a tiny modification on your inheritance hierarchy all you need to do is to mark the methods you need to be dynamically resolved virtual and we do that by inserting this virtual keyword in front of our function so we're going to do that on our shape class we're going to do that on our over class and we're going to do that on our circle class once we do this the c plus plus compiler is going to know i want to be looking at the type of the pointer or reference to know which kind of method to call and my inheritance hierarchy if i happen to be using a base pointer or a base reference to manage a derived object and we're going to be making this super clear in a minute and if you are lost please bear with me you're going to understand so let's do this we're going to modify our shape class and change our draw method to be virtual as you see here we're going to head over in our oval class we're going to modify our draw method and mark it to be virtual using the virtual keyword here and we're going to move in our circle class and change it to be virtual as you see down here this is really all we need to do from what we had in the last lecture and this is going to be magic let's look at what we can achieve now we're going to set up three objects shape oval and circle as you see here and we're going to be calling our method which is going to be taking references and we're going to see that we get the correct most specific method called so for example here we will call the shape joe down here we will call the oval draw method because we just passed in a novel object and on the third line here we will get the circle joe method called and we will see it printed out on the console this is really cool this is what we want to achieve if we want to call our methods that take pointers we can do that and on the first line here we will call shape draw on the second line here we will call overdraw and on the third line here we will call circuit draw this is what we want to achieve and if we happen to be setting up a roll base pointer like we do here and store in a derived object like this or another way to say this if we happen to be using this base pointer to manage a derived object and we call the draw method on the base pointer the compiler is going to know that it will need to resolve this draw method dynamically the reason is this is a virtual method and if a method is virtual the compiler want to do static binding like we did in the last lecture the compiler is going to be doing dynamic binding and with dynamic binding the compiler is not going to look at the type of the pointer it is going to look at the type of the actual object that the pointer is managing and this is going to give us the behavior that we wanted starting from the last lecture okay now that you know this we're going to head over to visual studio code and play with us a little more here we are in our working folder the current project is polymorphism with virtual functions we are going to be reusing the code from the last lecture because that's going to give us everything we want we will leave out the binary file here which is rooster and we're going to copy everything we want we're going to put that in the current project and we're going to open this in visual studio code we are going to have", "97195.512 - 97496.552": "methods here and we will just need to modify this a little bit to achieve dynamic binding as we saw in the slides all we need to do is to mark all these draw methods as virtual so we're going to say virtual void draw in the shape class we're going to go in the oval class and do that we're going to mark our method as virtual and we are going to go in our circle class and mark our draw method as virtual let's do that and at the moment we do this we're going to get dynamic binding behavior in our inheritance hierarchy here and this is really cool so let's go back and try to play with what we had before i am going to comment out everything we had and we're going to be doing things in step here let's go through the code that uses base pointers because that's where we started out from in the last lecture and we are going to mark that here let's put in some space to make it easy to follow so we are going to uncomment the line here that calls the draw method when we have a shape object stored in our base pointer or when we are using a base pointer to manage a shape object here we can also comment out all these lines because we don't want this to do anything and let's see yes this is what we want we are setting up our shapes and we are using a base pointer to manage an actual shape object and if we call the draw method we expect this to call shape draw and this is what we're going to get let's build our program we're going to pass this through gcc our favorite compiler the build is going to be good we can bring up a powershell window we can use to play with us if we call rooster we're going to see that shape draw is called and we are drawing shape one now if we change this to manage an actual oval object we can do that we can do that through this line here and we expect this to call overdraw and because the draw method is now virtual this will use dynamic binding again with dynamic binding we are telling the compiler don't look at the type of the base pointer look at the type of the actual object that the pointer is managing and the compiler is going to see that this object is a novel object and it will call the oval version of the draw method here and this is really cool this is what we want let's run the task to build with gcc again the world is going to be good as you see here we can clear and if we run booster look at this overdraw calls and we are going to be drawing our oval object and this is the data we have inside we can use this radius data to draw this on the screen if that's what we are after in our c plus plus program and this is really cool we can even use our base pointer to manage a circle object we can do that and if we do that and call the joe method because this draw method is now virtual the compiler will note that it doesn't need to look at the type of the pointer that we are using to manage our object the compiler is going to look at the type of the actual object that the base pointer is managing and in this case it happens to be a circle object so here we will call circle draw and this is going to draw a circle on the screen and this is really going to be super cool so let's pass this through gcc and we're going to see this in action the build is going to be good we can clear and run rooster and you see that we are drawing a circle and this is really cool and just using virtual functions we can really achieve powerful features and you see that this wasn't really hard to achieve all we had to do was to mark our inherited methods as a virtual and this is going to tell the compiler to do dynamic binding and this is going to be super cool let's see that we can also achieve the same thing using base references i am not going to run the code where we are using a base reference i am not going to be running the code where we are using a base reference to manage a base object because that's going to be really boring but what we can do is put in an awful object for example you can say over one and say shape ref and call the draw method again this is dynamic binding because the draw method is virtual so the compiler is not going to look at the type of the reference to decide which version of the draw method to call it is going to look at the actual object that this reference is managing and it is going to see that the type of the object is awful so c plus plus is going to call the oval version of the draw method that's what we're going to get if we run this program here", "97496.552 - 97796.0": "pass this through gcc the voltage should be good as we see here we are going to clear and run rooster you see we are drawing oval if we happen to be using this to manage our circle object let's do that we will see that we will get the circle method called okay let's build and we're going to pass this through gcc to do that the both is going to be good we can clear and run rooster you see that we are drawing a circle because our base pointer is now managing a circle object now because we are using dynamic binding or late binding as some people call it we can really do all kinds of crazy things the first thing we can achieve is set up one single method which is really going to draw any kind of shape we throw at it so let's do something like this we're going to say void and we're going to say draw shape and it is going to take a shape pointer let's say s and the only thing we're going to do in this function and say s draw this is going to call the draw method on whatever parameter that we pass in here and watch this if we go down here and uncomment this section on drawing shapes if we say draw and pass in a circle for example or let's pass an oval and do this one level and to do this level by level we're going to pass in over one and we should pass an address because this is taking a pointer let's so let's do this and if we build and run this program let's see what happens here we're going to build with gcc the world is going to be good as you see here if we clear and run rooster you see and let's take out this thing using base references here because this is just going to confuse us we're going to build again and i use gcc for this the build is going to be good within clear and run rooster you see oval drill because we are passing in a novel object if we pass in our shape let's say shape one for example we're going to build the book is going to be good as you see here if we clear and run rooster we're going to see shape draw if we pass in circle let's do that and the bold again we're going to build with gcc we're going to clear and run rooster you're going to see that circle draw is called and this is really cool we can only use a single method and this method is going to take any shape we throw at it and it is going to draw it if we happen to be having 100 kinds of shapes in our program we can just for example loop through a collection containing those shapes and if we call the draw method on any shape we store in our collection we're going to get the correct shape drone and this is super cool this is really powerful and i hope you are excited to be able to achieve this in c plus plus now we can also achieve the same thing by using a method that takes a reference for example so we can say void joe shape let's say v1 and we're going to pass a reference we can say const and pass a reference and say sr to say ship reference we can do that and we're going to say sjo we're going to call the jaw method on this reference and let's see what happens if we try this out let's say sr that's what we should say here and this is going to be taken by our visual studio code editor if we go in here and change this to say draw shape v1 we can pass in shape one we can do that because this is taking a reference now if we build with gcc we are going to see that the world is good we can clear let's clear we're going to run the rooster this is going to call shape draw because we are using a reference to manage a shaped object we can also pass it over one and we're going to build again and see how this works the bolt is going to be good we can clear and run rooster we're going to say overdraw and we're going to see our information here if we pass in our circle object and the bolt we're going to pass this through gcc the bolt is going to be good we can clear and run rooster this is going to draw a circle for us this is really cool we have one method again that is taking a parameter by reference but we can use this method to draw any kind of shape in our inheritance hierarchy this is going to work really well and it is doing dynamic binding which is powered by virtual functions we are using in our inheritance hierarchy here you should really keep this in mind now let's go back and see if we can even use row pointers to do stuff i am going to comment this out and i am going to say roll pointers because i want you to see something we're going to set up a shape pointer we're going to say shape ptr do we have that on top here let's see if we do yes we have shape ptr so let's say shape ptr and pass it a novel object we're going to pass a novel again and we're going to", "97796.0 - 98097.19200000001": "do we can call the draw method and get it called polymorphically or get it called using dynamic binding we can say shape ptr and say draw this is going to call the correct version but one thing i want you to see is that if a method is not polymorphic or if a method is not virtual you want to get it called using polymorphism for example if we go to our oval class we're going to see that we have a bunch of getters let's go in and make them public so that they are callable from the outside and if we try and get this called polymorphically or using dynamic binding that's not going to work let's do that we're going to say get x rad and the reason we might want to do something like this is because we have this method here and it is set up on our oval class so because we are using a base pointer to manage a novel object some of you might think uh-huh i might be able to call this method because i am able to call the job method which is also in the public scope of our overclass but that's not going to work because this method here is not virtual dynamic binding or polymorphism is only going to work if your methods are virtual and they are set up across your inheritance hierarchy so this is not going to work if you try to do something like this this is going to give you a compiler error let's try and build and see the compiler error and we're going to see an error that says that no such method on this object let's go here class shape has no class shape has no member name to get x red because the method is not virtual the compiler is going to do static binding and it is going to be using the type of the pointer which is shaped to resolve this method and it is going to see that in shape we don't have a method called get xrad and the compiler is going to throw this compiler error here this is what we get so this is not going to work and i want you to be aware of this another thing i want you to see is that because we are using dynamic binding now we don't need we don't need to set up all kinds of crazy collections to take into account different shapes that we have in our c plus plus program what we're going to do here is use a base pointer to manage the data that we store in our array here so all i am going to do is remove all this dirt here because this is really dirt you don't want to do something like that and we're going to use a base pointer which is a shape pointer and use that to set up an array which can handle any kind of shape we have in our inheritance hierarchy so we can store it shape objects we can store it over objects we can store in circle objects and if we look like we do here we're going to get the correct method called and this is going to be super cool so let's try and run this program we're going to pass this through gcc why do we have the red thing here let's build and see if it goes away maybe this is visual studio code having a problem with our code the world is good so visual studio code was playing with us we're going to clear and run rooster you're going to see that we're going to be looping through this array here and on the first iteration we're going to call shape draw because the first thing is the shape on the second iteration we're going to call overdraw because the second thing is a novel and we're going to hit the third iteration and call circle draw because the third thing in this collection is a circle hopefully you can see that this is going to simplify our programs a lot compared to what we were able to do in the last lecture and this is really all i had to share in this lecture showing you that you can achieve dynamic binding or polymorphism or late binding as some people call it using virtual functions in your inheritance hierarchy again all we had to do was mark our member functions as a virtual and the compiler is going to know that it can set up dynamic polymorphism for your types if you happen to be managing them using a base pointer or a base reference we are going to stop here in this lecture and the next one we're going to learn about slicing and the size of polymorphic objects go ahead and finish up here and meet me there in this lecture we're going to explore the size of polymorphic objects or objects that use dynamic binding and we're going to learn about the concept of slicing if you happen to assign a derived object to a base object we're going to see how this works out in the last two lectures we saw that we could", "98097.19200000001 - 98395.76": "like this we can set up an inheritance hierarchy and we're going to have oval derive or inherit from shape and we're going to have circle inherit or derive from over here and our methods are going to be row they are not going to be virtual on anything and this is going to do static binding if you happen to manage a derived object through a base pointer or reference you want to get dynamic holes you will get static binding and the compiler will use the base pointer or base reference to decide which draw method to call on your object we also saw that we could achieve dynamic binding using virtual functions and all we needed to do was mark our methods as virtual in our inheritance hierarchy here and this would give us polymorphism or dynamic binding but one thing you should know is that dynamic binding is not free you're going to be paying in terms of memory to get all these cool things we saw in the last lecture and we're going to be proving that in this lecture what we're going to be doing is basically set up our inheritance hierarchy and we are going to set that up in such a way that it is going to be using static binding we're going to see the sizes we get printed out here and we're going to use dynamic binding and compare the sizes and the constitution is going to be that with dynamic binding your objects are going to be much larger because your simplest plus program will need to keep track of the information that allows it to resolve function calls dynamically and that information is stored in what we call virtual tables but i am not going to go into that here because it is really out of scope of a course like this but i want you to be aware of this if you use dynamic if you use dynamic binding your objects are going to be much larger okay the first thing i want to bring your attention to is object slicing and we're going to look at a simple example here we have our objects we have a shape object we have an oval object and we have a circle object and down here we want to assign our circle object to a shape object now notice that here we are not using a pointer or a reference these are just the row objects that we are assigning to each other and what the competitor is basically going to do it's going to notice that a circle has a shape according to it and it is going to strip off the outer layers or in other words it is going to strip off the circle layer it is going to strip off the oval layer and it is going to leave in the shape part and that's what it is going to assign to our shape object here let's visualize this our shape class looks like what we have here on the left our oval class has a shape part into it and our circle is going to have an over part into it and that oval part is going to have a shape part of it and this is the setup that we have here now if we do our assignment we're going to do something like this the compiler is going to see that we are already assigning a circle to a shape and the compiler is going to notice that what we have on the left is just a shape and we don't have enough space to store information about oval and the circle here so what the compiler is going to do it is going to strip off all these things that we don't really need and it is going to leave in only the shape part that we can assign on what we have to the left so it is going to strip off all these stands and we are going to be left with something like this and then what we have on the right is going to be assigned on the left and we will have our data stored in our ship to object and if we try to use it that's what you're going to get in memory so this is referred to as slicing again the compiler is going to notice that it doesn't really have enough space on the left to store everything we have to the right of the assignment here and it is going to strip off or slice off everything we don't need and it is only going to leave in the shape part and that's what it is going to assign on our object that we have on the left of the assignment operator here and this is referred to as slicing in c plus plus terminology i just want you to be aware of this and we're going to see a lot of this starting from now now that you know this we're going to head over to visual studio code and play with this a little more here we are in our working folder the current project is size of polymorphic objects and slicing we are going to grab the code from the last lecture so let's grab everything except", "98395.76 - 98697.12": "everything and we're going to put that in the current folder and we're going to open this little guy in visual studio code by dragging and dropping here this is going to give us our project and we can head over in the main cpp file and clean up all the mess we got from the last previous lectures we can also take out these functions because i don't think we need them here and we are going to check out on our classes notice that we are using dynamic polymorphism because we have virtual functions here so if we happen to be using base pointers or base references to manage our derived objects we will get polymorphic results okay the first thing we want to see is the size of objects for our classes here because we are using virtual functions let's head over in the main cpp file and we're going to put in a piece of code which is just going to use the size of operator to print the sizes of objects of these classes we can try to build and run this program we're going to use gcc here the world is just going to be good we can bring up a powershell window we can use to run these programs we're going to do that new terminal this is going to bring us our window here we can clear and run rooster we're going to get 40 56 and 56 so you see that these are our sizes so let's say that with uh dynamic is going to be 40 for the base class with dynamic portal morphism we're going to get 56 for the oval object and we're going to get dynamic 56 for the circle object here now we're going to remove the setup that uses polymorphism and we're going to see the results that we get all we need to do is to remove the virtual keyword here we can comment it out you can do something like this in shape and we're going to hop over in oval and comment out the virtual key world we can do something like this and this is going to work without removing this completely from our code because we still need to leave this in as a reference we're going to hop over to circle and do the same thing and now that we have this setup we can hop over to our main cpp file we're going to see that we don't have any squiggly lines of some kind so this is going to be accepted by the compiler but if we build and run this program we're going to see different sizes let's see if the world is good it is good as you see here we can clear and run rooster now you see that with static binding the base object is 32 bytes the awful object is going to be 48 and hopefully you can see that with dynamic polymorphism our objects are going to be much larger because the compiler has to keep track of the information that allows it to dynamically resolve virtual function calls that's why our objects are larger with polymorphism and you should know that you are not getting polymorphic results for free you are going to be paying in terms of much more memory that you use for your objects in your c plus plus programs this is the first thing i want you to see in this lecture the second thing i want you to be aware of is the concept of slicing and this is going to happen if you happen to take a raw derived object and assign that to a row based object let's do something like that we are going to create a circle object and then we're going to say shape and say shape here and we're going to say equals circle one this is something we could do but notice that the compiler is not giving us any kind of compiler error because we can assign a circle to a shape because a circle is really a shape but from what we know in our inheritance hierarchy a circle is really much more than a row shape a circle has awful information in it and it also has circle information in it so it is really much larger and much wider than a shape object but the compiler is going to see that we are trying to assign a circle to a shape and it is going to be smart enough to know that we don't really need oval and circle information in our shape object that we are storing here so the compiler is going to slice off circle and oval information and it is going to leave in shape information and that's the only thing we will be able to use with this shape variable that we have in our c plus plus program so if we say shape drill you can try to guess what we are going to get and let's go back and re-enable polymorphism because some of you might think we are going to get polymorphic results with this setup here that's not what", "98697.12 - 98995.68": "going through bezel references or base pointers to do what we are doing in this example on slicing here so because we are not using base references or base pointers in this line here the compiler is going to see that these are raw objects and it is going to do slicing and slice of things we don't need in our shape variable that we are setting up on line 16 here so if we call the draw method this is going to call shape draw it is not going to do dynamic polymorphism here you should be aware of this if you're not using the base pointers or references and you hope to get dynamic polymorphism results i hate to break it to you but you're going to be disappointed because the compiler is going to slice off derived class information and all you're going to be left with is base class information here that's why this is going to call ship draw let's build and run and really make you see this this is going to go through gcc our favorite compiler the bullet is going to be good we cannot clear and run rooster you're going to see that it is going to say shape draw even if we try to assign a circle to a shape here this is going to disappoint us because this is really going to slice off circle and oval information and it is just going to leave in the shape nucleus that we have in our circle object here if i can say it like that this is really all i had to share in this lecture i hope you found it interesting we are going to stop here in this lecture in the next one we're going to see what happens if we try to store polymorphic objects in collections go ahead and finish up here and meet me there in this lecture we're going to explore what happens if you try to directly store polymorphic objects in a collection like an array in the last lecture we have seen that if you assign a derived object to a base object the data from the derived object is going to be basically sliced off if you assign an oval to a shape the oval part of the object is going to be sliced off and we're going to be left with only shaped data that we assigned to our shape object we saw that this was referred to as slicing in c plus plus and the same is going to happen if you assign a circle object to a shape the circle information is going to be sliced off then the oval information is also going to be sliced off and we're going to be left with the inner shape part that we assign to our shape object here now i want you to see that this can happen indirectly in ways that you might not expect and we are going to use our inheritance hierarchy again the base class is going to be shape we're going to inherit from that and get oval and we're going to inherit from oval and get our circle class here so let's look at a piece of code here we are creating a bunch of objects we have a bunch of circles and ovals and we are setting up an array that is going to directly store shape objects but what we are doing is storing our pre created objects in our array here and from what you already know if you store objects in an array like this this is going to create copies even if you can't see that directly so what we have in our array here is not dirt so what we have in our array here is not any kind of direct reference to the object we have on top here these are just copies and notice what is happening we are copying derived objects in spots that are designed to store direct shape objects and you might guess what this is going to do this is going to slice off circle and oval information and only shape information is going to be stored in this array here so if we happen to look through this array like we do here and try to call the draw method this is not going to call the most specific drill method for circle or oval this is just going to call the shape version of our draw method here this is something i want you to see okay some of you might say what if i take my shape information in here and assign that to a pointer and then go through that pointer to call the draw method well i hate to break it to you but the moment your data is sliced off in a situation like this you'll never get that data back so even if you try and take the object and sign that to a pointer or a reference you're never going to get polymorphic data again the data has been lost permanently and you", "98995.68 - 99296.552": "through a pointer or a reference to manage your object that we have in this array if we call the draw method we want to get polymorphic behavior we will get to the shape version of our draw method called so the data has been sliced off permanently if we store our derived objects in an array like this or even if we directly assign a derived object to a base object this is going to slice off the data and we will never get it back anyway you should really know this okay anytime i try to explain this students mostly come up with this question what if i try to store references in my array and do something like this now this is not going to work and this is not even go past the compilation stage of your program the reason is we can't store references in a collection and the reason has to do with the left assignability rule you can't assign to a reference and i changed the reference to store somewhere else and it really drive this home let's look at this example here we have a variable called a it is of entertype and we have a 56 value inside and we set up a reference which is going to be referencing the data we have in a and down on this line here we try to change the data in our reference but this is not going to be changing where this reference is pointing to or where this reference is referencing this will merely be changing the values in our reference here and once we have this reference we'll never be able to change where it is pointing again so from this hopefully you can understand that references are not left assignable you can't store thanks that are not left assignable in an array because an array is designed to modify the data of what is stored inside so if we set up an array like this the compiler thinks that at some later point you will want to assign other data to what is already stored in this array and there is a hard requirement on the data you store in your collections for the type of that data at least to be left assignable and references are not left assignable so we can't store them in a collection like this if we're trying to do this we're going to get a compiler error but again some of you are going to say what if we store in pointers well this is going to work this is the basic working principle of polymorphism going through base pointers to manage derived objects this is going to use polymorphism and here we will get the most basic draw method called so if our object is a circle we will call the draw method on the circle object if it is a novel we're going to call the draw method for the over part of our object here this is even going to work if we go through smart pointers so if we do something like this and store in smart pointers and create our smart pointers on the fly in our initializer here this is going to work because really a smart pointer is a wrapper on top of the regular roll pointer in c plus plus so again the message here is that you need to be careful on what you store in your collections if it is a raw piece of ghana your data is going to be sliced off if you store derived objects in a collection that is designed to store base class data if you store any references that's not even going to compile but if you're storing any kind of pointer row or smart this is going to work because polymorphism was designed in the first place to work with base pointers that are managing derived objects this is really cool and i want you to be aware of this now that you know this we're going to head over to visual studio code and play with this a little more here we are in our working folder the current project is polymorphic objects stored in collections we are going to reuse the code from the last lecture because we need our inheritance hierarchy here and this is going to serve us just well we're going to copy this and we are going to head over in our current project and put in our code and then we're going to open this in visual studio code pretty quick let's do this this is going to give us our code and we have our shape class which is really what we already know we have our oval class and we have our circle class take a good look at this and what we want to see is what happens if we use different kinds of setups to store objects of this inheritance hierarchy in a collection like an array let's go back to our main cpp file and", "99296.552 - 99596.0": "here we're going to set up what we're going to be using in this lecture we are going to set up a bunch of objects that we're going to be using here basically a bunch of circles and ovals we can close the left sidebar here and have some more breathing room after this we're going to set up an array which is going to store copies of this object in this array here which is called shapes one and after this we're going to try and loop through this array and try to do things with it for example we can say for shape and we may want to call the draw method on our copy here so for example we can say s and say draw going to see what happens here and let's say references because we don't want copies in our range based for loop here so this is going to avoid copies we do in this loop and we're going to be directly referencing whatever we have in this array here now what do you expect to get we have derived objects in this array and with the setup we have here because we are using virtual functions one would expect to get polymorphic behavior so here we would expect to get the joe versions in circle and oval to be called but that's not what is going to happen we're going to see that we're going to be calling shape versions of our draw methods let's try and build and show you this we're going to world with gcc our favorite compiler the build is going to go through we can kill this and bring up a powershell window to allow us to run our program we're going to say rooster here and you're going to see that we are drawing circle one over one circle two over two circle three oval three but we are calling the shape versions of our draw method and the reason is we are slicing off derived class information in our objects the moment we try to make a copy and copy in a spot that is designed to store objects of the base class so this is basically what we saw in the last lecture on the slicing but it is disguised because we are storing data in an array and when you store data in an array like this you're going to be making copies and storing copies in your array and in any copy you make you're going to be basically slicing off oval and circle information and only storing in shape information for our objects here this is what the compiler is going to do and that really try and prove this we can try and print the size of these objects and see the sizes of these objects in this array here when we loop so for example we can say stdc out size of circle one do we have circle one yes we do so we're going to say size of circle one here and we're going to put its size information out here to be seen by everybody we're going to say size of circle one and we're going to print it out and we are also going to print the size of whatever iteration we are at in our loop here that's the first thing we're going to prep and we're going to say size of object and we're going to say size of s this is going to do and we're going to loop and see if the information we have on the outside is the same as we have on the outside again we are printing this information on the direct object which is really not yet in our array and in fact we can bring this in front of our array to make this super clear and in our loop we are printing information on a copy that we have in our array because this is the real deal we have in our array because this is a reference hopefully this is going to make sense and prove to you that we are going to be working with derived objects and the data is going to be sliced off if we copy the data in our array here this is what i want you to see so we're going to run this again we're going to pass this through gcc the build is going to be good we're going to clear and run rooster now let's look at what we have here size of circle 1 is 56 but you're going to see that the size for all our objects in our array has shrinked to 40 because derived class information has been sliced off the moment we copied our data in our array here and this is what i want you to see and i think we can even see this if we go through our debugger for example we can put a break point here and uh open our run tab and if we try to run our program through the debugger the build is going to be good and the binary is going to be passed into our debugger and we're going to hit our break point in a minute so let's wait for this and", "99596.0 - 99898.31999999999": "what we can do now is look at our local variables on the left let's look at our array the array is called ships and if we go up we're going to see our ships one array and we're going to see that we have five indexes here because we have six elements inside we can expand and see what we have at index zero and you're going to see that we just have description data because this is a shape if we go back in our class we're going to see that the only thing we have in our shape class is really a description member variable and it is what we see in our array here just description information because this is a shaped object and we have lost or derived class information and this is really cool but if we go on top and for example expand circle one we're going to see that we have a novel part of us and we have a ship part of us but these events have been stripped off in our array when we slice off the data from derived objects to only store shape information in our array here i hope this makes sense now we're going to kill our debugging session because we don't need this anymore and we are going to comment this out and see some other things so we are going to comment with our data here we're going to say if you store row derived objects in an array which was set up to store base class object the data is going to be sliced off this is something i want you to know but some of you are going to say what if we store it in references okay so let's try and do that we're going to set up a piece of code like this and we're going to set up an array called shapes2 and this array is going to be basically storing references to the objects we have on top here and we're going to see what happens you notice that we have a squiggly line already and this is saying this is not going to work because references can't really be stored in collections again as we saw in the slides the reason is because references are not left assignable and they can't be stored in a collection like an array here the basic requirement on the types that you can store in your array is that they have to be left assignable and our references are not rest assignable so this is not going to compile if we try to build our program we're going to see that we're going to get weird compiler errors and the build is going to finish with errors and if we go up we're going to see that declaration of shapes to us array of references and this is not allowed you can't have an array of references in c plus plus and this is the reason why so we're going to get a compiler error here okay so now you know this but some of you are going to say what if we go through pointers well that's going to work because polymorphism through virtual functions was basically designed to work with base pointers that are managing derived objects and this is what we have here so if we look we're going to be getting polymorphic behavior and if we call our draw method on our pointer here we're going to get the most specific joe method called and this is what we want so we're going to try and weld this again and show you that this is going to work the build is going to be good we can clear and run rooster and we're going to see that we are going to be looping around and if we call the draw method we're going to call the overdraw method circle draw method overdraw method circle draw method this is basically what we want and we are going through base pointers to really use polymorphism here this is definitely going to work if you go through smart pointers so let's comment this out and set up another example to really drive this home you can really use any kind of smart pointer you can use unique pointer or shared pointers so here we will just be storing in shared pointers because this is easier to handle and we're going to head over to the top and include the memory header if you remember if you want to use smart pointers in c plus plus you will have to include the memory header which brings in the data to set up smart pointers in your surplus plus code so this is going to look good now and if we build we're going to get the most specific version of our draw method called through polymorphism that is using virtual functions here so let's build and show you that this is going to work the book is going to be good we can clear and run rooster and we are going to get our versions of draw called the version for a circle and the version for oval because we are using base pointers to manage derived objects here and our class inheritance hierarchy is using virtual functions for the draw method here so this is going to work this is really all i wanted you to see in this lecture you should be careful if you try", "99898.31999999999 - 100196.0": "derived objects in an array that was designed to store base class data if you are using raw data you're going to get slicing and you really need to be aware of this because you want to have derived class information if you try to store any references this is not even going to compile because references are not left assignable but this is going to work if you use role pointers or smart pointers because polymorphism was basically designed to work with base pointers or references that are managing a derived object which uses polymorphism we are going to stop here in this lecture the next one we're going to learn about the override mechanism in c plus plus go ahead and finish up here and meet me there in this lecture we're going to learn about the override specification a kind of setup you can do to avoid errors in your inheritance hierarchies if you use virtual functions to set up polymorphic behavior for your derived objects and this is something that was set up in ziplus plus to avoid easy to make mistakes for example if you have an inheritance hierarchy like this you might be meaning to set up a draw overrides for what we have in the base class and an override is really a must specific method that you have in your derived class to really hide what we had in the base class for example the draw method novel is going to be overriding or hiding what we have in shape and the draw method in circle is going to be overriding or hiding what we have in oval this is the idea here but as you set up your overrides you might make mistakes for example you may mean to say draw and i use a w that is in uppercase and that's going to be bad because what you will be putting in oval is going to be a completely separate method that is different from what we have on the top and this is going to be really bad you're not going to get polymorphic behavior for the draw method in oval because we are simply not overriding the jaw method from shape and this is going to be bad so in ziploc plus we can avoid these problems by explicitly specifying that the draw method we have in alpha is an override and we can add this specification after our method header and the c plus plus compiler is going to enforce that we are actually overriding a method that exists in our parents class which happens to be shape here if we have no method called draw in the base class we're going to get a compiler error because we want to be basically overriding any method here this is going to protect us from problems if we make typos in setting up our polymorphic methods here this is the main thing we can achieve with the override specification now that you know this we're going to head over to visual studio code and play with us a little more here we are in our working folder the current project is override here we're going to grab the code from the last lecture because we are basically going to be reusing the same code over and over building on top of that if we need to do that so we're going to put in our code and we are going to open this in visual studio code by dragging and dropping here this is going to give us our code and we can really do whatever we want with that i think we can leave in the code that is using the base pointer to manage our derived objects i think this is going to serve us well enough and we can take out everything else because that's just going to be confusion we don't need all this here this is going to be serving us well now we want to learn about the override key world and to learn about that we're going to introduce a title on purpose here for example suppose we want to set up a draw override and we use an uppercase letter here for the w key world i don't think this is really easy to spot once you've made this mistake and you're not going to be getting any compiler error because this is something valid you can set up a completely new method and call it joe and this is going to work but this will be very hard to spot in your program and the compiler won't protect you as we just said if we build our program you're going to see that it is going to bulk just fine so let's pass this through gcc the voltage is going to be good but we want to get to the behavior that we want i think we can take out this sddc out statement inside our for loop here and we can weld again this is going to be less confusing okay so the build is good we can bring up our powershell window and i'm going to run rooster and see what happens you're going to see that for a circle we're going to draw a", "100196.0 - 100497.6": "but for oval we're going to be drawing shape so what is happening here we are overriding our joe method in the overclass so we should get polymorphic behavior because this is a virtual function and it is called draw exactly the same thing like we had in the base class except we've made a really simple typo here but it is really hard to track and get hold of we have named our method draw but the w is in uppercase so this is a completely different method than the draw method we originally intended to override in our base class and this is really hard to follow and keep track of we can protect ourselves by adding the override specification so if we say override the compiler is going to help out and make sure that we are actually trying to override the method that exists in the shape class and if it doesn't exist we're going to get a compiler error then we're going to look at this and really spot this mistake here this is what you can achieve with the override keyword and in fact i do recommend and advise you to use this in your inheritance hierarchy if you happen to be using virtual functions because this is going to save you a lot of time if you make mistakes like this so we're going to try and run this and show you the compiler error we get so let's do that we're going to pass this through gcc the board is going to fail as we see here and we're going to get a compiler saying errol virtual void overall joe cost marked override but does not override this is super clear we are saying we want to override here but we're not overriding any method called joe with an uppercase because we don't have that in shape here this is the message once we see the problem we can correct it we're going to use in lowercase letter for w and this is going to work just fine now we're going to use the same mechanism to protect ourselves from ourselves in circle class so we're going to override our draw method but we're going to say that we want to override explicitly and if we're both now let's pass this through gcc this is going to build successfully and if we run our program we're going to get polymorphic behavior let's do that you see that circle draw overdraw circle draw overdraw this is what we expect this is really cool this is really all i had to share in this lecture i hope you found it interesting use the override keyword in your inheritance hierarchy because that's going to protect you from easy to make typos that are really going to give you a hard time otherwise we are going to stop here in this lecture in the next one we're going to explore the concepts of overriding and hiding in detail go ahead and finish up here and meet me there in this lecture we're going to zoom in on overloading overriding and hiding we have seen that overriding is a mechanism we have in c plus plus to be able to set up most specific versions of our virtual methods in derived classes so for example the draw method we have in oval is overriding or eclipsing the one we have in shape and the draw method in circle is overriding or hiding or eclipsing the one we have in awful this is the concept here but what happens if we introduce the concept of overloading and mix that up with overriding as we have seen so far so suppose we do something like this this is our shape class it is going to have two versions of the draw method we have one that takes one parameter for example this could be the color that we want to draw our shape with and another one is not going to take any parameter and these are two overloads of our virtual method here so what is going to happen in our derived classes that are going to inherit this virtual method so let's look at an example here we have a simple example that is setting up objects of our shapes we have a shape object we have a novel object and we have a circle object here if we call the draw method on our most derived class which is circle we're going to see that this is going to work we can draw without a parameter and we can draw with one parameter which is going to be our color depth this is going to work just fine we will be reusing our inherited method from the shape class and this is really cool but what happens if you override this method in our overclass suppose we hijack the inheritance process and set up another draw method in our overclass and we only override the overload that doesn't take any parameter we can do something like this but the moment you do this this is going to only override this method and", "100497.6 - 100797.12": "methods that we had in our base class which is shaped here and this is something i want you to know so once you override a single overload of your virtual functions all the other overloads are going to be hidden and they won't be usable anymore by downstream inheritance classes if you want all the overloads to be available to downstream inheritance classes you have no choice but to explicitly override each of them and that's how it's going to work so if we look at the example here we're going to see that the draw call without a parameter is going to work because this is overridden in our oval class but if we call the one which takes a parameter this is going to be hidden at the oval level and we want to have access to that in circle and if we try to call this we're going to get a compiler error again the message is if you override one overload of your virtual functions in the base class all the other ones are going to be hidden and you have no choice but to explicitly override them for them to be available and usable in downstream classes this is the message i wanted to convey here okay so now we know this but what if we set up another overload downstream for example what if we go in our oval class and set up another overload which is going to have two parameters for example we might have the color depth and the color here that we want to draw with okay so one thing you should know is that this this method is not going to participate in shape polymorphism and what i mean is that if we go through a base pointer or reference to manage derived objects we can't really call this method with shape polymorphism so if we go through our shape pointer or reference we want to be really able to call this method if we try to call it we will get a compiler error the reason is this method is not known to the shape class that's why it's not going to participate in shape polymorphism the only methods that are going to participate in shape polymorphism are the methods that are declared in the base class and they are virtual this is the condition here and if you violate this condition in any way shape polymorphism or base class polymorphism in this case is not going to work and you will get a compiler error so if you try to do something like this and you want to call your draw method with two parameters you're going to get a bunch of compiler errors and this is not going to work another thing i want you to see is that if you assign a derived object to a base object your derived virtual functions are going to be wiped out as part of the slicing that we have learned about already so the circle port is going to be wiped out the oval part is going to be sliced off and the draw method is going to go with our oval part and we will only be left with the shareport and if we try to call this method here we will get a compiler error because it's no longer available it's been sliced off this is really what i want you to see here now that we know this we're going to head over to visual studio code and play with this a little more here we are in our working folder the current project is overloading overriding and hiding we want to explore these concepts in a little more detail we're going to grab the code from the last lecture because that's going to be a good starting point we're going to take out the binary we don't want that and we're going to copy and we're going to put that in our current project here this is going to do and we are going to open this in visual studio code pretty quick by dragging and dropping here and we're going to see that we have a bunch of virtual functions here who just have the draw version but we can set up an overload of this draw method here this is what we want to do so i am going to go below here and set up an overload of this method this is going to be taking the color depth as a parameter and we want to see how usable this is downstream so we're going to go down in the main cpp function and take out what we don't need here we really need a bunch of objects we can set up circle one and over one and we will see that we can call this method we're going to say circle one draw without a parameter and we're going to say circle one draw and pass and 44 as our parameter and let's go back and make sure that we have our overload and this is going to be taking the color depth and let's try and build our program because we have a squiggly line here let's see if it is just a visual studio code playing games with us we're going to pass this through gcc and we will have a compiler error here so what is going on candidate virtual draw cost let's go up and see what kind of problem", "100797.12 - 101098.15999999999": "just talked about in the slides we are setting up our overloads here but this is being eclipsed by the overloads that we are setting up in oval you see we have a draw override and this is also being eclipsed by the override we have in our circle class here if we want the two overloads we have from shape to be available we can comment out the overrides we have both in circle and oval let's do that and that's going to be available and usable so let's do that this is a really good learning opportunity and now if we go in main cpp we're going to see that this is going to become available so we can upload this with gcc again to bring visual studio code up to date and you see the build is good and our methods are usable even from derived classes so for example we can also set up a novel object let's say oval one and say draw this is going to work if we say ovo one draw and pass in a parameter let's put in 54 for example this is going to do you're going to see that this is going to be accepted by visual studio code and if we weld and run this program it is going to build it is going to be calling the inherited functions in oval and circle here the boat is good we can kill our terminal here and bring up a powershell window we can use to run our program we're going to see that we call shape draw and shape draw because these are inherited functions from the shape class that's why we are saying shape draw here and we're going to be drawing a oval and a drawing with a color depth we're going to be drawing the circle and drawing with the color depth here this is the message i want to convey but the moment we override these methods in any downstream class for example if we go in our over class and and comment out the override for the draw method notice that we are just overriding a single overload again if we go back to our shape class we have an overload that doesn't take any parameter we also have an overload which is going to take one parameter in oval we are just going to override the overload that doesn't take any parameter but this is going to hide all the other overloads we had for the draw method here and this is the only overload that is going to be available in downstream classes so if we go back in main we're going to see that the one with a parameter is not going to work and we're going to get a bunch of compiler errors this is going to be the case even in circle if we uncomment this guy the others are going to be eclipsed again the other one we have is just the one with one parameter but this is going to stay true even if you have a hundred overloads all the others are not going to be available if you happen to only override one of the overloads in other words the other overloads are going to be hidden by this one overall ride that you are putting in your inheritance hierarchy you should really know this if you want this guide to be available in downstream classes for example you can also override that in derived classes this is an option we can go in oval and put in another overload for this this is going to bring this back in scope so we can say overdraw here with the color depth i don't think we copied the right thing we can grab this and go in oval and put this in place this is going to do we're going to say oval drawing and we can go in circle and also put this end this is an option and we're going to say circle drawing and now you see that the squiggly lines in main go away because we have overridden all the overloads okay if we build and run our program we're going to see that this is going to work as we expect the world is going to be good and we can clear and run rooster we're going to see that overdraw called overdraw called we are calling our derived overrides and this is really cool this is what we want here let's take this back because we don't want these overridden in our inherited classes so we're going to take this out in oval and we're going to take this out in circle and i want you to see that shaped polymorphism is not going to work if you override your methods at a downstream level so what we are going to do we are going to go at the oval level and set up another overload for the joe method here but this draw method is not going to participate in shape polymorphism because it is really declared at the oval level and any base pointer we have or any shape pointer we have is not going to have any knowledge of this overload that we are about to set up here this is what i want you to know okay so we are going to go in our oval", "101098.15999999999 - 101395.04": "set that up here it is going to be taken two parameters one is going to be the color depth the other is going to be the color and we don't want to pass a string by a value like this we can use std string view and we can include that if we need to but it looks like visual studio code has got this from something else we have included before but we can include that explicitly to avoid problems so let's do that we're going to say stream view here and now we want to see that this method is not going to participate in shape polymorphism even if it is a virtual functions the reason is this is not going to be known by your shape pointers because it is not declared at the sherpa level here i really want you to know this we're going to take out everything we had here and we can set up a shape pointer we're going to say shape and say ship ptr and we're going to set up a derived object here we can say new and serious circle and what do we need to build the circle object we need the radius and the description so we're going to put that in place here the radius is going to be something like 10 why not and the description is going to be circle one how creative and we want to see if our method is available through polymorphism and it is not going to be available because the method was not declared at the shape level so if we do shape ptr and say draw and we have a method which is going to take two parameters at the oval level we have the color depth and the color so for example if we go in main and say the color depth is 45.21 not let's say this is something that makes sense or let's use 45 because this is an integer parameter and we're going to pass in a string let's say red you're going to see that this is not going to compile because the draw method with two parameters is not known at the shape level this is the message i want to convey here so if you want your method to be usable with polymorphism the method has to show up at the top level this is what i want you to see here if we're trying to build this we're going to get a compiler error and you need to be aware of this but know that even if this is not working with shape polymorphism this can work with oval polymorphism and this is an idea i am going to explore in the next lecture where we learn about the fact that polar morphism can be set up at different levels so we are going to stop here in this lecture and explore that idea in detail in the next lecture so go ahead and finish up here and meet me there in this lecture we're going to explore the idea that we can do polymorphism at different levels in our inheritance hierarchy suppose we have a hierarchy like we see here the top level class is animal and we can derive from animal and create a feline animal we can derive from feline and create a dog animal we can derive from feline create a cat animal we can also do it the other way and create a bird which is also an animal a bird is going to have its own methods and member variables that make it a bird we can derive from a bird create a pigeon and we can derive from a bird and create a crowd and we can do all these things that these animals do so the idea i want to expose here is that polymorphism doesn't have to always only work on the top level class if you have an inheritance hierarchy like this if you want you can declare a virtual method at the feline level and make sure that method is also available in deriving class and you can set up feline polymorphism if that makes sense for your application following the same idea you can also set up a virtual method in the bird class and you can have that method overridden in downstream inheritance classes like pigeon and crow and you can set up bird polymorphism in your c plus plus program if that makes sense of course you can still use animal polymorphism if you want to do that and that's going to work as well this is the idea we're going to explore here okay so with that inheritance hierarchy in mind we can create animal polymorphism and animal polymorphism is just going through the animal base pointer and using that to manage derived objects for example here we have a dog we have a cat we have a pigeon we have a crow we can do animal polymorphism and storing any kind of animal we have here you see we are putting in a dog we are putting in a cat we are putting in a pigeon and we are putting in a crow and if we do animal polymorphism and call the breathe method which exists in any kind of animal we have in our", "101395.04 - 101696.72": "specific breathe method on each animal and this is going to work really well this is going to do animal polymorphism following the same idea we can also do feline polymorphism and in this case feline is going to be acting as our base pointer so again we have our dog we have our cat we have our pigeon if we do feline polymorphism we will have to put in all kinds of crazy felines we have in our program for example we can put in dog and cat and this is going to work if you do fill out a polymorphism like we are doing here and put in an animal this is not going to work because the animal top level class is probably not going to override the virtual method we are interested in here for example here we are calling the run method and the run method is not set up at the animal level let's go back and look at our inheritance hierarchy here you see this is our animal class our virtual method is going to be breathed because any kind of animal we have is going to need to breathe but the run method is set up at the feline level so if we try and store an an animal in a setup that uses filing polymorphism the run method is not going to be available and we're going to get a compiler error so i want you to know this but we will also see this in a minute when we hit visual studio code to really play with us okay we can also do bird polymorphism and here you see we have two objects one is a pigeon the other is a crow and we're going to do bird polymorphism here and what that means is that we will use a bird pointer to manage all kinds of crazy birds in our c plus plus program for example we can use that to manage a pigeon we can use that to manage a crow and if we loop through our birds and call the fly method the most specific fly method is going to be called in this case at the first iteration we're going to call the fly method on our pigeon object at the second iteration we're going to call the fly method on our crawl object here and this is going to work now that you know this we're going to head over to visual studio code and play with this a little more here we are in our working folder the current project is polymorphism at different levels we're going to grab our template files let's grab it all we're going to copy this and put this in our current project and we're going to open this little guy in visual studio code like we always do and before we open this up i am going to put in the classes i have lying around on my drive and these are going to be the classes making up our inheritance hierarchy here to make things go faster if you want you can grab these classes from the attached resource section on this lecture you're going to find all these files you can download them and put them in your project and use that as a starting point because you don't really want to be creating all these classes this is going to just waste your time the basic idea i wanted to expose here is doing polymorphism at different levels so we're going to open this up in visual studio code by dragging and dropping here this is going to give us our good starting point you see we have a bunch of classes in here but all these classes are really trying to set up the inheritance hierarchy we have here the top class is going to be the animal class we can derive from animal and create a filler in a class and we can derive from animal and also create a bird class we can derive from feline and create a dark we can derive from feline and create a cat and we can also derive from bird create a pigeon we can also derive from bird and create a crowd class and at each level we're going to have a virtual method that we set up that other deriving classes can call through polymorphism for example if we do animal polymorphism we will get the correct breathe method called regardless of the actual object we are managing with our animal pointer if we do feline polymorphism we can manage our objects through feline pointers but we will get the correct run method called regardless of which kind of object we are calling this method on so if we call the run method on a base pointer managing a dog object we will get the run method called on the dog object this is what we mean here okay so we have our classes here let's take a closer look at our animal class it is our top level class and it is going to have a virtual method which is called breathe it is caused because it is not modifying our class here notice that we don't have a virtual destructor because i wanted to keep this simple but in your practical object you should make your destructors virtual if you happen to have a virtual function in your class here so for example we can even do that let's make this virtual this is not going to cost us anything", "101696.72 - 101995.512": "this is going to be our top class we cannot look at the implementation file it is not going to do anything special it is just going to forward whatever parameter we pass and use that to initialize our member variable i think we can also go in and change our parameter to a string view so we can do that hdd string view let's go in the cpp file and also change that pretty quick we're going to say std string view here and this is our animal class we're going to go in our feline class because that's the deriving class feline is going to be inheriting from animal publicly just as we see here we're not going to really do anything special we're going to set up a member variable called fur style and we're going to forward the data from our constructor and use that to initialize stuff in our class here our parameters are also going to be passed as std string view types so let's do that here and this is in place we also have a virtual method which is called run and inside we are just printing which kind of object we have and uh giving a hint on the method that is being called here this is what we just do here and we don't intend to create feline objects directly that's why we're not setting up any overrides of the top that's why we are not setting up any direct specific overrides for these methods but we will do that in downstream classes for example dog and cat because that's going to make sense there let's go in the cpp file for feline and also change things a little bit we're going to use std string view parameters let's do that for the second parameter as well and this is our filling class so we can go in and look at our dog class let's see if we can find it and i don't think we made our destructor in feline a virtual so let's do that and look at our delta class pretty quick here we have our dog it's going to have no member variable at all and it will just forward this data to upstream classes but we can override our breathe method we get from the animal class we can do that and we are going to say we can grab this entire thing and we're going to go in dark we can do that if we want we're going to put this method down below here and we're going to say breathe we're going to say that this is overriding what we have on top and we're going to say dog breathe called this is going to do and we also need to change our parameters to hdd strength view let's do that this is going to make things work better because we will avoid unnecessary copies and we will be able to pass string literals as parameters to this constructor here this is what we want to achieve with us we can hit the cpp file for a dog class and we're going to change the parameters again std string view and we're going to say std string view as well here and we're going to go to the header file again and make sure we have a virtual destructor here because this is good practice if you are using virtual functions like we are doing here we can grab our breathe method and hop over to our cat class again remember the inheritance hierarchy we are going after is what we have here so if you are confused please come back and look at this you're going to really understand what we are doing here we're going to go to the dog class and make sure it is working as we want so we just did the dog class and we just made sure it works like we want now we're going to hop over to cat and make sure it is now we're going to hop over to the cat class and make sure it is overriding the brief method to make sure the correct method is called okay so let's do that we're going to hop over to our cat class it is going to have its own meow method but it can also override the breathe method we get from the animal class so let's do that we can grab this and we can go to our cat class let's do that we're going to put in our virtual method and we're going to say cat breathe and this is really all we also need to set up our parameters correctly using std string view let's do this std string view and this is really all we need to do here we can also make our destructor virtual because this is good practice we hop over in the cpp file and change our parameters to be of type std string view let's do this and this is done we can really work with this inheritance hierarchy here we're going to also go pretty fast and work on the other side of our inheritance hierarchy we're going to work on birds let's look at the bird class it is going to inherit from animal it is not going to do anything special really but we just want to change the type of our parameters to std string view and i'm going to do that", "101995.512 - 102295.04": "to hop over in the cpp file and change these things here let's do that we're going to say std string view and do the same thing here std string view and bird is done we can grab our breathe method for example let's go back to the top and grab that from our animal class and we're going to hop over to one kind of bird we have in our program we can look at pigeon for example the last class here we're going to override the breathe method and i'm going to say pigeon breathe and we are going to change the type of our parameters here to std string view and i'm going to do the same here and let's hop over to the cpp file and change the type of our parameter let's do that for the second parameter here this is done let's look at the second kind of bird we have i think we have the crow class we also want to override the breathe method we're going to say crow breathe and we can go up and change our parameter to be of type std string view and we're going to do that here again if you are not interested in these changes you can just grab the code and you're going to have all these classes ready for use i just wanted to correct this little problem i had in my classes on my drive because this is not good to design in modern c plus plus we wanted to do things proper because we are really learning about modern c plus plus here let's hop over to the cpp file and finish this up we're going to change the type to hdd stream view and uh let's use view correctly and we're going to say std string view on the second parameter and this is done now we have our inheritance hierarchy and we're going to start by looking at animal polymorphism again we just set up this inheritance hierarchy now we are going to try and do animal polymorphism okay so now we're going to hop over to the main cpp file and we are going to clean it up a little bit remove whatever it is we don't need we are going to put in our includes we're going to include all of the fans in our file here animal feline dog cat bird pigeon and crow we're going to include all this and we just want to play with animal polymorphism here we are going to set up a bunch of objects and we're going to put in dog cat pigeon and crow all kinds of crazy animals we can create in our c plus plus program and we're going to put them in an array that is storing animal pointer and this animal pointer is going to enable polymorphism for our objects that we have in here remember animal sets up a virtual method called draw if we go back we're going to find that and we made sure to override this method in all kinds of crazy animals we can create for example in our cat we have a breathe method overridden in our dog class we have the breathe method overridden and what we want to achieve in our main cpp file let's go there if i can find it we want to achieve a setup so that if we call the breathe method we're going to call the most specific breathe method on our animal pointer here even if we are calling that method on a base pointer this is what we want to achieve this is going to be animal polymorphism because the base pointer is of animal type this is what we mean here let's try and build this program so if we look and call the breathe method the correct breathe method is going to be called and what we expect for the first object which is a dark object we're going to get the dark breathe method called for the second iteration the category breathe method is going to be called for the third for the third iteration the pigeon breath method is going to be called for the last iteration the crow breathe method is going to be called this is what we expect to see if we run this program here so let's do this we're going to pass this through gcc our favorite compiler we can use any compiler we want but gcc is going to do in this case okay the build is good we can bring up a powershell window to play with and we're going to run rooster our program and if we run this you're going to see that in our loop the first iteration is going to call dog breathe because the first object is a dog the second iteration is going to call cat breathe because the second object is a cat the third iteration is going to call pigeon breathe because the third object is a pigeon and the last iteration is going to call crow breathe because the last object is a crow and notice that we are calling the breathe method through a base animal pointer and this is what polymorphism is all about and what we are doing here is animal polymorphism but this is not what we are really after in this lecture we want to see that we can also do feline and", "102295.04 - 102596.552": "hierarchy so we're going to put in a separator let's do sddc out and put in a bunch of dashes here or hyphens some people call them like that doesn't really matter and we're going to play with feline polymorphism let's do this we are going to go down and put in a simple piece of coat that we're going to be using to play with things here and we're going to set up a bunch of objects we have a dog we have a cat we have a pigeon and we are going to use a feline pointer to manage feline derived objects for example we're going to use this pointer to manage a dog and a cat but one thing i want you to see is that if you put in a pigeon for example this is not going to work because a pigeon is not a feline so the compiler is going to give you a compiler error let's try and do that we're going to try and put in pigeon here pigeon 2 you can select this and if we do that you're going to see that we get a squeaky line this is the sign that this is going to go wrong because we are storing in felines and the pigeon is really not a feline even by our inheritance hierarchy so the compiler is going to give us a compiler error let's try and weld to show you the compiler error okay the world finished with errors and if we go and we're going to find that cannot convert pigeon to feed line pointer so this is the error here you can't do something like this even if you create an animal object let's say that we're going to go in and create animal and we're going to say animal one we can do that and we're going to pass in the description i think we can do that we can do something like this and if we try and pass in the address of animal one let's do that this is also going to give us a compiler error because animal is not a feline again if you get confused come back and look at our inheritance hierarchy here what we are setting up in our code we are using feline polymorphism but we want to store an animal in a raid that is storing felines and this is going to be a problem because the compiler isn't really going to be able to process this our base pointer is a feline and we should really be able to only store in derived types from feline but we are putting in a superclass or a parent class of feline which will not be able to have these specializations that feline is doing so the compiler is really saying this is crazy i can't do this i am going to throw a compiler error this is the behavior we get here okay so this is going to give us a compiler error and let's run and see that we're going to use gcc the book is going to finish with an error and we are going to see that we have an invalid conversion from animal pointer to filament pointer this is what we want to do here we want to convert an animal pointer and store that in a slot that is only supposed to store feline pointers so this is not going to work but if you do everything right and only put in derived types of feline you're going to get the correct length to work and let's look at our dog class let's open it again we're going to look at dog and we're going to have a run method but we don't have that set up for our dog class but we can do that pretty quick let's look at cat and see if we have a run method we don't but we can set that up let's go to feline and copy our virtual function we can do that and we are going to go in dog and set up another virtual method which is going to be run and this is going to be an override of what we have in our inheritance hierarchy so this is an override method we are also going to do the same but before we go let's say that this is the dog class we are doing thanks from we are going to grab this method again and go in cat because that's another feline we have in our program we can do something like this and we're going to say cat here okay so now let's come back to maine and we're going to weld again we're going to pass this through gcc and we still have a pigeon in here so this is not good let's check this out make sure that we only have a few lines in this array here let's build again okay you see the bolt is good we can clear and run rooster we're going to have our separator here and you're going to see that we are calling our dog method at the first iteration because the first object is a dog and we are calling a cat running method because the second object is a cat and this is filing polymorphism in action hopefully this proves to you that we can do polymorphism at different levels depending on what we want to achieve in our c plus plus program to close off this lecture we are also going to set up bird polymorphism let's do that we're going to put in a separator and we're going to say vertical demod", "102596.552 - 102895.192": "bunch of objects and set up a base pointer array which is going to be a bird pointer array in this case and we're going to be storing in derived objects of the base pointer type so we are going to be storing any derived objects of bird and we have a pigeon and a crow and this is the setup we want here now let's go and look at the setup we have in our pigeon for example we don't have a fly method we just have a cool method because the pigeon coos if we go in our crow we're going to see that we don't have fly method we're just having the cow method because the crowd calls but if we call our fly method because we don't have this method overridden in any downstream classes of bird we will get the base version of the fly method called so we will get this method here called i want you to see this let's hop over to the main cpp file and make sure we have the correct setup looks like this is what we want we're going to build this with gcc the book is going to be good as we see here and we're going to run now we're going to see bird fly bird fly for pigeon one and crow one but this is not using any derived method that we have in our crow and a pigeon class if you want you can also override the fly method and you're going to get that called let's actually do that because i'd like to show you things directly so that you can really see with your own eyes so we're going to go in bird and grab the fly method and we're going to override this in pigeon we can do that and we're going to override here and we are going to say pigeon here and we can grab this and i put this method also in the crowd class can do that and we're going to say crow here now if we run this program using what we have in the main cpp file for the first iteration we're going to call the fly method on the pigeon object because we have the fly method overwritten at the pigeon level as we see here this is right here beneath our eyes and we're going to see this in action if we run this program here the same is going to happen for the crow object here let's build with gcc to really prove this the builder is going to go through we can clear and run rooster and we're going to see pigeon fly crowd fly this is proving what we set up in this lecture here this is really all i had to share i hope you found this interesting the main message is that you can set up polymorphism at different levels in your inheritance hierarchy depending on what you want to achieve in your c plus plus program we saw that we could do the usual thing and use the top level class as the driver for our polymorphism and we did animal polymorphism here but nothing prevents you from doing feline polymorphism or bird polymorphism as we saw in this lecture we are going to stop here in this one in the next one we're going to see how we can do polymorphism with static members go ahead and finish up here and make me there in this lecture we're going to explore how inheritance and polymorphism play out with static members that we have in our classes and we're going to be using this inheritance hierarchy here our base class is going to be shape we're going to inherit from that and create an ellipse class let's look at some code here so we're going to set up our base class as shape as we said and we're going to have one member variable which is going to be our description here we're going to have a constructor and a destructor and we're going to have a default constructor which is really not important here but notice that we have a static member which is called m count and if you remember a static member variable is a kind of variable which is associated with the type itself it's not associated with any object that you create if you forgot this please go back to our chapter on classes or user defined types you're going to learn all about static variables here we are just exploring how they play out with inheritance and polymorphism now we have a shape class if we inherit from it and create an ellipse class for example we're going to have all the data that was public in our base class to be public in this class as well so by that logic we are also going to get this static variable inherited and we're going to be able to access it from ellipse objects let's try and use this in code here to really drive the point home here we are creating a batch of shape objects here is our first shape we print our static variable through this syntax here because it is public we can do this we're going to get a one because we just have one shape here we create a second shape and we print the count", "102895.192 - 103195.192": "have two shapes in here we create our third shape and we try and print the count we're going to get three and if you wonder how we are incrementing this static variable we may do this in our constructor we're going to see how this works exactly once we hit visual studio code in a minute but note that every time we create an object we're going to be incrementing our static variable that's why we see one two three as we created these objects here this is the logic now we have three shapes here we go down and create a new object which is of ellipse type if we print the shape count we're going to get four because an ellipse is a shape and ellipse is inheriting the static variable from shape so we're going to get a 4 printed out here but if we also print ellipse count we're going to get a 4 even if we really just have one ellipse so the static variable from shape is being inherited and used in our ellipse class and this may not be what we want so the problem here is that the static variable we are using in shape and ellipse are the same because the one we have in ellipse was inherited from shape that's why we have these results here but sometimes we just want to have ellipse count to b1 here because in reality we really have one ellipse so how do we do that to get that behavior you can also set up another static variable named exactly the same way at the ellipse level and you can do that like this you can also override the gate count method to return the current count in ellipse this is going to work through polymorphism because the getcount method is a virtual function if you call this method through a basepointer you will get the correct one called which is going to be the most specific one through polymorphism but what we want to see is how things are going to work now that we have a static variable which is named exactly the same as the one we have in our base class here the one in shape is exactly named m count it is a static variable of type and the one we have in ellipse is also the same it is a static variable called m count of type and but now ellipse is going to maintain its own static variable and shape is going to maintain its own static variable now we are going to get this kind of behavior we are going to see that if we try and print the count of shapes we have we're going to get a four here but now if we try and print the count from ellipse we're going to get a one because we already have one ellipse and this is working because ellipse is going to maintain its own static variable and this is going to give you this behavior if it is what we are after in our c plus plus program now we can also go on and create a bunch of other objects here we are going to store them in this array which is going to be storing shared pointers to shape and we're going to store in derived objects this is the syntax we can use to do this and at the moment we do this we're going to get six shapes because in total we already have six shapes but three of those shapes are going to be ellipses and if we try to print the ellipse count we're going to see that we have three ellipses in our c plus plus program and this is going to do what we want another thing you could do is also do shape polymorphism and call the gatecount method and you're going to get the correct getcount method and print the most specific account if we are calling that method on an ellipse object for example we're going to print three if we call that on a shape object we're going to get sex and that's the behavior we could achieve with polymorphism with static member variables and i really want you to be aware of this now that you know this we're going to head over to visual studio code and play with us a little more here we are in our working folder the current project is inheritance and polymorphism with static members we're going to grab our template files and put them in place and i am going to grab our classes from my drive and use this as the starting point again if you don't want to type or create these classes you can use the files provided in the resource section of this lecture you can download them and use them directly without having to create them because we are really interested in how static members behave with our inheritance hierarchy which happens to be setting up polymorphism this is what we want to learn about here i am going to open this up in visual studio code and we're going to take a good look at our classes the base class is going to be shape which is what we have here it's going to have a virtual method which is get count here and we have a static member which is of type and i am going to change my parameter here to bsdd string view because that's what we should do in", "103195.192 - 103497.12000000001": "file for this and we're going to fix this a little bit and we're going to hop over back to the header file and look at what we have we have a virtual method which is going to return this count here it is a const method because it's really not going to modify it's just going to return a copy of the count member variable we have here and this is a static member variable notice that it is not in line so we will need to define this in the cpp file somewhere because this is a declaration we need to put in a definition which is what we have in our cpp file here because we are doing thanks in the older c plus plus way we are going to increment our account member variable in our constructor and this is going to achieve the behavior we really want to have the m count member variable which is static incremented each time we'll create a shape object here let's go back and look at our destructor and make sure that it is virtual because we have virtual functions in this class and this is the setup we have let's look at ellipse and we're going to take out this static member variable because we don't want to set it up as of now we will enable it in a minute let's make sure we remove this and let's remove this because i don't want this and now we can try to create objects of our classes and see how these guys play out we can also go in ellipse and make sure the constructor is taken std string views where we are needing strings you can do that and hop over to the cpp file and do that std string view i think this is going to make a visual studio code happy by now we can hop over to the main cpp file and clean it up a little bit and we are going to include ellipse and in our main function we're going to create a bunch of objects let's close the left sidebar here because we don't really need that anymore we're going to grab a shape object and we're going to print the shape count we expect to get a one because we just have one shape at this moment we're going to create a second shape here and if we print the count we're going to get two because we have two shapes this is what we expect we create another shape which is going to be shape three here we print the count we're going to get a three but the problem is going to come when we create an ellipse here if we create an ellipse and print the count we're going to get a four because we have four shapes in our c plus plus program but if we print the ellipse count here we expect to get a one but that's not what we're going to get we're going to get a 4 because the m count variable in ellipse is inherited from our shape class so it is going to be the same thing we have in shape here because if you go back you're going to see that at this point ellipse doesn't have a static variable m count of its own so it's going to use the one it is inheritance from the shape class this is the behavior we're going to get here and i want you to be aware of this if this is what you want this is fine but in most cases you will want this to be different because you want very clear information about how many objects of each type you have created in your z-plus plus program if it is just shaped this is going to be really vague because you want to know if it is an ellipse if it is a rectangle if it is a triangle this is not going to be super clear so let's weld and really show you the problem here we're going to pass this through gcc our favorite compiler we can also bring up the left sidebar no problem here and we're going to bring up a terminal window or a powershell window i can say we're going to clear and run rooster you're going to see that the shape count is going to be one two three and we have a five here because we are also incrementing the m count variable in our derived class so we are incrementing twice if we create an ellipse object let's show you this in ellipse cpp we are incrementing the m count member variable but in the base class we are also implementing that in the cpp file that's what we have here and notice that the derived class is also calling the base class through our initializer lust here so this is the behavior we have we shouldn't be incrementing this because ellipse doesn't have its own static variable as of now now we're going to build and really solve this problem now you see the kinds of problems you can run into if you have a static variable that is named exactly the same way and you have an inheritance hierarchy really weird problems can pop up and you need to be aware of this let's build and see that the problem actually disappeared okay the bolt is good we can clear and run rooster we're going to see that now this is what we expect one two three because we have three shapes created up to this point here if we create an ellipse that's going to be another shape if we get the shape count we're going to", "103497.12000000001 - 103795.12": "us a 4 because ellipse doesn't have its own static variable to solve this problem we can go to ellipse and set up our own member variable at the ellipse level so we can enable this and uncomment it we're going to go to the cpp file and make sure we are incrementing to get the correct count incremented here i think this is all we need to do we are also going to initialize the static variable we have at the ellipse level this is going to do what we want and we can build again now we're going to get the behavior we want because at this point we are going to print a one for the ellipse count and this really makes sense because we have one ellipse even if we have four shapes in total so this is the design i think makes more sense in our c plus plus program here we are going to build this again and pass this through gcc the builder is going to be good we can clear and run rooster now we're going to see that we have four shapes and one ellipse this is what we want now that we have this we can really do all kinds of crazy things hopefully you can see that the static variable is working exactly as we want we can print the ellipse count we can print the shape count if that's what we want in our c plus plus program but we can also do shape polymorphism and get the correct get count method called in our c plus first program for example if we call the getcount method on the basepointer that is managing a shape we're going to get this one called if we have a best pointer that is managing an ellipse we're going to get to this one called this is going to be super cool let's go up in our program and set this up we're going to do this on the fly let's say shape polymorphism and we're going to say shift pointer and it is going to be an array let's say shapes this is going to do and it is going to be just an array and we're going to initialize this and store in a bunch of objects let's put in a closing brace here let's go up and see what we have for example we have shape one and ellipse one we can use these we're going to put in the address of shape one and we're going to put in the address of ellipse one this is going to do and we can loop through these guys and call the get count method so let's do this we're going to say for auto s and let's do a reference because we don't want copies and we're going to say in shapes and we're going to call the gatecount method we're going to say s and say getcount this is going to give us the count and we can print this out if we want we can say sddc out and count and we're going to put a new line character here to separate these guys and we can put a separator here we can copy what we just used in our c plus plus program here just to make sure this is super clear when we print things on the terminal here we're going to build our program and see if it actually works the body is going to be good we can clear and run rooster we're going to see that the count is going to be 4 for the first iteration because we're going to be calling the get count method from shape because that's our base pointer so this is what we're going to get we're going to print the m count member variable from the base class that's why we have a four but on the second iteration the object is ellipse and we are using polymorphism because we are going through a base pointer and this base pointer happens to support the virtual method get count we will get the most specific one called on the current object that our base pointer is managing here and this happens to be an ellipse so we're going to call the ellipse version of our virtual function here and we will get a one because we really have one ellipse in our c plus plus program this is what we see here this is really all i wanted you to see in this lecture how you can use static member variables with inheritance and polymorphism and you need to be aware of these little things that can really be confusing especially for beginners we are going to stop here in this lecture the next one we're going to learn about the final specification we can use in our inheritance hierarchy go ahead and finish up here and meet me there go ahead and finish up here and meet me there in this lecture we're going to learn about the final specifier used in inheritance hierarchies this is going to allow you to do one of two things you will either be able to restrict how you override methods in the derived classes or you can restrict how you can derive from base classes i know this is in the air but we're going to look at a few examples to really drive this home suppose we have an inheritance hierarchy like we see here the top class is animal we can derive from this and have feline you can have bird as a derived class feline can be inherited to have a dog", "103795.12 - 104095.832": "example to have wild cat and bulldog from dog you can do all these things here and this is inheritance hierarchy we're going to be using to learn about these things now here is a possible implementation for the dog class which is going to be inherited from feline publicly as we see here but take a look at the run method we are setting up in dag we are appending a final specifier and what this is going to mean is that no downstream inheritance class will be able to override the random method further this is what we can achieve so if we don't want our derived classes to override our virtual method we can mark that method as final in our class and we are basically saying i am going to put in my implementation but i don't want any deriving downstream class to override this method further if they do that they are going to get a compiler error and this is something we can achieve using the final specifier in our inheritance hierarchy again in this case we are using this to restrict how people can override our own virtual method in downstream classes or i shouldn't really say our own method because it may be coming from upstream but you are restricting people from overriding that method further in downstream classes here okay so this is the first use we have for the final specifier but we can also restrict people from inheriting altogether so here we have a simple example to drive this home we have our cat class it is going to be inheriting from feline but we are marking our cat class as final and what this is going to mean if anybody tries to inherit or derive from cat in any way they are going to get a compiler error and this is what we can achieve with the final specifier again there are two things you can restrict how people override your virtual methods if you want to restrict that from the current class you can mark your virtual method as final you can also restrict how people inherit all together from your class and if you want that behavior you can mark your class as final using the syntax we just saw in the slides here okay now that you know these things let's look at a few things that may be interesting for example here is a simple fact that you can create a class right away in market as final and when you do this nobody will be able to ever inherit from this class in your program and if we do this we will get a compiler error for example this is one thing i find interesting and i really wanted you to know this another thing is that it is possible to introduce useless virtual methods in your inheritance hierarchy for example if our cat class is marked as final what this means is that nobody will ever be able to inherit from this class but we are going further in setting up a virtual method which is meant to be inherited or overwritten in downstream classes but how do we get a downstream class if we can't inherit from the cat class which is marked final so so we have conflicting ideas here on one hand we are saying we can never inherit from this grant class but on the other hand we are setting up a method that is meant to be used or specialized in derived classes so this is something that is interesting this code is going to compile and i think maybe in future standards of c plus plus they are going to fix this problem and maybe give you a compiler error if you try to do something like this but at this point you're not going to get a compiler error this is just going to be valid c plus plus syntax even if this is really weird we have conflicting ideas here okay one thing you should know though is that we can override in a final class and this is going to make sense because for example the run method is coming from the feline class and here we are just specializing that so we are marking that as an override here even if this is the final class so be careful this is valid c plus plus syntax this is going to work just fine another thing you can do which is pretty useless in your c plus plus program is to introduce a virtual method and mark it as final right away so again this is really weird we have two ideas that are conflicting the virtual keyword means that we want this to be visualized in the downstream classes but again we are saying this method is final so no downstream class will override this if they try to do that they are going to get a compiler error so this is again a bunch of conflicting ideas c plus plus is going to allow this syntax this is not going to give you a compiler error but this is weird and you need to be aware of this okay now that you know these ideas we're going to head over to", "104095.832 - 104397.28": "final specifier in our inheritance hierarchy we will be setting up this kind of inheritance hierarchy and we will set up a bunch of virtual methods and mark them as final i think we will do that in the dog class and we will mark a bunch of classes as final and see that if we inherit from them we're going to get a bunch of compiler errors so let's do this here we are in our working folder the current project is final and we are going to bring in our template files pretty quick we're going to use this as our starting point we're going to put that in place and i am going to put in a bunch of classes i have lying around on my system because i don't want to set up these classes that would be a waste of your time just know that we are trying to set up this kind of inheritance hierarchy animal is going to be our top dog or animal is going to be our top class and we will be inheriting from this creating an inheritance hierarchy we can play with in our code here okay so we are going to open this up in visual studio code so let's do that by dragging and dropping here this is going to give us all these crazy classes we have the top class is going to be animal and it is going to be defining the features any kind of animal we support you know c plus plus program is going to have for example any kind of animal will need to breathe and we will set up this virtual method here and we will be inheriting from this animal class to create a feline class and a bird class this is something we did in a few previous lectures and we are just reusing this inheritance hierarchy here let's look at the feline class the filament class is going to set up a virtual method which is called run and the method is going to be overridden in the dog for example we can override the run method but notice that we are marking that as final okay so look at this the method is final and what this means is that no downstream classes inheriting from doug will ever be able to specialize or override this method further if they try to do that they will get a compiler error notice that this may be our method or it may be a method coming from upstream classes in this case the run method was introduced at the feline level you see it was introduced here and doug happens to be overriding this method here that's why we have the override key world but at the same time we are going to mark it as final and prohibit or prevent downstream classes from overriding this method further if we look at our bulldog class we're going to find the class to inherit from dark we have our run method here it is commented out at this moment i just want you to see that our code is just going to compile if we compile it now let's do this we're going to pass this through gcc okay you see the bolt is good and we have generated our binary which is really not doing anything because our main function is just some dummy code we have here to make sure it works with c plus plus 20 but what i want you to see is that if you go in bulldog let's go in our bulldog class and uncomment this class here or this virtual method we're going to see that we're going to get a compiler error we have a squiggly line meaning that we did something wrong and well let's look at the problems tab from visual studio code here cannot override find a function dog run this is a final method from the dog class if we try to override it further we will get a compiler error this is something we can achieve by marking our virtual method as final as we are doing here now if we try to build this program we're going to get a compiler error let's pass this through gcc and let you see this okay you see we get a compiler error and uh the error is that we are overriding let's go up and see the error here error and on line 12 in bulldog h we see that we are overriding a final method virtual void bulldog is a final function and we are overriding this and this is going to give us a compiler error this is the behavior we get so the message here is that you can go in your inheritance hierarchy at any level and mark a virtual method as final and prevent download stream classes from specializing or overriding that method further and if they do that they will get a compiler error this is something we can achieve in our c plus plus program another thing you can do with the final specifier is that you can prevent people from inheriting from your class altogether let's go to our cat class i think that's the example that sets that up we have a cat class it is", "104397.28 - 104695.832": "the class is marked as final now what this is going to do it's going to throw a compiler error anytime somebody tries to derive or inherit from this class here so if somebody tries to inherit from cat as we are doing here create a wildcat from a cat we are going to get a compiler error because we can't inherit from cat altogether it is a final class at this moment okay so let's look at our wildcat class it is going to try and derive from cat we can do something like this we can remove our comments here and if we try to do this we will get a compiler arrow let's look at the cpp file and see what we have it has nothing special but if we try to do that and inherit from cat we will get a compiler error because the cat class is final and you cannot derive from it if you do that you will get a compiler error because the cat class is final this is what i want you to see here let's try and build our program again we're going to pass this through gcc and we will see our compiler error okay the world is finished with errors if we go up we will see that we cannot derive from a final base class if we do that we will get a compiler error and this is what i want you to see here okay now that we notice we're going to take this back and take out the compiler error here because we want our code to compile we're going to make sure it is compiling fine okay now the code is compiling because we are no longer trying to inherit from cat and i want you to now see a few interesting facts about the final specifier when it works together with virtual functions let's go to the main cpp file and show you the first fact and that's that you can create a class right away and mark that as vinyl as you create it as we do here if you do that this class is going to not be inheritable and if you try to inherit from it you will get a compiler error let's take out everything we have here and just say hello in our main function this is going to do just to have something this is going to give us a compiler error because we can't inherit from a final class let's build and show you the compiler error this is going to go through gcc and the world is going to finish with errors and that we have our message here and we don't have the error we expected because we forgot to put our closing semicolon on our class definition here but we can build again and get our error okay the world is finished with errors and the error is going to be that we cannot derive from a final class this is what we expect here let's comment this out because i just wanted you to see this fact another interesting thing c plus plus allows you to do is to set up a new virtual method in a final class let's first build and make sure the compiler error here goes away and i am going to show you that okay the build is good let's go back in our final class which is the cat class if i remember correctly this is a final class we can't derive from this class but we can set up a virtual method for example the virtual method here called meow is useless why is it useless it is a virtual and marking it virtual means that you at least want people inheriting from this class to inherit it and use it or even better you want them to have the ability to specialize or override this method and make it to do more specialized things but you can't really do that because you can't derive from this class all together so this is something that c plus plus allows us to do but this is a useless method which will never be used in any way so this is something i want you to be aware of but this is going to compile again let's pass this through gcc you're going to see that this is going to compile and work even if this method is really useless i want you to be aware of this okay so the build is good here okay so this is our interesting fact number two okay even if this method is useless it is possible to specialize a method coming from upstream classes from your final class for example in feline we have a method called run which was introduced there i think we can override this method in our final class which is the cat class here so this method is going to be useless because it will be specializing what we get from our upstream class this is going to work okay so since we are looking at a few useless things you can do with final combined with the virtual mechanisms in c plus plus i want you to see that it is possible to set up a virtual method and mark it as a final in the same declaration and we're going to go to the bird class and really show you that for example", "104695.832 - 104995.512": "fly but this is marked final the moment we declare it and this is going to be contradicted for example the virtual keyword means that people downstream will be able to specialize this or inherit this but at the same time we are marking this guy as final so we are saying nobody downstream will be able to override this method if they do that they will get a compiler error now which one is going to win virtual or final final is going to win because if you try to override this method in downstream classes you will get a compiler error let's go down and look at one bird we might have in our program for example we might have a pigeon let's grab this method and try to override it you're going to see that we get a compiler error we're going to go in pidgin and put in the fly method and uh for example we're going to say pigeon fly here and we're going to say override we are trying to override this method but we're going to get a compiler error you see we have a squiggly line because this is a final method and we are trying to override this in a downstream class and this class is a downstream class from bird and in bird we map this method as final so this is not going to work even if this is virtual you want to be able to really use the virtual mechanism because this is final if we try to inherit from this if we try to override this like we are doing in pigeon here we will get the compiler error let's try and build our program and we will see that we get our trusty compiler error the bullet is going to finish with errors and if we go up we're going to find our error we're going to say virtual function fly overriding final function we are overriding a final virtual method and this is going to give us a compiler error we can't do this this is something you can do in your c plus plus program so this is really confusing because in bird the virtual keyword suggests that you can really specialize this in downstream class but this is contradictant and c plus plus allows you to do this you need to be aware of this again if we don't override this and leave this in the code is going to compile but in my opinion this is really confusing and you need to be aware of this that's the whole point of this lecture here let's make sure the code is building and this is really all i had to share in this lecture introducing the final keyword to you you can use it to restrict how people override your virtual function or you can use it to restrict people from inheriting from your class altogether and use these things if they make sense for whatever application you are designing with c plus plus we are going to stop here in this lecture and the next one i am going to show you a secret you probably didn't know so go ahead and finish up here and meet me there in this lecture we're going to explore how virtual functions or polymorphism plays with default arguments and when we say default arguments we mean a setup like this we have a virtual function here which is called add it is going to return double and it has default parameters here for a and b and the value is five here in our derived class we also have the same function we are overriding that and we have a different set of values acting as our default parameter here we are using 10 for a and b here and we want to see how this plays with polymorphism now please note that with polymorphism if we go through a base pointer to manage a derived class object what we want is to call the most specific implementation of the virtual function here for example if we have a base pointer managing a derived object and we call the add method from a base pointer we will get the most specific method here called but what you get with these default arguments is that the compiler is going to use static binding to decide which default parameters to pass to your function so even if you will get this method here called the compiler will still use the default arguments we have in our base class so we will call this method here but we will use the default arguments coming from the base class and this is the behavior you need to be aware of okay so another way to put this is that default arguments are handled at compile time the compiler is going to wire these things at compile time where you are building your application and the virtual functions are called at run time with polymorphism so if you use default arguments with virtual functions you might get weird results with polymorphism because the default arguments you will be using are going to be decided by static binding but the actual function that you get called is going to be decided by dynamic binding so we will call the virtual function in", "104995.512 - 105295.68000000001": "the default arguments from the base class this is the behavior we'll get you need to be aware of this and make sure this is what you desire my personal preference is to not use default parameters or default arguments with virtual functions because this is really going to make my code hard to follow and hard to understand especially for other developers that might have to work on my code base in the future okay here is a simple example we have a base pointer which is going to be managing a derived object and we will call the add function here what do we expect to get well because we have polymorphism here we will call the most specific add function here and that's going to be the add function from our derived class but the default argument we pass are not going to be decided by the derived class the default arguments are going to be plugged in at compile time using static binding so because the base pointer is a base object we will be using the default arguments from the base implementation of the add method so we will just plug in five and five so we will add five to five and add a two that's why we get a 12 right here and if we go through these references we will get the same result because this is going to enable or trigger polymorphic behavior in our c-plus programs if we go through direct objects we will be doing static binding and we will use the default arguments or device parameters from our derived object and remember that we use the value of 10 in there so we are going to add 10 to 10 and add a 2 and we are going to get a 22 as you see here through static binding if we do slicing by assigning a derived object to a base object the derived information is going to be sliced off and if we add we will use the default parameters from the base class and we will use the implementation in the base class so if we come back to our code here we will use the default arguments from the base class and that's a five and a five we're going to add them up because the body is going to be from the base class remember the derived information has been completely sliced off so we are going to add a five and a five and a one and we're going to get 11 printed out if we do slicing and that's the result we get right here as a closing note before we head over to visual studio code again default arguments with virtual functions can be very confusing they are best avoided because they really are going to give a hard time to anybody that is going to be working on your code in the future now that you know this we're going to head over to visual studio code and play with this a little more here we are in our working folder the current project is virtual functions with default arguments we're going to grab the code from our template project we're going to copy this and put this in the current project and i am going to grab my classes base and derived that we are going to be using here if you don't want to type along you can grab the source code from the resource section of the course if you don't want to type all these classes or create them you can grab the source code from the resource section on this lecture you're going to download this and use this you don't have to waste time typing these things because many of these things are already familiar to you we're going to open this in visual studio code and we're going to have our classes here we have a base class which is going to have a virtual function with a pair of default arguments here we are using 5 5 in our ad virtual function here and if we go and derived it is going to derive publicly from base and it is going to override our virtual function here but notice that it is going to set up its own default parameters so if we do polymorphism and use the base pointer to call the add method here we will get the most specific or the most specialized version of the add method called and this is going to call this body here but the parameters are going to be decided by static binding so because we will be going through a base pointer we will use the default arguments from the base class that's going to be five five and we're going to play with this and see what this is going to give us in the main cpp file here let's clean up a little bit we're going to remove whatever we don't need here and we are going to include our derived class we can do that we are going to put in our code to really play with us let's remove these spaces because we don't need them we are going to go through a base pointer to manage a derived object and this is a setup we can use to put things in place here we are going to call the add method notice that we are not passing in any parameter because we are going through a base pointer and the add method is virtual", "105295.68000000001 - 105596.16": "get the derived version of our add function code so we will call this add function here but be careful because we want to be using these default parameters here if we did we would add a 10 to a 10 and get to 22 in our main function here but that's not going to be the case the compiler is going to use static binding to decide which default parameters to use either those in the base class or those in the derived class and notice that if we hover over this add function you see that the compiler has plugged down those from the base class and that's what the compiler is going to do so it is going to add a five to a five and it is going to add two to that i think that's what we are doing in our derived version and we are going to get to 12 printed out let's build and see if this is actually the case we're going to pass this through gcc and that's the compiler that is our favorite now the book is going to be good we can close this and bring up a powershell window and if we run rooster we're going to see that the arrived ad was called and the result was 12 here this is what we get again the compiler is going to call the most specialized virtual function override here but it is going to use the default parameters from the base class you should really note this and this can really be confusing especially if you are a beginner to polymorphism if we go through a base reference we will also get polymorphic behavior so if we have a derived object and we set up a reference to that which is of type base and we go through that base reference and called the add method we will get the most specialized add version called so that's going to be derived and but we will use the default parameters from the base class because which default arguments we use is decided by using static binding that's what we get here and official studio code is really helpful here because if we hover over the add function we're going to see which default parameters were plugged in by the compiler and you see that they are those from the base class so we are again going to add five to a five and we are going to add a two and we will get 12 printed out here if we boil and run we're going to see that this is the case the build is good we can clear and run rooster we're going to see that with a base reference we're also going to get a 12. we will get the most specific implementation of the add method called but we will plug in the default parameters from the base class i really wanted this to be super clear if you set up things in a way that you are going to get static binding then if you are going through a base object you will call the base version of the add method and you will use the default parameters from the base class if you happen to be manipulating a derived object you will use the information in the derived class the derived version of the add method is going to be called and we are going to use the default argument from the derived class so if we set up another example here we can set up a base object for example we're going to say base and say base 3 we can do that and we try to call the add method we can say base 3 and say add we can try and store this in our research variable and we can print this out we're going to say sdbcl row research we can say something like this and we're going to print out the result here if we build and run we're going to see that this is going to call the base version of the add method and it is going to use the default parameters from the base if we go back to base we're going to see that we are going to add a 5 to a 5 and we will get 11 because we will plug in a 1 and return the result here let's build and run and see that this is actually the case so this is going to be completely doing static binding let's clear and run you see that the world is good we're going to run restaurant and we will get 11 printed out here hopefully you can see this if you assign a derived object to a base object you will get slicing let's see that we can actually do this but before we do that i also want you to see that you can also do row direct objects of derived classes if you do this you will get the information from the derived class we will use the body from the derived class and we will use the default parameters from the derived class so we will take 10 and add a 10 and we will add the 2 to that and we will get a 22 printed out i think we can do this so let's put in a separator because that's going to make it easier to follow these lengths and we're going to build with the gcc the both is going to be good", "105596.16 - 105896.64": "the bulk is good we can clear and run rooster and we're going to see that we get a 22 here if we assign a derived object to a base object directly by doing something like this event we don't need this guy here we can remove this we have a base object that we are setting up here and we are assigning a derived object to this base object here if we call the add method we will get the version from the base class because mind your steps this is going to slice off all the derived information because we are not going through any kind of base or reference so this is going to slice off all the information we have in the derived object here and we will be left with the base information and if we call the add function here you see that we are using the default parameters from the base class and we will use the body of the base class implementation here so we will add a 5 to a 5 and we will add 1 to that and we will get 11 printed out as we see here let's build and actually prove this we're going to pass this through gcc the world is going to be good we can clear and run rooster and we are going to see that the result is irreverent if we do row object assignment here this is really all i wanted you to see in this lecture that you should really be careful if you are using virtual functions mixed up with default arguments the compiler is not going to do dynamic binding on the default parameters it is going to decide which default parameters to plug in at compile time using static binding so the compiler is basically going to look at the type of the pointer or object that you have and it is going to use that to decide which default parameters to plug in so at this example here for example at line 7 it is going to see what kind of pointer do i have i have a base pointer so i am going to use the default parameters from the base implementation and if you hover over here you're going to see that it is going to plug in a 5 and a 5. even if we are using the most specialized add version in our inheritance hierarchy the compiler is going to still use the default argument from the base implementation down here on line 16 the compiler is going to say which kind of reference do i have it's going to say base because that's what we have here so it is going to use the default parameters from base and that's what it is going to plug in here 5 and 5 and we're going to get this result here down here on line 25 the compiler is going to see which kind of object do i have here this three is a base so i am going to use the default parameters from base down below on line 31 the compiler is going to look and see which kind of object do i have here the object is derived so i will plug in the default parameters for it derived again this is really what the compiler is going to do with default parameters the compiler is never going to do dynamic binding and this is going to make your code really confusing again my advice is to avoid default arguments or devote parameters if you are using polymorphism in your inheritance hierarchy we are going to stop here in this lecture and the next one we're going to learn about virtual destructors go ahead and finish up here and meet me there in this lecture we are going to explore virtual destructors and these are destructor methods you might want to be called using dynamic binding or polymorphic behavior we are going to be using this inheritance hierarchy to play with thanks so the animal class is going to be our base class we are going to derive from that publicly and have a feline class and we are going to derive from feline and have a dog class this is the setup we are going to be using here now let's look at some code we are going to set up our animal class like there's nothing really special here notice that the destructor is a regular destructor we have we will derive from animal and create a feline class which is going to set up its own virtual function which is going to be run if you want you can override the breathe method but we don't want to do that here because we just want to focus on the destructors here and the order in which they are going to be called we are going to derive from feline and set up a dog class and this dog class is going to set up its own virtual function and notice that it has a destructor which is really a regular destructor now once we have this inheritance hierarchy set up we might want to do something like this we can create a dark object and when it is time for this object to be destroyed i want you to focus on the order in which the destructors are going to be called we have seen this before", "105896.64 - 106195.04000000001": "from the specialized to the most base implementation of the destructor so the destructor for doug will be called first then we will call the destructor for feline then we will call the destructor for animal now a problem is going to pop up if we are using a base pointer to manage a derived object with polymorphic behavior that we might want for our inheritance hierarchy here so we are going to use an animal pointer to manage a dark object like this and when it is time to release the memory for this object we may be tempted to call the delete operator on our animal pointer here but this is only going to call the destructor for the base class and hopefully you can see the problem here because our destructors are not virtual the compiler is going to use static binding to decide which destructor to call so it is going to look at the type of a pointer it is going to see that it is an animal pointer and it is going to decide to call the destructor for animal here that's why we get this reserve we are managing an object which is not just an animal it has derived information in it but we are only calling the destructor for the base part of this stun so any piece of dynamic memory we might have allocated in the constructors for feline or dog is going to be leaked out because remember even if this is a dark object it is made up of base parts the foundation for this is going to be animal and on top of that we are going to build a feline level and on top of that we are going to build a dog level in this case only the destructor for dog is going to be called and any dynamic memory that might have been allocated at the feline and dog level is going to be leaked out and this is something we don't want you really need to keep your eye out on this and this is something really bad you really need to keep your eye out for this so this is really a big problem and to solve it we need the destructors to be called using polymorphism and you can set that up by marking your destructors as a virtual if you do this the compiler will know that if you are going through a base pointer to manage a derived object when the time comes for the memory to be released and you release the memory through a base pointer the compiler is going to call the most specific destructor it can find and this is going to solve our problem then we will reuse the order we are familiar with the most derived destructor will be called and it will call its best destructor and that's going to happen until we hit the most base class in our inheritance hierarchy and the memory is going to be released exactly as we would want now that you know this we're going to head over to visual studio code and play with us a little more here we are in our working folder we are going to learn about virtual destructors and before we do that we're going to grab our template files and put them in place let's do that and i am going to put in the classes that make up our inheritance hierarchy our most based class is going to be base our most based class is going to be animal after that we're going to derive we are going to derive from that and create the feline class and we are going to derive from feline and create a dog class here this is the inheritance hierarchy we talked about in our slides okay we are going to open this up in visual studio code and this is going to give us our classes here and we are going to remove these virtual keywords because we want to see what would happen if you don't mark your destructors as a virtual we're going to do that for feline we're going to do that for doug let's remove the virtual keyword here we're going to remove that and we're going to remove that for the animal class and we want to see the implementations for our destructors for animal we are just going to say that the destructor for animal was called for feline we're going to say the same thing feline destructor called for doubt we're going to say the same thing we're going to say destructor for dog called here we are using strengths as our parameters here so i think it is a good idea to change these guys to use string view i am going to do that and come back when this is done okay this is done all our parameters are of std string view type and now that we have this inheritance hierarchy let's make sure none of the destructors is virtual this is the case here we can head over to the main cpp file and use this inheritance hierarchy here we're going to crack it open and remove whatever we don't need here we are going to include our dog class which is going to implicitly include or its parent classes so we're going to include dog.h here and we are going to create a row.object by default here", "106195.04000000001 - 106496.4": "one we can do that and we might not even give it any parameter this is going to call the default constructor and if we go to doug we're going to see that it is possible to specify information here first style description but we're going to ignore this and we just want to see which order in which the destructors are called let's build and run this program we're going to pass this through gcc the book is going to be good if we clear let's bring up a powershell window to do that we're going to clear and run rooster you're going to see that dog destructor was called feline destructor was called animal destructor was called and this is really cool this is the order we expect by default but if we don't do something like this and say animal pointer and say p animal to mean a pointer to animal and we say new dog we're going to allocate a dog on the heap and we're going to manage that using a base pointer and if we try to release the memory here let's do that we're going to say delete p animal let's see which destructor gets called here because notice we are using a base pointer to manage a must specific object here which is a derived class of dog indirectly and we will see that we don't get the destructors called in the order that we expect let's build and run this program to really see this we're going to use gcc to build it the world is going to be good as you see here we're going to clear and run rooster now you see that only the destructor for animal is called even if we are really managing a dog object for things to work really well we would expect the destructor for duck to be called and then the destructor for a feline and then the destructor for animal to release or the memory that might have been allocated by these parent classes for our dog class if you go back in the cpp file for example for each of these classes you're going to see that the compiler is going to be calling each base class of the current level that we are at in doug cpp we are going to call the constructor for feline the constructor for feline is going to be called if it is doing any dynamic memory allocation we need to release this memory constructor for feline is also going to call the constructor for animal and if animal is doing any dynamic memory allocation this is going to need to be called but notice that we are just colon the destructor for animal and if we only call this destructor all of the memory that was allocated by the filing constructor is going to be leaked out because only the animal destructor is going to be called hopefully you can see the problem here but this is not the only problem the c plus plus standard says that if you do something like we are doing here and call a destructor using a pointer to the base class but that pointer happens to be managing a derived object this is going to give you undefined behavior so you're not guaranteed to get to the same behavior on different compilers on different operating systems so this is something really bad we want all the destructors in our inheritance hierarchy to be called to properly release the memory that would potentially be dynamically allocated by each level in our constructor calls the fix for this is really simple all you have to do is mark your destructors as virtual and the compiler will call the most specific destructor for your classes so all we need to do is go in and mark these guys as virtual so we're going to do that the base class destructor is going to be marked as virtual we're going to go to feline and do the same thing we're going to mark that as virtual and we're going to go to dog and mark its destructor as virtual we're going to do something like this and now notice we don't need to change any other thing if we build our program we're going to pass it through gcc it is going to do exactly what we want because now the compiler will resolve the calls to the destructors polymorphically because we are going through a base pointer the compiler will call the most specific implementation for this structure because we are going through a base pointer to call the destructor here the compiler will call the most specialized destructor we can find and it is going to find the destructor for duck which is going to be the most specialized destructor we can find in our inheritance hierarchy it is going to call the dog destructor that's going to go the destructor for feline in turn and then that's going to call the destructor for animal and our memory is going to be released properly that's what we're going to see here let's make sure we weld this again because i'm not sure if i actually built this the body is going to be good anyway so we're going to clear and run rooster now you see that the duct destructor is called the vlan destructor is called the animal", "106496.4 - 106796.48": "just going to fall in place so my advice if you are using virtual functions in your inheritance hierarchy make sure you also mark your destructors as virtual this is going to save you future headaches you might come in contact with if you are using a base pointer to manage a derived object and you are doing some kind of dynamic memory allocations in your constructors that's going to release the memory properly if you are releasing the memory through a base pointer like we are doing on line 8 here this is really all i had to share in this lecture i hope you found it interesting we are going to stop here in this one in the next one we're going to learn about dynamic casts go ahead and finish up here and meet me there in this lecture we're going to learn about dynamic casts and the dynamic casts are a facility we have in c plus plus to do downstream transformations between our polymorphic types so if we have a base planer for example we can transform it to a derived type and be able to use it like we use any row object for example if we do this kind of transformation we will be able to call non-polymorphic functions and this may come in handy sometimes this is the hierarchy we will be using our top class will be animal here we will derive from this and create our feline class and we will be live from feline and create our dog class here if we have a base pointer pointing to a dark object for example the most specialized class we can have in our inheritance hierarchy sometimes we might want to transform from this base pointer to the most derived object here and get to the direct most derived object that we can really call anything on if you remember with a base planer like animal here the only thing we can do is really call polymorphic or virtual functions but sometimes we want to do much more than this for example if we want to call non-polymorphic functions this is not going to work because the best pointer has no knowledge of those functions so if we need to do that explicitly transforming from a base pointer to a derived pointer is going to give us that capability if the actual object we are pointing at happens to have that method okay so this is what we are after in this lecture we want to be able to transform from a base class pointer or reference to a derived class pointer or reference at runtime another way you can text this is to think of the base class pointer or reference as input and we want to get a derived class pointer or reference as output in our c plus plus program and the main benefit of this is to be able to call non-polymorphic methods on derived pointers or references this is going to be super cool in some cases okay so let's look at our inheritance hierarchy here the top class is going to be animal as you see here it's going to have a single virtual method it's going to also have a virtual disruptor because we know how to do this now we can derive from this and create our filling class which is going to be inheriting publicly it's going to have its own run method and it's going to declare its own other method which is not virtual we can also derive from feline and create a dog class this is how we do this and we're going to set up our own virtual method in dog which is going to be bark and we can really do anything we want with this inheritance hierarchy okay what we're going to be using as input is a base class pointer or a base class reference and we set them up here this is our base pointer this is our base reference and we want to go from these and create a derived class pointer or reference that we can use to even call non-polymorphic functions and we can achieve that using dynamic casts here we're going to show you how you can cast pointers again our animal base pointer is going to act as our input and the output is going to be what we want to get out of this transformation and all we do is say dynamic cast we specify a pair of angle brackets inside we're going to specify the output we want to get and this is usually going to be a derived class pointer so the base class pointer is going to be within this parenthesis and and it's going to be our output and this is going to do the transformation and it's going to give us a result that we're going to be storing in our feline pointer here and if this succeeds we will have a valid feline pointer here and we can use it to call non-polymorphic or non-virtual functions like we are doing here and this is super cool another thing you can do with this", "106796.48 - 107096.872": "in a pointer check for example we can check and see if this pointer is not a null pointer if it's not a null pointer we can call our non-polymorphic function to it the result was successful but if it's no pointer we're going to fail and fall down here and we can say that we couldn't cast to a feeling pointer and some of you might ask how can this transformation fail well if we go back to our code here we have an animal base pointer which is really pointing to a feline object in memory if we try and cast this animal pointer to dog suppose we want to do this kind of transformation try to think about this this is not going to work because we really have no dog information in this villain object and if we try to cast this to dog the compiler will really have no way to do this and the transformation through dynamic cast will fail and we will say the message here meaning that we couldn't do the transformation the user asked for so here we can do the transformation and transform from a base pointer to a derived pointer but we can also transform to a derived reference and i am going to show you the syntax to do that and it is super simple we say dynamic cast and we specify our input reference notice that this is a reference you have to put it it's not a pointer and you specify the output within this angle brackets here once you do this the output of this is going to be a derived reference and we're going to store this in our feline reference here once we do this transformation and the transformation is successful we're going to be able to call our non-polymorphic function this is going to work but with references we don't have the luxury to do something like a pointer check because there is no such thing as a null reference a reference is always pointing to something and if the transformation fails we will have some kind of invalid reference and if this fails it is probably going to blow up and give us undefined behavior so you don't really want to do this i usually don't recommend doing this kind of transformation with references unless you know that the transformation is possible beforehand what i usually recommend is to pass through pointers and it is even possible to transform a base reference into a derived pointer and the syntax to do that is what you see here okay and uh once we do a transformation to a pointer if the transformation is successful we're going to have a valid pointer in here if the transformation fails we're going to have a null pointer and the check is going to draw us here and we're going to print this message to say that we can't do the transformation here okay again the cast may fail if it fails while we are trying to transform it to a dog pointer we are going to fall down here and say that the cast failed we can also do the same thing through references for example if we want to transform this base reference to a derived pointer and this fails we're going to follow here because of the check we are doing here we can do something like this to make our code much safer to work with and another thing i should really point out is that in practice casting like this is usually done in functions where you are passing a base pointer or a base reference as a parameter and in this function you somehow need to call a non-polymorphic function so you might do something like this and take the pointer and turn that into a derived pointer and if the transformation is successful you're going to call your method and if the check fails you're going to follow here and print an error message you can do something like this with pointers and we can do exactly the same thing with references but here because we want to do this check we're going to transform our base reference into a derived pointer and call our method on the derived pointer instead this is going to give us the ability to do this kind of check to make our code much safer to work with a word of caution here overusing down casting is a sign of bad design if you find yourself doing this kind of thing a lot to call non-polymorphic function that's maybe a sign that you should make that non-polymorphic function polymorphic because that's going to save you from doing this kind of transformations a lot just make sure you don't overuse this and do it in a few cases where you really need to do this kind of thing now that you know this we're going to head over to visual studio code and play with us a little more here we are in our working folder the current project is dynamic casts we're going to grab our template files and we're going to put them in place let's do that and we are going to grab the files that make up our inheritance hierarchy we're going to put those in we", "107096.872 - 107396.552": "going to make up our inheritance hierarchy here once we have this in place we can open this up in visual studio code by dragging and dropping here and this is going to give us our files okay we have our files in here we can open up the animal class which is our base class we can see that it is really simple it's just going to have one virtual method which is brief it's going to have a single member variable which is description here we can derive from this and create our feline class which is going to inherit publicly from animal feline is going to set up its own method which is non-virtual and we will have a virtual method called run we can override in downstream classes if we want to do that and let's look at the implementation for feline cpp if you want to do that you can take a look it's just going to forward the construction to the base class to build the base part of us let's look at dog dog is going to inherit from feline and it is going to set up a simple virtual function called work and it's going to have a virtual destructor now we know that we should really put in virtual disruptors if we happen to even have a single virtual method in our inheritance hierarchy because that's going to make events easier now we want to go to the main cpp file and play with dynamic casts we're going to remove whatever it is we don't need here and that we can include our most derived class let's include doug here this is going to implicitly include both feline and animal because this header is going to include its parent and its parent is going to include its own parent this is the logic here we are going to start out by using a simple example here and show you that you can't really call non-polymorphic functions from a base pointer that is managing the derived object and here we have an animal pointer it is a base pointer and it is managing a real feline object in memory but if we try and call a non-virtual function through this base pointer this is going to blow up this is not going to work because we can't really call a non-polymorphic function through a base pointer because that's not a virtual function the requirement to be able to do this is for the function to be virtual and do some feeling thingy is not a virtual function that we know at the base level so this is not going to work by default and if we're trying to build code like this this is going to give us a compiler error let's pass this through gcc we're going to do that we are going to finish the world with errors and if we go up we're going to find that class animal has no member name to do some feline thingy so this is the compiler error here this is not going to work if we need to do something like this one solution might be to do dynamic casts that we are learning about in this lecture here and the syntax is ridiculously simple so we can go down here and put in a simple separator to be able to follow this lens on our powershell window you can do this if you want and we're going to do our dynamic cast for example if we wanted to do a transformation and transform this to a dark object this would give us a problem and let's try and look at this again we have a feline object here and we are managing this through a base pointer and what we want to do is to take this space pointer and turn it into a dog object if you look at this remember that we don't really have any dog information in our feline object this is going to just go up to the level of feline but we want to transform this to a dog to make this super clear let's look at our inheritance hierarchy again what we have is a feline object and the information we have really goes up to this level and we are managing our feeling object through a base pointer this is the setup we have but we want to do the transformation and turn this base pointer into a dog object and this is going to blow up especially if we have any dog specific member variables this is going to blow up this is not going to work if we try to access dog information through what we get through the transformation to animal to dog we're going to get a crush because we have no such information and we're going to look at a simple example to really drive this home so what we're going to do is go back to our dog class and we're going to put in a sample member variable we're going to make it private and for example we can make this a member variable to keep track of the speed for the dock we can do this and we're going to initialize this to 0 by default and we're going to set up a function which is going to print some dog information let's go back to feline and copy the do some feline thingy method and we're going to do some dog thingy that's what we're going to do here i am going to put in this method and adapt it a little bit we're going to", "107396.552 - 107695.04": "account for that in the body but we also want to print the speed for this dog here so we're going to say speed and we're going to print this out suppose we have this kind of setup in our inheritance hierarchy here a dark object has some doubt specific information it has an additional member variable which is m speed here we won't worry about initializing this from the constructor you can do that if you want all we really want is to add some extra data at the dog level and we're going to see that if we try to transform to doug this is going to give us a few problems so what we want is to turn this animal base pointer into a dark object let's do this we're going to change this to dog and the result object we get is going to be a dog pointer and we want to call the do some dog thingy method on the pointer we get as a result of this transformation here let's see what happens you're going to see that this is not going to give us any indication that we are doing something wrong but if the transformation here fails this is going to silently fail and store junk data in our feline pointer here and here we're going to try and call a method that is going to possibly use some dog stuff on the feline object this is going to blow up again we don't have dog information in this feline object and the do some dog thinking method is going to try and print the speed of the dog that we don't really have we don't have any dog information so we have no business accessing dog information from this object to start with so this is going to blow up and it's probably going to give us a crash let's try and build and see what happens we're going to pass this through gcc like we always do the boat is going to go through you see that this is going to even blow up at run time when users are actually using your application this is super dangerous we're going to run this and see what happens you see doing some dug thingy and it's going to try and print the speed the compiler is really trying its best but this is really going to fail and we are crashing our program if you go down here and say done to make sure we know when the program is done and we try and run our program again let's pass this through gcc to take into account this thing we have on line 20. the book is going to be good you're going to see that the computer is going to try and really run this but it's going to see that it doesn't really have any dog information and the computer is not going to succeed because we are trying to access this dub specific information really on a feline object so we are going to get a crash again the message is that this dynamic casts can fail and we need a better way to do some kind of checks before we call our methods here and we can do this by just using the pointer we get from this transformation here so we can say if feline pointer and check and see if we have some valid data in this villain pointer and if that's the case we're going to do whatever we want to do with this pointer here okay so this is something we can do and if the transformation fails we're going to fall in this else block and we can put some nice message here instead of letting the user crash at runtime this is much better in my opinion so we're going to say couldn't do the transformation from animal pointer to dog pointer because we really have no dog information and this base pointer that we have here this is something we can do so we're going to say sddc out i'm going to say stdendl here and we're going to see what happens let's build hopefully we're not going to get the crash because we are doing something smarter now we are checking to see if we have any dog information in this pointer before we call some doubt specific method on this pointer here this is the beauty of this we're going to clear and run rooster now you see couldn't do the transformation from animal to dog and our program is no longer crashing it is ending properly and this is much better this is what you should aim for so again the transformations here may fail but if we turn this back to doing v-line transformation let's do feline pointer we're going to change this to fill in pointer again and we're going to do some feline thing now we're going to bolt again and this is true we're going to bolt again and this is going to build successfully and it is going to probably do some filament thingy the build is good we can clear and run rooster this is going to work just fine and our program is going to end properly so here we just saw that we could do a transformation from a base pointer to a derived pointer and this is going to work just fine we can also do the transformation for references let's say that here and we're going to go down and put in a simple example to drive this home we're going to have a feline object we're going to set up a reference to it and if we try and call a", "107695.04 - 107996.08": "reference this is going to blow up because the base class has no information about this non-virtual method that we declare at the feline level this is going to blow up if we try to build our program we're going to see that we get a compiler error saying no such method as do some feeling thing we're going to see that here no member named this way at the animal level this is the compiler error we get if we try to call a non-virtual method through a base reference that we have here this is not going to work but we can also do a dynamic cast and transform from a base reference to a derived reference and the syntax to do that is really here we're going to set up a derived reference in this case it's going to be a feedline reference we're going to initialize this with a dynamic cast transformation and the result of the cast is going to be used to initialize this reference here and we're going to be taking a base reference and turning that into a derived reference here this is the syntax the output you desire is going to be within this angle brackets and the input is going to be through this parenthesis here if this succeeds we will be able to call our method here and this is going to work just fine let's try this out we are going to put in a separator to be able to follow these things let's put that at line 24 here this is going to do and we're going to try and build our program we're going to pass this through gcc the boat is good we can clear and run rooster now we're going to see that we are doing some filling thingy through a reference and this is super cool we can do this you can do this kind of transformation here and at the end you see that we are calling our destructors on our objects and this is a good reminder that we didn't properly release the memory on this animal pointer that we had so we are going to go down at the end of the program and release that memory this is good practice and hopefully you can see how easy it is to forget to release some memory that you allocate for with the new operator this is a good learning experience here but this is a good learning experience here but we're going to fix this problem we're going to say animal one and we're going to release the memory now if we run the program we're going to see that we are releasing two objects when the program ends we're going to clear and run rooster and the destructor is going to be called two times once for this guy and a second for this guy this is what we want and you see that because we have virtual destructors in our classes we are destroying at each level so here we are destroying at the feline level and we are destroying at the animal level and this is going to properly release the memory from our inheritance hierarchy here so now you know that you can do a transformation of references using dynamic casts but with dynamic cast we have no way to check and see if the transformation was successful again if we try to turn this into a dark reference we can do that and we're going to say dog reference here and we will try and call the do some duck thingy method this is not going to give us an indication of a problem but this is going to crash at runtime because we don't really have any dog information in our original feline object here so if you try and transform this reference into a dog reference this is obviously not going to work because we have no dog information in this to start with let's boil and show you the problem the book is going to be good so we can clear and run rooster you're going to see that we are going to terminate our program with the band cast and this is going to crush you see that we don't get to the point where we print done and we are not even going to get a chance to release the memory that we have allocated in this main function hopefully you can see that this is really bad so with references we have no way to check and see if the transformation was successful and this is a limitation that's why in most cases i usually do my transformations through pointers and there is a way you can even turn this base reference into a base pointer and i am going to show you how you can do that so we are going to go down here and try to change things a little bit we are going to say doing proper checks with references and we're going to put in a piece of code to play with us and what we're going to do we're going to take the base reference and turn that into a base pointer this is the syntax here again the input is the base reference but the output we desire is a base pointer and this is possible in c plus plus this is going to work just fine now we are going to go on top and comment this problematic transformation we just tried to do and we're going to try and build", "107996.08 - 108295.912": "if this transformation succeeds we're going to do some villain thingy if it fails we're going to say couldn't cast to feline reference and we're going to say that we are sorry this is a good output message if we get something wrong we're going to build this with gcc and see if this actually works the world is good we can clear and run rooster you see that this is working just fine we're going to hit the end of the program and we are going to destroy our objects here this is super cool but if we try and do the transformation and transform it to a dark object even if we know that we don't have any dog information in this object that we are referencing to start with we hope that we're going to get a good message and the program is going to end properly we're not going to get a crush so let's make sure we are transforming to dog here we're going to pass a dog pointer as our output and we're going to store this as a dog pointer even if the name is still vlan pointer hopefully this is not going to confuse you even if this is named feline pointer it is a dot pointer here because we just want to see if we get the error message that we have here so we are turning this reference into a pointer and the benefit of this is that a pointer can store null pointers and we can use this to our advantage to check and see if the transformation here was successful if it was successful we will call some dog thank method let's say that here and if this fails we're going to say that we couldn't transform to doug and this is going to give us a nice message and our program is not going to crash we're going to build this again with gcc what is going to be good as you see here we're going to clear and run rooster now you see that we are saying we couldn't catch the dog reference and our program is not crashing so if you have a reference to start with and you want to do some proper checks after you do the transformation to a derived pointer or a derived reference this is the best of both worlds you can do something like this and your program is going to be much safer the last thing i want you to see is that these kinds of dynamic casts are really useful if you are passing base pointer or base references into functions and here i am going to put in a bunch of functions the first one is going to take a base pointer the second one is going to take a base reference and it is going to say do something with animal pointer and do something with animal reference and inside we're going to do our thing here we're going to take the animal pointer turn that into a feline pointer and we're going to do our proper check and we're going to do some feline thingy if the transformation was successful we can do something like this we can also do exactly the same thing with references we're going to take our input reference we're going to turn that into a derived object and we can call our method on this pointer and we're going to do proper chats because we have a pointer which has a concept of node pointer that we get if the transformation here fails this is the setup we can use in our c plus programs and we can use these methods to get derived pointers that we can call even non-polymorphic functions on and this is going to work really well so we can go down and comment out everything i guess to make this super easy to follow but i don't think we need to comment out everything we can just comment out what we just did here and we're going to be reusing the reference we have here and the pointer we have all the way to the top so we're going to go down and put in a separator here we can do that and because of this separator i don't think we even need to comment things out we can remove our comment and leave the code in because i want you to see that super easily and we're going to call our functions here we're going to say do something with animal pointer and we're going to pass an animal one which is a pointer and we're going to say do something with animal ref we can do something like this and we're going to pass an animal ref we have this reference here and we can do something like this you're going to see that this is not going to give us any kind of problem and it is going to work just fine that's world we're going to pass this through gcc the photo is going to be good we can clear and run rooster and down here you see that in function taking base pointer doing some feline thingy in function taking some biz reference doing some feeling thingy and this is working really fine this is what we want in our c plus plus programs this is really all i wanted you to see in this lecture hopefully you didn't find it confusing again the message is that you can do dynamic casts to transform from a base pointer to a derived pointer or to transform from a base reference to a derived reference as we did right here but transforming to a derived reference has a drawback in that you don't have a way to check and see if the transformation was successful so if you want to be able to do chats you can do something like this and turn a", "108295.912 - 108596.64": "and then we can check and see if the pointer is not a node pointer if it's a no pointer we will know that the transformation failed and we will print a good error message if the transformation was successful we will have a valid pointer in here and we will call our derived non-polymorphic method on our pointer this is going to work really fine the last thing i want you to see before we wrap up this lecture is that dynamic casts are only going to work with polymorphic inheritance hierarchies so for example if we try and turn a double into a string obviously that's not going to work with the dynamic cast but let's try and do that to really show you that this is going to give us a problem we're going to say sddc out and we're going to put in a separator here and we're going to set up two variables one is going to be a net for example and we're going to say data we're going to put in a 45 and if we do a dynamic cast to an sdd string for example that's not going to work we're going to say std string yana str meaning that this is a string we're going to say dynamic cast let's say we want to turn this into an sdd string for example and the input is going to be our data if you're trying to do something like this this is going to blow up you see that even visual studio code is giving us a squiggly line so this is not going to work just make sure you use dynamic cast in an inheritance hierarchy that supports virtual functions this is the design purpose for the dynamic cast if you use this outside this context you're going to get undefined behavior or even compiler errors if you are lucky let's try and weld and show you this we're going to pass this through gcc and we're probably going to get an error saying that we can't transform from an integer to a string for example let's go here cannot dynamic cast so basically it is saying dynamic casts are meant to work only with pointers or references but even then let's see if we can transform from an end pointer to a string pointer let's try and do that let's say we want to turn the address of data or let's set up a pointer to be explicit we're going to say data ptr and we're going to initialize this with the address of data we can do something like this and we're going to cast data ptr to an std strength pointer let's see if we can do this because it is meant to cast between pointers and references but you see that this is even not going to work so you shouldn't really do something like this if your input and output are not part of the same polymorphic inheritance hierarchy again dynamic casts are meant to cast from base information to derived information and the input and output must be part of the same polymorphic inheritance hierarchy this is the information i am trying to convey here so this is bad don't do something like this if you do this you're going to get undefined behavior or you're even going to get a bunch of compiler errors if you are lucky this is really all we set up to do in this lecture showing you that you can use dynamic casts we are going to stop here in this lecture the next one we're going to show you what happens if you try to call a polymorphic function from a destructor go ahead and finish up here and meet me there in this lecture i am going to give you a warning and that is to never call virtual functions from constructors or destructors i am going to repeat this never never call virtual or polymorphic functions either from constructors or destructors and we're going to explore why we're going to be using this inheritance hierarchy we're going to have a base class called base how creative we're going to inherit from base and create derived which is our inherited class and we're going to be using this to explore why we can't call virtual functions from constructors and destructors this is what our code is going to look like the base class is going to have a protected member variable it's going to have a bunch of virtual functions we will have a virtual function to set things up and it is just going to set the value of our member variable to 10 and we're going to have a virtual function called cleanup which is going to maybe do some cleanup we're going to see how this works out we also have a method to get the value but i don't think we will use this but you can keep this and if you want notice that we are trying to call the setup method from the constructor and you see that we have a comment that says that this is going to do static binding but we're going to see why in a minute so this is our base class we can derive from this class and create our derived class we're going to inherit publicly and we are going to override the methods we have in the base class we're going to override the setup method as you see here we're going to override the cleanup", "108596.64 - 108897.12000000001": "our destructor is also going to be virtual because we are good c plus plus citizens and this is the setup we have once you have your inheritance hierarchy set up you're going to do something like this because you want polymorphic behavior you're going to set up the base pointer and you're going to use that to manage a derived object and you can do something like this now considering this statement here i want you to think about the order in which constructors and destructors are going to be called we have touched on this subject before and we are going to revisit this because it is really important in terms of calling virtual functions in destructors and destructors so when we do something like this the base part of this object is going to be wealth first so we are going to call the base constructor first we're going to set up the best part of us after that we're going to set up the derived part of us and we're going to call the derived constructor and after the derived part of us is set up we can use our object like we do always so we're going to use our object to do whatever it is we want to do when the time comes for this object to be destroyed we're going to destroy the derived part first and then we're going to destroy the base part first now that we have considered this order try to think about the setup when we call a virtual function from a constructor that's what we're going to look at first the best constructor is going to be called but notice that by the time we call the base constructor the derived part of us won't be set up yet so if we try to call a virtual function in the base constructor there won't be a derived part to call the most specialized method for so the compiler will notice that we don't have a derived part yet we will be at this stage building the base part and if we call a virtual polymorphic function we want the most specific parts to be called which should live in the derived part but we haven't done the derived part yet we are still building the base part of us so the compiler is going to notice that we don't have a derived part and it is going to call the base version of our virtual function that's why we said that if you call a virtual function from a constructor or a destructor you're going to get static binding results if you call a virtual function you want the most specific version called but we don't have that yet in the base part because the derived part haven't been set up that's why we get static binding results i hope this makes sense and we're going to get to the same result if you try to call a virtual function from a destructor if we get to the point where our object needs to be destroyed the derived part is going to be wiped out first we're going to be left with the base destructor and when we hit this base destructor and call a virtual function that would mean to call the most specialized version of that method but the derived part of our object has been already wiped down so this is no longer existent and we are trying to call the method on this so the compiler is going to do the next best thing it can do it is going to call the best version of our virtual function and again we are going to get static binding results that's why it isn't really wise to call a virtual function either from a constructor or a destructor now some of you must be asking what if i really need to do setup and clean up in the way that we set up these things in our classes what if this method is really useful maybe it is setting up things we're going to be using in our application we really need this and the most logical point to call this is the base constructor well you shouldn't really put these in a constructor what you could do is maybe call this virtual method on your object directly when the object has finished being a constructor that's going to be a better place to do this because if you put that in a constructor or a destructor you're not going to get dynamic binding results and that's going to be really bad so to sum up calling a virtual function from a constructor or a destructor want to give you polymorphic or dynamic binding results the call will never go to a more derived class than the currently executing constructor or disruptor and we will get static binding results this is the idea i want to convey here and as a guideline you should never call virtual functions or polymorphic functions from constructors or disruptors if you really need this the next best thing you can do is to call your virtual functions directly on your object after the object has been properly set up we can do something like this and call our setup method and then we can call cleanup when we think that we need to clean up and you call cleanup after you construct the object and you call delete after you clean up your object this is going to do whatever it is you", "108897.12000000001 - 109197.28": "functions and the calls to these virtual functions want to be leaving inside a constructor or a disruptor and this is going to work really well now that you know this we're going to head over to visual studio code and play with us a little more here we are in our working folder the current project is polymorphic functions and the structures we should really say with constructors and instructors but this is going to do we're going to grab our template files and we're going to put them in place and we are going to open this little guy in visual studio code by dragging and dropping here this is going to give us our main cpp file we can clean up a little bit remove whatever it is we don't need and i am just going to put in my classes i am going to do that in the main cpp file because that's going to be much easier to follow we have our base class it is going to have a single member variable called m value and we will have a virtual destructor we will have a bunch of virtual functions one is going to be setup which is going to set our value the other is going to be cleanup which is going to be doing some cleanup here we will also have a getvalue method which will get this value and print it out if we want but it is really not that useful here we will also create a derived class which is going to inherit publicly from base it is not going to have its own member variable all it's going to do is set up a bunch of overrides for the virtual functions we have in the base class we're going to override setup and in derived we're going to set our value to 100 and we're going to clean up and put a message that we are cleaning up here once we have this set up we can head over in the main function and set up a base pointer which is going to be managing a derived object a classic setup for polymorphic behavior so we're going to say base and i'm going to say p bass and we're going to say equals new derived this is going to give us our object which is managed by a base pointer and one thing i didn't show you is that we are calling the setup virtual function from the base constructor this is what we want to see we want to see what is happening here now if we call this setup function we would expect polymorphism to kick in because this is a virtual function if the derived part is available we will call the most specific setup function and that would set up the value to be 100 here if we get the value that's what we would get let's see what we get here if we try to get the value that we have in this object here so we will get auto value and we're going to say p base get value we have this function here and we will try to print this out okay this is something we can do in our c plus bus program and we're going to see the value we get because we are calling this virtual function we expect polymorphism to kick in and if polymorphism kicks in we're going to call the most specialized version of our virtual function here that would be the override we have in derived and that would give us 100. so one would get to get 100 printed out here but let's see what we get we're going to run this through gcc our favorite compiler the builder is going to be good we can clear or bring up a powershell window we're going to clear now and run rooster we're going to see that the base constructor is going to be called base setup was called you see we called the base version of this and the derived constructor will be called and we're going to see that the value doesn't exist oh we didn't put the value out let's do that my bad here we're going to build again we're going to use gcc to build and the world is good we can clear and run rooster now we see that the base setup method was called and set the value to b10 and we are really getting static binding results because we are calling the setup method from the base class and the base version is being called so this is classic static binding behavior but we want polymorphic behavior to be working here but we just saw the reason why this is in the slides by the time we call this virtual function we haven't set up the derived part of us yet and we have no way to call this virtual function which lives in the derived part of us so the compiler is going to do the next best thing it can do it's going to call the best version of this method and we are going to get static binding results and we are going to get the same results if we try to call a virtual function from the destructor for example if we go in our destructor here let's see if we can find it we're going to go in our instructor here and say this and say cleanup can do something like this and you're going to see that the cleanup version we call is the base version of cleanup and we don't really want to do something like this we want the most derived cleanup version to be called but we", "109197.28 - 109496.72": "call this virtual function from our base class the derived part will already have been wiped out so it won't be available and the compiler will do the next best thing it can do it is going to call the best version of our cleanup function here i hope this makes sense again to really drive this home i realize this can be confusing to many people especially beginners if we are calling a virtual function from a constructor we will call that virtual function when we hit the base constructor but by the time we hit the base constructor the derived part of us hasn't been constructed yet so if we try to call a polymorphic function needing to hold the derived implementation that won't be available and the compiler will do the next best thing it can do it is going to call the base version the same phenomenon is going to happen in the destructor when we are done using our object we will destroy the derived part information first and when we hit the base destructor and call a virtual function there won't be a most specialized version of the virtual function because the derived part has been already destroyed and it doesn't exist anymore so if we call a virtual function from the base destructor we will get the best version called and this will give us static binding behavior this is what we are experiencing here okay so let's try and run this program and see what we get we will print out value here which is going to give us static binding results but we want to see which version of cleanup is called this is what we want to see here we're going to run the task to build with gcc the world is going to be good as usual we're going to clear and run rooster and i'm going to see base constructor called derived constructor called and we're going to have a value which is a junk value because we never initialize this value but we don't see our destructure is called what is going on here let's investigate this a little more the reason is we are not explicitly releasing this memory here through the base pointer let's do that we're going to delete p base here and we're going to run again we're going to weld with gcc now our destructors should be called we're going to run rooster and we are going to see that the base cleanup version was called and again this is giving us static binding results you don't want something like this so if you want to get to this behavior i would advise not to call the cleanup or setup functions inside constructors or destructors and that's the guideline i gave in the slides you should really never call virtual functions either from constructors or disruptors especially if you are doing this from a parent class hoping to get the most specific virtual function called through polymorphism if you want to do that the best thing you can do is to call the cleanup functions and is to call the setup and cleanup functions after your object has been properly constructed or before your object gets to be destroyed so what you can do here is call the setup method on the pbes pointer here let's do that and we're going to call setup this is going to call our virtual function and we are going to get polymorphic behavior this is going to print a 100 as we expect because it will call the derived version of setup here and before we delete our object we will need to call the cleanup function if we need to do some custom cleanup here so i'm going to say base and call the cleanup function and this is going to give us the behavior we want we're going to build our program pass this through gcc the both is going to be good we can clear and run rooster and we are going to see that this constructor was called derived constructor was called we will call the derived version of setup our value will be 100 and when we get to release or clean up our memory the derived version of cleanup will be called and then we will destroy the derived part of us and then we will destroy the base part of us this is going to work in line with the behavior we are familiar with with polymorphism and this is really cool so this is what you should do you should never call virtual functions from distractors and constructors because that's going to give you static binding results and what you want in this case is really dynamic binding behavior this is really all i have to share in this lecture i hope you found it interesting we are going to stop here in this one the next one we're going to learn about the type id operator that can come in handy especially if you want to debug polymorphic code in your c plus plus program go ahead and finish up here and meet me there in this lecture we're going to learn about pure virtual functions and abstract classes and pure", "109496.72 - 109796.64": "have in c plus plus to mean that the method isn't meant to be implemented in the base class here we have a simple inheritance hierarchy to try and drive this home the base class is shape and we are deriving from this class to create a circle class and on the other side we are deriving to create a rectangle class if we look in the shape class we have two virtual methods one is going to be used to compute the perimeter of the shape the other is going to be used to compute the surface of the shape but if we go down in our inheritance classes we're going to see that we have the same methods these are going to be overrides of what we have in the base class but the special thing about this inheritance hierarchy is that we don't have implementations for these methods in the base class here and this is by design if you think about it this is an abstract shape we don't know if it's a rectangle we don't know if it's a circle we don't know if it is a triangle so we don't really have concrete information we can use to properly compute its perimeter and its surface so it makes sense to really leave in the declaration for these methods but leave the implementation details to inheriting classes because these classes are going to have concrete information we can use to reliably compute the perimeter and the surface and we can get this information here so in c plus plus we mean this kind of design by setting up these methods as pure virtual functions and what this is going to tell the compiler is these methods are not meant to be implemented in the base class they are meant to be overridden and implemented by inheritance classes and another side effect of this is that the compiler is going to prevent you from creating objects of this class because it really doesn't make sense to create an object of shaping your design if you want to be able to compute its perimeter if you want to be able to compute its surface so why bother creating an object that you won't really be using in your c plus plus program the meaning for this base class is just to be a an idea or a representation of a shape without really going into the concrete implementation of how that shape really works hopefully this makes sense so let's see how we can do this in code here we have a simple class which is going to be our shape class we are going to have two virtual functions we're going to have the perimeter function we're going to have the surface function these are going to be virtual functions or virtual member functions i should say but we are going to make them pure virtual functions by using the syntax you see here so we're going to prepare an echo zero and this is going to tell the compiler that these are pure virtual functions once you set up these functions a few things are going to happen in your class this class is going to become an abstract class in that you want to be able to create objects of this class anymore if you try to do that you will get a compiler error another thing is that you don't need to put in implementations for these methods because you marked them as pure virtual and what this means is that the implementations will be put in by inheriting downstream classes because they will have concrete information to compute the perimeter or the surface as we have here so we don't need to bother with definitions for these functions here if you even try to put in a definition here you're going to get a compiler error because this is a virtual function we have no business putting an implementation in the base class here these are meant to be implemented by downstream inheritance classes okay once we have our ship class and our inheritance hierarchy we can try to run this in our code for example if we try and create a shape object we're going to get a compiler error because shape is an abstract class so we can't create objects of it and i don't think i made this super clear once you set up at least one pure virtual function in your class the class is automatically going to become an abstract class and what that means is that you want to be able to create objects of this class so this is an abstract class we have here and if we try to create an object of it as we are doing on this line here this is going to give us a compiler error but we can still use a base pointer to manage a derived object a common setup we do with polymorphism so for example here we can set up a shape pointer and use this to manage a rectangle object if we call the surface member function on our base pointer this is going to do a polymorphic call and we will get the surface of the rectangle and we're going to print this out here you're going to see that this is going", "109796.64 - 110096.72": "to manage a circle object as we see here if we call the surface method this is going to do polymorphism and it is going to call the surface version of the circle class and we can see it printed out here this is the design we can achieve even if shape is an abstract class we can't create direct objects of shape as we are doing here but we can use a base pointer or a shape pointer to manage derived object through polymorphism and you need to be aware of this okay now that you have an idea about what a pure virtual function is and what an abstract class is let's see a few ideas you need to keep in mind if your class has at least one pure virtual function it will become an abstract class you already know this you can't create objects of an abstract class if you try to do that you will get a compiler error another thing i don't think amid super clear is that derived classes from an abstract class must explicitly override all the pure virtual functions from the base class if you leave in any pure virtual class that you don't put in an implementation in for your derived class is also going to become an abstract class and you want to be able to create objects of that you need to keep this in mind another thing you can't do you can't call the pure virtual functions from the constructor of the abstract class if you do this you're going to get a compiler error because we don't have implementations for these things so this is not going to work the constructor of our abstract class is used by deriving classes to build the base part of our derived objects but they are not meant to be used from the outside because we can't really create an object of an abstract class so now that you notice we're going to head over to visual studio code and play with this a little more here we are in our working folder the current project is pure virtual functions and abstract classes we are going to grab our template files and put them in place and we're going to paste them in this project here and we are going to grab the files that make up our inheritance hierarchy you are going to get these files from the resource section of the course if you want you can download them and use them like i am using them here or even better you can type the code and see how these things really work that's the best way to learn i do recommend that but we want to save on time here so i am just going to reuse these glasses that i have lying on my drive i am going to open this in visual studio code by dragging and dropping here we have our shape class here this is going to be our base class you're going to see that we have our member variable which is going to be the description for our shape we have a bunch of constructors here but the most important thing here is that we have a bunch of pure virtual functions here and if you go in the cpp file you're going to see that we don't have implementations then for the perimeter and surface functions these are pure virtual functions and we have no business putting in an implementation in the base class once we have these virtual functions in and mark them as pure virtual functions by prepending n equals zero here this class here is going to become an abstract class and what that means is that we can't create objects of this class it is meant ready to be inherited from and downstream inheritance classes are going to be forced to override these methods here otherwise they are themselves going to become abstract classes we're going to have a chance to look at this here we also have our rectangle class which is going to be inheriting from shape it is going to override our two methods we're going to override the perimeter function we're going to override the surface function for rectangle the perimeter is computed this way we're going to multiply the width by two and the height by two and we're going to add these two things up we're going to compute the surface by multiplying width and height and this is going to give us the data we want we can look at circle it is going to also inherit from shape and it is going to override our methods here if we want we can even put in a radius and a variable to keep track of pi we can do this you can really do this however you want this is just going to allow us to compute the surface relatively easily in this class here let's look at the implementation nothing special here this is just going to forward the construction of the base part of us to the base constructor and this is going to do whatever it is we want to do here let's head over to the main cpp file and actually use these things we are going to include circle and rectangle let's do that circle dot h and we're going to put in rectangle that h", "110096.72 - 110395.51199999999": "a shape object let's do that we're going to say shape and say shape pointer and this is going to be new shape we can use a default constructor and if we do something like this you're going to see that we're going to have a compiler error here we have a squiggly line but if we bring up a terminal window and look at the problems tab we're going to see that object of abstract class type shape is not allowed so shape is an abstract class now and why is it an abstract class because we have an at least one pure virtual function here we actually have two and this is going to make our shape class an abstract class what that means is that we can't create objects of this class and if we do that we're going to get a compiler error let's try and build this program we're going to pass this through gcc our favorite compiler we are going to see that the bolt is going to fail we're going to have a bunch of errors if we go up and look at the error we have invalid new expression of abstract class type shape so we can't really create an object of this let's go down and see what these errors are saying note because the following virtual functions are pure within shape and they are going to try and really be helpful in the errors that they give here and all they are saying is that we can't create objects of this class because we have pure virtual functions inside okay now you know this if a class is abstract you can't create objects of that class but you can still use a base pointer to manage derived objects of that class so let's comment this out because this is going to make our code not compile and we're going to say that this is going to give us a compiler error and we're going to try and use the base pointer to manage a rectangle object we can do this so we're going to set up a shape pointer and it is going to be managing the memory of a rectangle object we're going to go through the base pointer and call the surface method and this is going to call the implementation in rectangle because our base pointer is really managing the rectangle object if you want you can even use the type id operator to print the dynamic type of this shape rect pointer you're going to see that it is managing a rectangle you can actually do this because we learned about that in the last lecture so let's practice that we're going to say dynamic type of shape wrap and we're going to say type id and we're going to de-reference the pointer we're going to say shipwrecked and we're going to print the name of this and we're going to see it print out on our powershell window and after this we are going to print the surface that we got from this call here and we're going to see what this gives us let's try and build this program we're going to pass it through gcc our favorite compiler the bullet is going to be good we're going to clear and run rooster we're going to see that the dynamic type is rectangle you can see that right here so the base pointer is really managing a rectangle object and this is what we have here and if we call the surface method we will be calling the method on the dynamic type so we will be calling this surface method on the rectangle class and we will be using the implementation we have here so the surface function that is going to be called is what we have on line 20 in rectangle here and this is going to just be a multiplication of width and height and we're going to get 100 here because our width and height happen to be 10 and 10 so multiplying this is going to give us 100 as we see here this is really cool this is what we expect we can even use our base pointer to manage a circle object so let's do that we're going to put in a separator to be able to follow this easily and our output so let's say stdndl here and we're going to put in the code so we're going to set up a base pointer which is really going to be managing a circle object here and we will call our surface method this is going to call this method polymorphically because surface is a virtual function so we will get polymorphism here and we will call the surface method on the circle object which is really our dynamic type if we print this out we're going to see the surface printed out but if we want we can even print the dynamic type of our base pointer here so we're going to do the same thing we did for rectangle we can use our type id operator to print the dynamic type of shape circle and we're going to say shape circle here and this is going to do what we want let's look at this we're going to be printing the surface here this is exactly what we want so let's build and run we're going to pass this through gcc the bolt is going to go through as you see here if we clear and run rooster we're going to see that the dynamic type is now a circle so the base pointer or the shape pointer we", "110395.51199999999 - 110696.552": "a circle object polymorphically so if we call a virtual function on this base pointer it is going to call the most specific implementation of the surface object we have and that happens to be for this circle object here this is what i mean if we compute the surface we're going to see that it is going to be using the data we have here and we will get this number as our surface if you plug this in you're going to see that this is really right so this is really all i had to share in this lecture we can set up pure virtual functions in a base class and what that's going to do it is going to make our class an abstract class but we want also be able to put in implementations for these methods anymore in the base class because they are meant to be overwritten and implemented by downstream inheritance classes so if you go in here and try to put in an implementation we will probably get a compiler error because this is not allowed you see we have a problem here if we try to build we will get a weird compiler error let's make sure we see the compiler error so world finished with errors and we are going to see what's the problem here let's go up and see pure specifier on function definition so this is not allowed so we are really conflicting ourselves here we are marking this function as a pure virtual function and what that means and a pure virtual functions isn't meant to have a definition but we are also putting in a definition here so the compiler is going to be confused this is not something we should be doing another thing i want to point out before we wrap up this lecture is that downstream inheriting classes are forced to override and implement all the pure virtual functions from the class that they inherit from if they don't do that they are themselves going to become abstract and we want to be able to create objects of them so let's try and for example comment out the surface implementation here and that's going to make our circle class an abstract class and if we try to create an object with circle we will get a compiler error because now circle is an abstract class let's try and build and show you the compiler error and this can really be confusing if you are a beginner on this you will be wondering why you can't create objects of your class even if you didn't really explicitly put in any pure virtual function the reason is we are inheriting from an abstract class that has two pure virtual functions but we are only overriding one pure virtual function we need to override all of them otherwise our class is also going to be an abstract class let's look at the compiler error we are getting here let's go up and see if we can find it we are going to say in function in main evaluate new expression of abstract class type circle we are trying to create an object from an abstract class this is the error we have here and you should really note this so let's go back and make sure we are overriding all these stunts because we need to do that to be able to create objects of a circle and now this is going to work exactly as it should let's build and make sure of that the bullet is going to be good we are fine this is working exactly as we want this is really all i wanted you to see in this lecture i hope you found it interesting we are going to stop here in this one the next one we're going to learn about interfaces in c plus plus and they are going to be reusing the knowledge we learned about in this lecture go ahead and finish up here and meet me there in this lecture we're going to see that we can model interfaces in c plus plus using abstract classes and now there's a lot of things that might not make sense in what i just said so let's break this apart an interface can be thought of as an abstract class with only pure virtual functions and no member variable so if you have a setup like that you can call that thing an interface let's look at a simple example here here we have a simple class called stream insertable you see that it doesn't have any member variable it only has a pure virtual function here and a helper function that we could set up to help us do a few things the only specification to make this an interface is to have in only pure virtual functions and no member variables if you have in a member variable this is going to stop becoming an interface in c plus plus okay so you can think of an interface as an abstract class with at least one pure virtual function and no member variable that's going to make it an interface down here you see that an interface can be thought of as a specification of something that will be", "110696.552 - 110997.192": "but the specification itself is going to reside in the abstract class another way to think about an interface is to treat an interface as a thing you can attach to your types to give them superpowers for example this stream insertable interface has a single job and that's going to allow our types to insert data into output streams like sddc out this is the only thing this interface is going to add to our times so we can take this interface and attach that to a point class for example and we will automatically be able to print point objects to the output stream and we want to need to overload the stream output operator in the point class we can do the same thing to our bird class we can do the same thing to our dog class and we will be able to print these things without having to overload the stream output operator hopefully you can see how powerful this is if we manage to set up this kind of relationship between our type and our interfaces so again an interface is something you can attach to your types to give them powers or features that they originally didn't have and that's going to save you from having to implement these features separately in each class for real time so this is a huge time saver now you must be asking how do i take my interface and attach it to my type well the way c plus plus does this you have to inherit from the interface from your type to attach the interface to your type so for example if we wanted to attach this interface to our point class what we would do is something like this we would set up our point class and inherit from our interface which is stream insertable the moment we do this our point is going to be able to print thanks to the console through the stream output operator but hopefully you can see that something is missing how does our point class know how to print stuff if we go up and look at our stream insertable interface we're going to see that it is declaring a stream output operator it is this thing that is used to print data to the output stream you see this is a regular output stream operator we will be printing to sddo stream and the object is named out here and we will be printing whatever operand that is passed as a second parameter here but the catches we will need to set up a virtual function that will need to be implemented by whoever inherits from our interface here and this is going to be super powerful we are going to take over the job to print to the output stream but we will let inheriting download classes to specify what we print and they are going to specify that in this virtual method let's look at our point class again and really put the puzzles together here and understand how this works okay this is our point class and it is going to be inheriting from our interface and it is going to implement our virtual function here we are going to set it up here and we are going to mark it as an override because it is overriding a method that comes from our stream insertable interface here and it is going to specify which data we print to the output stream and how the data is going to be printed out you can specify these things here we're going to format the data in a point and we're going to be using these square brackets to put mx and my here and notice that this is an override so the inheritance class has all the information we need to put in our output stream operator and we will do that through our stream insert override here now let's go back to our stream insertable interface to see how our output stream operator actually works what we have here is what would be a header and this is going to just put in a declaration for this but we can even look at its implementation the implementation for our output stream operator may look something like this we are going to pass in the first operand and the second operand here but notice what we are doing here we are going to call the stream insert virtual function on our operand here and this is going to call the most specific implementation we can find for the stream insert if we are trying to print a circle for example this is going to call the stream insert override on a circle object if we are trying to print a point this is going to call this method on our point object and this is going to use polymorphism because our second operand here is pass by reference hopefully you can see how this is super powerful i know this is convoluted because we are jumping around trying to explain this but i couldn't really come up with an easier way to put", "110997.192 - 111296.55200000001": "really see the power of this but this is really the power of interfaces we can design our features and wrap them in an interface and we can really attach that interface to any type we have in our c plus plus program and that type is going to automatically inherit the features that we have set up in our interface for example now that we have attached this interface to our point here we can print our points on the output stream and this is going to work automatically you see that we don't need to set up an output stream operator on our class altogether we can even go further and attach this interface to a full inheritance hierarchy for example if we have our base class to be animal and we inherit from this class to create all kinds of crazy classes we can go on and attach our interface to the base class here and this is going to make all our classes in our inheritance hierarchy have the features that the interface has brought to the base class so for example we can attach our interface to the animal class by inheriting from stream insertable here and this is going to give our animal the powers to be printed out to output streams and this is going to be powered by the virtual function that we are overriding here you see we are going to specify which data to print in our animal class and how the data is going to be printed out here and we can do that in this override and this is super powerful once we do this we're going to go to each class in our inheritance hierarchy and implement the stream insert override because if we don't do that this class is also going to become an abstract class because it is inheriting from a class that has a pure virtual function remember if you inherit from a class that has at least one pure virtual function you will be forced to implement all the pure virtual functions that come from your parent class if you don't do that you are going to become an abstract class yourself and we don't really want that that's why we are overriding the stream insert override here and with this we are going to specify which information to print from our object here and here we are going to put out the description and the wing color and this is the format we specify here and this method is going to be called by our output stream operator which is coming from our stream insertable interface hopefully you can see how this is super powerful okay now that you know this we're going to head over to visual studio code and play with us a little more here we are in our working folder the current project is abstract classes as interfaces we're going to grab our template files and put the data in place and i'm going to copy this and put that in here we are going to put in the files we're going to be using in our inheritance hierarchy you see we have our animal hierarchy here you can grab these files from the resource section of this lecture and you can reuse them like we are using here or if you want you can even type this but i don't really recommend this because this is too much typing we just want to learn about interfaces here and that's what you should focus on so we're going to open this up in videos video code and this is going to give us all the files we need we're going to look at the top class and we will see that it is inheriting from our stream insertable interface so let's look at our stream insertable interface because this is the focus of this lecture here so it is a regular class as you see here it is class stream insertable we're going to set up an output stream operator and it is really like any other output stream operator you have seen we're going to pass the second operand by reference and we are going to specify our pure virtual function which is going to be implemented by downstream inheriting classes from this class here and this is going to set up polymorphism and what this will do is if we call this method on our second operand here we are going to call this method polymorphically so if you are trying to print a point we are going to call this method on a point object and we will print it out exactly how the point wants to be printed if we are printing a circle we will call this stream insert method on the circle and we will print a circle exactly how a circle wants to be printed out let's look at the implementation and it is nothing really complicated we're going to specify our output stream object as the first parameter here and the second parameter is what we want to print out we will pass this by reference and this is going to allow us to do polymorphism remember that stream insertable is really going to become our top base class so we will basically be setting up stream insertable polymorphism here you", "111296.55200000001 - 111597.12000000001": "to call our stream insert method on our operand and we're going to pass the stream output we want to print on and we're going to return this output stream to really make this behave like a regular output stream operator to allow output chaining in our operator here once we have this stream insertable interface we can really use it however we want let's head over to the main cpp file and try to play with us so what we are going to do is crack this open and we are going to remove whatever it is we don't need we are going to include our interface so we're going to include stream insertable let's do that insertable.h i think this is the name and we're going to set up a point class which we wish to be printed out on the output stream notice that we want to inherit from stream insertable and what this is really doing is attaching the interface to the point class here and because this stream insertable interface has a pure virtual function we need to override this pure virtual function here if we don't we want to be able to create objects of our point here let's go down and show you that we're going to get that problem if we don't do that we're going to say point and say p1 and for example put in 10 and 20 we will have a compiler error because now the point class is an abstract class because it is inherited from a class that has a pure virtual function and it is not overriding that pure virtual function so in other words this class still has a non-implemented pure virtual function that's why it is an abstract class and we can't create an object of it if we're trying to run this code we're going to pass this through gcc we will get a compiler okay we have a compiler error here and we need to fix this all we need to do is to implement the interface that comes from our stream insertable interface here so we can grab our pure virtual function and implement it in our main cpp file for the point class we're going to put it in here and we will remove the pure virtual function specifier here and we will put in an implementation we want to specify that this is an override of a method that is coming from our upstream parent class and we are going to head over in the body of our function and put in the information we want to put out this is a point object so we just want to print the m x coordinate and the m y coordinate here and this is the format that we want and at this moment the job of this function is really done and it will be picked up polymorphically if somebody tries to call this on a point object through polymorphism and this is going to work now that we have this point we can try and build and make sure this is working let's make sure we don't have the compiler error anymore the world finished successfully so we are cool here but what we want to see is that we are able to print point objects because that's the whole point of attaching this interface to our point class here so what we are going to do is print this out we're going to say sddc out we're going to say p1 and we're going to say p1 here this is how we would use our output stream operator you see we don't have a compiler error this is really magic some of you are going to ask how is this even working somebody is going to look at your class they are going to look you don't have an output stream operator but you can print your objects so how is this working well this is working through the magic of interfaces we are attaching this interface to our point class and this is going to give our class the powers that come from this interface and one of those powers is to use the output stream operator we get from this interface we can use that directly and what this is going to do let's look at the implementation of this interface this is going to just call the stream insert virtual method on the object that we pass as a second parameter in this operator here and the second parameter happens to be the point that we are printing here so what this is really going to do is something like this we're going to try and figure out what the compiler is going to try and do we are going to say p1 and we're going to say operator stream output and we're going to say stdc out that's the stream we want to be printing to and the point we want to print is p1 this is basically what the compiler is going to do and it is going to print our thumb and this method is available in our stream insertable header and it is a friend of our interface that's why we are able to do something like this accessing the data from our interface let's build and actually show you that", "111597.12000000001 - 111897.51199999999": "pass this through our gcc compiler the build is going to be good so we can clear not clear we're going to control z on this and we're going to bring up a powershell window and we're going to clear this time and run rooster you see that we are creating our point here and this is really cool we can even uncomment this and we're going to use sddc out because the compiler is going to take this and turn that into this and we have the ability to have code that is much more readable by c plus plus developers out there we're going to build and run this again the build is going to be good we can clear and run rooster and this is going to print our point here this is really cool but this is not the end of our store we can even print an entire inheritance hierarchy look at what we did at our animal class here we attached this interface to our animal class and the moment we do that we need to override the pure virtual function that comes with this interface and that's what we did down here we have overwritten the stream insert virtual function and in the body we're going to specify which data we want to print and how to print that data that's the whole point of this override we are doing here we are going to do the same thing in each inheritance class from animal for example if we go to feline we're going to do exactly the same thing we are going to inherit from animal and this will indirectly inherit from our interface so we need to override the pure virtual function that comes with that interface and we do that here we're going to specify which data we want to print in this case we're going to put the description out and the first style and we are going to specify the format in which we want the data to be printed out again that's the whole point of overriding this virtual function here we're going to do the same thing on each inheritance class in our inheritance hierarchy for example we did the exact same thing for doug we did the exact same thing for a cat and we're going to do the same thing on our bird classes that's exactly what we do here specify which data to print out and how the data is going to be printed out and this stream insert override is going to be picked up by our interface when we get to call the output stream operator here notice that we are calling this thing polymorphically we are calling our stream insert method on a reference that we pass here and this is going to resolve this using dynamic binding this is going to work really well now that we have this setup we can head over to the main cpp file and really do all kinds of crazy things let's put in a separator here and we are going to play with us we are going to include the classes we need to set up our animals and we are going to put them in here we have animal feline dog cat bird pigeon and crow the moment we do this we don't need to put in this stream insertable because it is coming in directly from this but we don't need to worry about this because we have include guards in but we are going to be using smart pointers so let's include the memory header and we can set up an animal and try to print it out we will be using polymorphism so we will go through a base pointer to animal and use that to manage a dog object here we are just going to pass in the data and we will try to print this animal out notice that we are going through a base pointer calling the output stream operator so this is going to resolve the call to stream insert polymorphically and it is going to print this information at the dog level and what i mean by that is that if we go in dog we're going to find our stream insert that's going to print this information here like we want to print a dog and this is super powerful hopefully you can see how cool this is we're going to try and build this program we're going to pass this through gcc the boat is going to be good we can clear and run rooster we're going to see that we print this as a dog even if we used a base pointer to try and print this out how cool is this we can even use this to set up a bird and print it out we're going to set up a base pointer that is going to be managing a bird you can see that we are using a unique pointer here you can really use any kind of smart pointer you want we're going to print this out and this will be printed out like a bird wants to be printed out and that's going to be using the override from our bird class and that's going to say bird is going to put out the description it's going to put out the wing color and this is really going to work really well we're going to pass this through gcc again the world is going to be good we can clear and run rooster you see that we are printing out bird here and this is using polymorphism"}